{"version":3,"file":"monaco-vim.umd.js","names":["_a","strings.isFullWidthCharacter","strings.isEmojiImprecise","strings.GraphemeIterator","strings.getNextCodePoint","Position","Range","Position","Selection","Range","Position","from","Iterable","self","once","map","filter","signal","Event","buffer","stack","count","_a","event","platform.isLittleEndian","buffer.readUInt16LE","strings.isHighSurrogate","strings.escapeRegExpCharacters","strings.createRegExp","stringBuilder.hasTextDecoder","stringBuilder.getPlatformTextDecoder","toReversedString","Range","strings.escapeRegExpCharacters","_util","LanguageConfigurationService","strings.getLeadingWhitespace","strings.firstNonWhitespaceIndex","Range","Selection","Pos","signal","Position","KeyCode","editor","change","Range","monacoEditor","SelectionDirection","sel","Selection","pos","CMAdapter","CodeMirror","ctx","query","macroModeState","e","i","dir","cm","options","commandMatch","unique","numberRegex","line","global","repeat","StatusBar","VimMode"],"sources":["../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cache.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/errors.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/functional.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/buffer.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/language.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","../node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/commands/shiftCommand.js","../src/cm_adapter.ts","../src/cm/keymap_vim.ts","../src/statusbar.ts","../src/index.ts"],"sourcesContent":["/**\n * Uses a LRU cache to make a given parametrized function cached.\n * Caches just the last value.\n * The key must be JSON serializable.\n*/\nexport class LRUCachedComputed {\n    constructor(computeFn) {\n        this.computeFn = computeFn;\n        this.lastCache = undefined;\n        this.lastArgKey = undefined;\n    }\n    get(arg) {\n        const key = JSON.stringify(arg);\n        if (this.lastArgKey !== key) {\n            this.lastArgKey = key;\n            this.lastCache = this.computeFn(arg);\n        }\n        return this.lastCache;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class Lazy {\n    constructor(executor) {\n        this.executor = executor;\n        this._didRun = false;\n    }\n    /**\n     * Get the wrapped value.\n     *\n     * This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only\n     * resolved once. `getValue` will re-throw exceptions that are hit while resolving the value\n     */\n    getValue() {\n        if (!this._didRun) {\n            try {\n                this._value = this.executor();\n            }\n            catch (err) {\n                this._error = err;\n            }\n            finally {\n                this._didRun = true;\n            }\n        }\n        if (this._error) {\n            throw this._error;\n        }\n        return this._value;\n    }\n    /**\n     * Get the wrapped value without forcing evaluation.\n     */\n    get rawValue() { return this._value; }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nimport { LRUCachedComputed } from './cache.js';\nimport { Lazy } from './lazy.js';\nexport function isFalsyOrWhitespace(str) {\n    if (!str || typeof str !== 'string') {\n        return true;\n    }\n    return str.trim().length === 0;\n}\nconst _formatRegexp = /{(\\d+)}/g;\n/**\n * Helper to produce a string with a variable number of arguments. Insert variable segments\n * into the string using the {n} notation where N is the index of the argument following the string.\n * @param value string to which formatting is applied\n * @param args replacements for {n}-entries\n */\nexport function format(value, ...args) {\n    if (args.length === 0) {\n        return value;\n    }\n    return value.replace(_formatRegexp, function (match, group) {\n        const idx = parseInt(group, 10);\n        return isNaN(idx) || idx < 0 || idx >= args.length ?\n            match :\n            args[idx];\n    });\n}\n/**\n * Converts HTML characters inside the string to use entities instead. Makes the string safe from\n * being used e.g. in HTMLElement.innerHTML.\n */\nexport function escape(html) {\n    return html.replace(/[<>&]/g, function (match) {\n        switch (match) {\n            case '<': return '&lt;';\n            case '>': return '&gt;';\n            case '&': return '&amp;';\n            default: return match;\n        }\n    });\n}\n/**\n * Escapes regular expression characters in a given string\n */\nexport function escapeRegExpCharacters(value) {\n    return value.replace(/[\\\\\\{\\}\\*\\+\\?\\|\\^\\$\\.\\[\\]\\(\\)]/g, '\\\\$&');\n}\n/**\n * Removes all occurrences of needle from the beginning and end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim (default is a blank)\n */\nexport function trim(haystack, needle = ' ') {\n    const trimmed = ltrim(haystack, needle);\n    return rtrim(trimmed, needle);\n}\n/**\n * Removes all occurrences of needle from the beginning of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function ltrim(haystack, needle) {\n    if (!haystack || !needle) {\n        return haystack;\n    }\n    const needleLen = needle.length;\n    if (needleLen === 0 || haystack.length === 0) {\n        return haystack;\n    }\n    let offset = 0;\n    while (haystack.indexOf(needle, offset) === offset) {\n        offset = offset + needleLen;\n    }\n    return haystack.substring(offset);\n}\n/**\n * Removes all occurrences of needle from the end of haystack.\n * @param haystack string to trim\n * @param needle the thing to trim\n */\nexport function rtrim(haystack, needle) {\n    if (!haystack || !needle) {\n        return haystack;\n    }\n    const needleLen = needle.length, haystackLen = haystack.length;\n    if (needleLen === 0 || haystackLen === 0) {\n        return haystack;\n    }\n    let offset = haystackLen, idx = -1;\n    while (true) {\n        idx = haystack.lastIndexOf(needle, offset - 1);\n        if (idx === -1 || idx + needleLen !== offset) {\n            break;\n        }\n        if (idx === 0) {\n            return '';\n        }\n        offset = idx;\n    }\n    return haystack.substring(0, offset);\n}\nexport function convertSimple2RegExpPattern(pattern) {\n    return pattern.replace(/[\\-\\\\\\{\\}\\+\\?\\|\\^\\$\\.\\,\\[\\]\\(\\)\\#\\s]/g, '\\\\$&').replace(/[\\*]/g, '.*');\n}\nexport function stripWildcards(pattern) {\n    return pattern.replace(/\\*/g, '');\n}\nexport function createRegExp(searchString, isRegex, options = {}) {\n    if (!searchString) {\n        throw new Error('Cannot create regex from empty string');\n    }\n    if (!isRegex) {\n        searchString = escapeRegExpCharacters(searchString);\n    }\n    if (options.wholeWord) {\n        if (!/\\B/.test(searchString.charAt(0))) {\n            searchString = '\\\\b' + searchString;\n        }\n        if (!/\\B/.test(searchString.charAt(searchString.length - 1))) {\n            searchString = searchString + '\\\\b';\n        }\n    }\n    let modifiers = '';\n    if (options.global) {\n        modifiers += 'g';\n    }\n    if (!options.matchCase) {\n        modifiers += 'i';\n    }\n    if (options.multiline) {\n        modifiers += 'm';\n    }\n    if (options.unicode) {\n        modifiers += 'u';\n    }\n    return new RegExp(searchString, modifiers);\n}\nexport function regExpLeadsToEndlessLoop(regexp) {\n    // Exit early if it's one of these special cases which are meant to match\n    // against an empty string\n    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\\\s*$') {\n        return false;\n    }\n    // We check against an empty string. If the regular expression doesn't advance\n    // (e.g. ends in an endless loop) it will match an empty string.\n    const match = regexp.exec('');\n    return !!(match && regexp.lastIndex === 0);\n}\nexport function regExpFlags(regexp) {\n    return (regexp.global ? 'g' : '')\n        + (regexp.ignoreCase ? 'i' : '')\n        + (regexp.multiline ? 'm' : '')\n        + (regexp /* standalone editor compilation */.unicode ? 'u' : '');\n}\nexport function splitLines(str) {\n    return str.split(/\\r\\n|\\r|\\n/);\n}\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function firstNonWhitespaceIndex(str) {\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Returns the leading whitespace of the string.\n * If the string contains only whitespaces, returns entire string\n */\nexport function getLeadingWhitespace(str, start = 0, end = str.length) {\n    for (let i = start; i < end; i++) {\n        const chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\n            return str.substring(start, i);\n        }\n    }\n    return str.substring(start, end);\n}\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nexport function lastNonWhitespaceIndex(str, startIndex = str.length - 1) {\n    for (let i = startIndex; i >= 0; i--) {\n        const chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\n            return i;\n        }\n    }\n    return -1;\n}\nexport function compare(a, b) {\n    if (a < b) {\n        return -1;\n    }\n    else if (a > b) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\nexport function compareSubstring(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {\n    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n        let codeA = a.charCodeAt(aStart);\n        let codeB = b.charCodeAt(bStart);\n        if (codeA < codeB) {\n            return -1;\n        }\n        else if (codeA > codeB) {\n            return 1;\n        }\n    }\n    const aLen = aEnd - aStart;\n    const bLen = bEnd - bStart;\n    if (aLen < bLen) {\n        return -1;\n    }\n    else if (aLen > bLen) {\n        return 1;\n    }\n    return 0;\n}\nexport function compareIgnoreCase(a, b) {\n    return compareSubstringIgnoreCase(a, b, 0, a.length, 0, b.length);\n}\nexport function compareSubstringIgnoreCase(a, b, aStart = 0, aEnd = a.length, bStart = 0, bEnd = b.length) {\n    for (; aStart < aEnd && bStart < bEnd; aStart++, bStart++) {\n        let codeA = a.charCodeAt(aStart);\n        let codeB = b.charCodeAt(bStart);\n        if (codeA === codeB) {\n            // equal\n            continue;\n        }\n        if (codeA >= 128 || codeB >= 128) {\n            // not ASCII letters -> fallback to lower-casing strings\n            return compareSubstring(a.toLowerCase(), b.toLowerCase(), aStart, aEnd, bStart, bEnd);\n        }\n        // mapper lower-case ascii letter onto upper-case varinats\n        // [97-122] (lower ascii) --> [65-90] (upper ascii)\n        if (isLowerAsciiLetter(codeA)) {\n            codeA -= 32;\n        }\n        if (isLowerAsciiLetter(codeB)) {\n            codeB -= 32;\n        }\n        // compare both code points\n        const diff = codeA - codeB;\n        if (diff === 0) {\n            continue;\n        }\n        return diff;\n    }\n    const aLen = aEnd - aStart;\n    const bLen = bEnd - bStart;\n    if (aLen < bLen) {\n        return -1;\n    }\n    else if (aLen > bLen) {\n        return 1;\n    }\n    return 0;\n}\nexport function isLowerAsciiLetter(code) {\n    return code >= 97 /* a */ && code <= 122 /* z */;\n}\nexport function isUpperAsciiLetter(code) {\n    return code >= 65 /* A */ && code <= 90 /* Z */;\n}\nexport function equalsIgnoreCase(a, b) {\n    return a.length === b.length && compareSubstringIgnoreCase(a, b) === 0;\n}\nexport function startsWithIgnoreCase(str, candidate) {\n    const candidateLength = candidate.length;\n    if (candidate.length > str.length) {\n        return false;\n    }\n    return compareSubstringIgnoreCase(str, candidate, 0, candidateLength) === 0;\n}\n/**\n * @returns the length of the common prefix of the two strings.\n */\nexport function commonPrefixLength(a, b) {\n    let i, len = Math.min(a.length, b.length);\n    for (i = 0; i < len; i++) {\n        if (a.charCodeAt(i) !== b.charCodeAt(i)) {\n            return i;\n        }\n    }\n    return len;\n}\n/**\n * @returns the length of the common suffix of the two strings.\n */\nexport function commonSuffixLength(a, b) {\n    let i, len = Math.min(a.length, b.length);\n    const aLastIndex = a.length - 1;\n    const bLastIndex = b.length - 1;\n    for (i = 0; i < len; i++) {\n        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {\n            return i;\n        }\n    }\n    return len;\n}\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isHighSurrogate(charCode) {\n    return (0xD800 <= charCode && charCode <= 0xDBFF);\n}\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function isLowSurrogate(charCode) {\n    return (0xDC00 <= charCode && charCode <= 0xDFFF);\n}\n/**\n * See http://en.wikipedia.org/wiki/Surrogate_pair\n */\nexport function computeCodePoint(highSurrogate, lowSurrogate) {\n    return ((highSurrogate - 0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000;\n}\n/**\n * get the code point that begins at offset `offset`\n */\nexport function getNextCodePoint(str, len, offset) {\n    const charCode = str.charCodeAt(offset);\n    if (isHighSurrogate(charCode) && offset + 1 < len) {\n        const nextCharCode = str.charCodeAt(offset + 1);\n        if (isLowSurrogate(nextCharCode)) {\n            return computeCodePoint(charCode, nextCharCode);\n        }\n    }\n    return charCode;\n}\n/**\n * get the code point that ends right before offset `offset`\n */\nfunction getPrevCodePoint(str, offset) {\n    const charCode = str.charCodeAt(offset - 1);\n    if (isLowSurrogate(charCode) && offset > 1) {\n        const prevCharCode = str.charCodeAt(offset - 2);\n        if (isHighSurrogate(prevCharCode)) {\n            return computeCodePoint(prevCharCode, charCode);\n        }\n    }\n    return charCode;\n}\nexport class CodePointIterator {\n    constructor(str, offset = 0) {\n        this._str = str;\n        this._len = str.length;\n        this._offset = offset;\n    }\n    get offset() {\n        return this._offset;\n    }\n    setOffset(offset) {\n        this._offset = offset;\n    }\n    prevCodePoint() {\n        const codePoint = getPrevCodePoint(this._str, this._offset);\n        this._offset -= (codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n        return codePoint;\n    }\n    nextCodePoint() {\n        const codePoint = getNextCodePoint(this._str, this._len, this._offset);\n        this._offset += (codePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);\n        return codePoint;\n    }\n    eol() {\n        return (this._offset >= this._len);\n    }\n}\nexport class GraphemeIterator {\n    constructor(str, offset = 0) {\n        this._iterator = new CodePointIterator(str, offset);\n    }\n    get offset() {\n        return this._iterator.offset;\n    }\n    nextGraphemeLength() {\n        const graphemeBreakTree = GraphemeBreakTree.getInstance();\n        const iterator = this._iterator;\n        const initialOffset = iterator.offset;\n        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n        while (!iterator.eol()) {\n            const offset = iterator.offset;\n            const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());\n            if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {\n                // move iterator back\n                iterator.setOffset(offset);\n                break;\n            }\n            graphemeBreakType = nextGraphemeBreakType;\n        }\n        return (iterator.offset - initialOffset);\n    }\n    prevGraphemeLength() {\n        const graphemeBreakTree = GraphemeBreakTree.getInstance();\n        const iterator = this._iterator;\n        const initialOffset = iterator.offset;\n        let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n        while (iterator.offset > 0) {\n            const offset = iterator.offset;\n            const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());\n            if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {\n                // move iterator back\n                iterator.setOffset(offset);\n                break;\n            }\n            graphemeBreakType = prevGraphemeBreakType;\n        }\n        return (initialOffset - iterator.offset);\n    }\n    eol() {\n        return this._iterator.eol();\n    }\n}\nexport function nextCharLength(str, initialOffset) {\n    const iterator = new GraphemeIterator(str, initialOffset);\n    return iterator.nextGraphemeLength();\n}\nexport function prevCharLength(str, initialOffset) {\n    const iterator = new GraphemeIterator(str, initialOffset);\n    return iterator.prevGraphemeLength();\n}\nexport function getCharContainingOffset(str, offset) {\n    if (offset > 0 && isLowSurrogate(str.charCodeAt(offset))) {\n        offset--;\n    }\n    const endOffset = offset + nextCharLength(str, offset);\n    const startOffset = endOffset - prevCharLength(str, endOffset);\n    return [startOffset, endOffset];\n}\n/**\n * Generated using https://github.com/alexdima/unicode-utils/blob/main/rtl-test.js\n */\nconst CONTAINS_RTL = /(?:[\\u05BE\\u05C0\\u05C3\\u05C6\\u05D0-\\u05F4\\u0608\\u060B\\u060D\\u061B-\\u064A\\u066D-\\u066F\\u0671-\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1-\\u07EA\\u07F4\\u07F5\\u07FA\\u07FE-\\u0815\\u081A\\u0824\\u0828\\u0830-\\u0858\\u085E-\\u088E\\u08A0-\\u08C9\\u200F\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFD3D\\uFD50-\\uFDC7\\uFDF0-\\uFDFC\\uFE70-\\uFEFC]|\\uD802[\\uDC00-\\uDD1B\\uDD20-\\uDE00\\uDE10-\\uDE35\\uDE40-\\uDEE4\\uDEEB-\\uDF35\\uDF40-\\uDFFF]|\\uD803[\\uDC00-\\uDD23\\uDE80-\\uDEA9\\uDEAD-\\uDF45\\uDF51-\\uDF81\\uDF86-\\uDFF6]|\\uD83A[\\uDC00-\\uDCCF\\uDD00-\\uDD43\\uDD4B-\\uDFFF]|\\uD83B[\\uDC00-\\uDEBB])/;\n/**\n * Returns true if `str` contains any Unicode character that is classified as \"R\" or \"AL\".\n */\nexport function containsRTL(str) {\n    return CONTAINS_RTL.test(str);\n}\nconst IS_BASIC_ASCII = /^[\\t\\n\\r\\x20-\\x7E]*$/;\n/**\n * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \\n, \\r, \\t\n */\nexport function isBasicASCII(str) {\n    return IS_BASIC_ASCII.test(str);\n}\nexport const UNUSUAL_LINE_TERMINATORS = /[\\u2028\\u2029]/; // LINE SEPARATOR (LS) or PARAGRAPH SEPARATOR (PS)\n/**\n * Returns true if `str` contains unusual line terminators, like LS or PS\n */\nexport function containsUnusualLineTerminators(str) {\n    return UNUSUAL_LINE_TERMINATORS.test(str);\n}\nexport function isFullWidthCharacter(charCode) {\n    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns\n    // http://jrgraphix.net/research/unicode_blocks.php\n    //          2E80 - 2EFF   CJK Radicals Supplement\n    //          2F00 - 2FDF   Kangxi Radicals\n    //          2FF0 - 2FFF   Ideographic Description Characters\n    //          3000 - 303F   CJK Symbols and Punctuation\n    //          3040 - 309F   Hiragana\n    //          30A0 - 30FF   Katakana\n    //          3100 - 312F   Bopomofo\n    //          3130 - 318F   Hangul Compatibility Jamo\n    //          3190 - 319F   Kanbun\n    //          31A0 - 31BF   Bopomofo Extended\n    //          31F0 - 31FF   Katakana Phonetic Extensions\n    //          3200 - 32FF   Enclosed CJK Letters and Months\n    //          3300 - 33FF   CJK Compatibility\n    //          3400 - 4DBF   CJK Unified Ideographs Extension A\n    //          4DC0 - 4DFF   Yijing Hexagram Symbols\n    //          4E00 - 9FFF   CJK Unified Ideographs\n    //          A000 - A48F   Yi Syllables\n    //          A490 - A4CF   Yi Radicals\n    //          AC00 - D7AF   Hangul Syllables\n    // [IGNORE] D800 - DB7F   High Surrogates\n    // [IGNORE] DB80 - DBFF   High Private Use Surrogates\n    // [IGNORE] DC00 - DFFF   Low Surrogates\n    // [IGNORE] E000 - F8FF   Private Use Area\n    //          F900 - FAFF   CJK Compatibility Ideographs\n    // [IGNORE] FB00 - FB4F   Alphabetic Presentation Forms\n    // [IGNORE] FB50 - FDFF   Arabic Presentation Forms-A\n    // [IGNORE] FE00 - FE0F   Variation Selectors\n    // [IGNORE] FE20 - FE2F   Combining Half Marks\n    // [IGNORE] FE30 - FE4F   CJK Compatibility Forms\n    // [IGNORE] FE50 - FE6F   Small Form Variants\n    // [IGNORE] FE70 - FEFF   Arabic Presentation Forms-B\n    //          FF00 - FFEF   Halfwidth and Fullwidth Forms\n    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]\n    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E\n    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul\n    // [IGNORE] FFF0 - FFFF   Specials\n    return ((charCode >= 0x2E80 && charCode <= 0xD7AF)\n        || (charCode >= 0xF900 && charCode <= 0xFAFF)\n        || (charCode >= 0xFF01 && charCode <= 0xFF5E));\n}\n/**\n * A fast function (therefore imprecise) to check if code points are emojis.\n * Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js\n */\nexport function isEmojiImprecise(x) {\n    return ((x >= 0x1F1E6 && x <= 0x1F1FF) || (x === 8986) || (x === 8987) || (x === 9200)\n        || (x === 9203) || (x >= 9728 && x <= 10175) || (x === 11088) || (x === 11093)\n        || (x >= 127744 && x <= 128591) || (x >= 128640 && x <= 128764)\n        || (x >= 128992 && x <= 129008) || (x >= 129280 && x <= 129535)\n        || (x >= 129648 && x <= 129782));\n}\n// -- UTF-8 BOM\nexport const UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);\nexport function startsWithUTF8BOM(str) {\n    return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);\n}\nexport function containsUppercaseCharacter(target, ignoreEscapedChars = false) {\n    if (!target) {\n        return false;\n    }\n    if (ignoreEscapedChars) {\n        target = target.replace(/\\\\./g, '');\n    }\n    return target.toLowerCase() !== target;\n}\n/**\n * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.\n */\nexport function singleLetterHash(n) {\n    const LETTERS_CNT = (90 /* Z */ - 65 /* A */ + 1);\n    n = n % (2 * LETTERS_CNT);\n    if (n < LETTERS_CNT) {\n        return String.fromCharCode(97 /* a */ + n);\n    }\n    return String.fromCharCode(65 /* A */ + n - LETTERS_CNT);\n}\nfunction breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {\n    // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules\n    // !!! Let's make the common case a bit faster\n    if (breakTypeA === 0 /* Other */) {\n        // see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table\n        return (breakTypeB !== 5 /* Extend */ && breakTypeB !== 7 /* SpacingMark */);\n    }\n    // Do not break between a CR and LF. Otherwise, break before and after controls.\n    // GB3                                        CR × LF\n    // GB4                       (Control | CR | LF) ÷\n    // GB5                                           ÷ (Control | CR | LF)\n    if (breakTypeA === 2 /* CR */) {\n        if (breakTypeB === 3 /* LF */) {\n            return false; // GB3\n        }\n    }\n    if (breakTypeA === 4 /* Control */ || breakTypeA === 2 /* CR */ || breakTypeA === 3 /* LF */) {\n        return true; // GB4\n    }\n    if (breakTypeB === 4 /* Control */ || breakTypeB === 2 /* CR */ || breakTypeB === 3 /* LF */) {\n        return true; // GB5\n    }\n    // Do not break Hangul syllable sequences.\n    // GB6                                         L × (L | V | LV | LVT)\n    // GB7                                  (LV | V) × (V | T)\n    // GB8                                 (LVT | T) × T\n    if (breakTypeA === 8 /* L */) {\n        if (breakTypeB === 8 /* L */ || breakTypeB === 9 /* V */ || breakTypeB === 11 /* LV */ || breakTypeB === 12 /* LVT */) {\n            return false; // GB6\n        }\n    }\n    if (breakTypeA === 11 /* LV */ || breakTypeA === 9 /* V */) {\n        if (breakTypeB === 9 /* V */ || breakTypeB === 10 /* T */) {\n            return false; // GB7\n        }\n    }\n    if (breakTypeA === 12 /* LVT */ || breakTypeA === 10 /* T */) {\n        if (breakTypeB === 10 /* T */) {\n            return false; // GB8\n        }\n    }\n    // Do not break before extending characters or ZWJ.\n    // GB9                                           × (Extend | ZWJ)\n    if (breakTypeB === 5 /* Extend */ || breakTypeB === 13 /* ZWJ */) {\n        return false; // GB9\n    }\n    // The GB9a and GB9b rules only apply to extended grapheme clusters:\n    // Do not break before SpacingMarks, or after Prepend characters.\n    // GB9a                                          × SpacingMark\n    // GB9b                                  Prepend ×\n    if (breakTypeB === 7 /* SpacingMark */) {\n        return false; // GB9a\n    }\n    if (breakTypeA === 1 /* Prepend */) {\n        return false; // GB9b\n    }\n    // Do not break within emoji modifier sequences or emoji zwj sequences.\n    // GB11    \\p{Extended_Pictographic} Extend* ZWJ × \\p{Extended_Pictographic}\n    if (breakTypeA === 13 /* ZWJ */ && breakTypeB === 14 /* Extended_Pictographic */) {\n        // Note: we are not implementing the rule entirely here to avoid introducing states\n        return false; // GB11\n    }\n    // GB12                          sot (RI RI)* RI × RI\n    // GB13                        [^RI] (RI RI)* RI × RI\n    if (breakTypeA === 6 /* Regional_Indicator */ && breakTypeB === 6 /* Regional_Indicator */) {\n        // Note: we are not implementing the rule entirely here to avoid introducing states\n        return false; // GB12 & GB13\n    }\n    // GB999                                     Any ÷ Any\n    return true;\n}\nclass GraphemeBreakTree {\n    constructor() {\n        this._data = getGraphemeBreakRawData();\n    }\n    static getInstance() {\n        if (!GraphemeBreakTree._INSTANCE) {\n            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();\n        }\n        return GraphemeBreakTree._INSTANCE;\n    }\n    getGraphemeBreakType(codePoint) {\n        // !!! Let's make 7bit ASCII a bit faster: 0..31\n        if (codePoint < 32) {\n            if (codePoint === 10 /* LineFeed */) {\n                return 3 /* LF */;\n            }\n            if (codePoint === 13 /* CarriageReturn */) {\n                return 2 /* CR */;\n            }\n            return 4 /* Control */;\n        }\n        // !!! Let's make 7bit ASCII a bit faster: 32..126\n        if (codePoint < 127) {\n            return 0 /* Other */;\n        }\n        const data = this._data;\n        const nodeCount = data.length / 3;\n        let nodeIndex = 1;\n        while (nodeIndex <= nodeCount) {\n            if (codePoint < data[3 * nodeIndex]) {\n                // go left\n                nodeIndex = 2 * nodeIndex;\n            }\n            else if (codePoint > data[3 * nodeIndex + 1]) {\n                // go right\n                nodeIndex = 2 * nodeIndex + 1;\n            }\n            else {\n                // hit\n                return data[3 * nodeIndex + 2];\n            }\n        }\n        return 0 /* Other */;\n    }\n}\nGraphemeBreakTree._INSTANCE = null;\nfunction getGraphemeBreakRawData() {\n    // generated using https://github.com/alexdima/unicode-utils/blob/main/grapheme-break.js\n    return JSON.parse('[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]');\n}\n//#endregion\n/**\n * Computes the offset after performing a left delete on the given string,\n * while considering unicode grapheme/emoji rules.\n*/\nexport function getLeftDeleteOffset(offset, str) {\n    if (offset === 0) {\n        return 0;\n    }\n    // Try to delete emoji part.\n    const emojiOffset = getOffsetBeforeLastEmojiComponent(offset, str);\n    if (emojiOffset !== undefined) {\n        return emojiOffset;\n    }\n    // Otherwise, just skip a single code point.\n    const iterator = new CodePointIterator(str, offset);\n    iterator.prevCodePoint();\n    return iterator.offset;\n}\nfunction getOffsetBeforeLastEmojiComponent(initialOffset, str) {\n    // See https://www.unicode.org/reports/tr51/tr51-14.html#EBNF_and_Regex for the\n    // structure of emojis.\n    const iterator = new CodePointIterator(str, initialOffset);\n    let codePoint = iterator.prevCodePoint();\n    // Skip modifiers\n    while ((isEmojiModifier(codePoint) || codePoint === 65039 /* emojiVariantSelector */ || codePoint === 8419 /* enclosingKeyCap */)) {\n        if (iterator.offset === 0) {\n            // Cannot skip modifier, no preceding emoji base.\n            return undefined;\n        }\n        codePoint = iterator.prevCodePoint();\n    }\n    // Expect base emoji\n    if (!isEmojiImprecise(codePoint)) {\n        // Unexpected code point, not a valid emoji.\n        return undefined;\n    }\n    let resultOffset = iterator.offset;\n    if (resultOffset > 0) {\n        // Skip optional ZWJ code points that combine multiple emojis.\n        // In theory, we should check if that ZWJ actually combines multiple emojis\n        // to prevent deleting ZWJs in situations we didn't account for.\n        const optionalZwjCodePoint = iterator.prevCodePoint();\n        if (optionalZwjCodePoint === 8205 /* zwj */) {\n            resultOffset = iterator.offset;\n        }\n    }\n    return resultOffset;\n}\nfunction isEmojiModifier(codePoint) {\n    return 0x1F3FB <= codePoint && codePoint <= 0x1F3FF;\n}\nexport const noBreakWhitespace = '\\xa0';\nexport class AmbiguousCharacters {\n    constructor(confusableDictionary) {\n        this.confusableDictionary = confusableDictionary;\n    }\n    static getInstance(locales) {\n        return AmbiguousCharacters.cache.get(Array.from(locales));\n    }\n    static getLocales() {\n        return AmbiguousCharacters._locales.getValue();\n    }\n    isAmbiguous(codePoint) {\n        return this.confusableDictionary.has(codePoint);\n    }\n    /**\n     * Returns the non basic ASCII code point that the given code point can be confused,\n     * or undefined if such code point does note exist.\n     */\n    getPrimaryConfusable(codePoint) {\n        return this.confusableDictionary.get(codePoint);\n    }\n    getConfusableCodePoints() {\n        return new Set(this.confusableDictionary.keys());\n    }\n}\n_a = AmbiguousCharacters;\nAmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {\n    // Generated using https://github.com/hediet/vscode-unicode-data\n    // Stored as key1, value1, key2, value2, ...\n    return JSON.parse('{\\\"_common\\\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],\\\"_default\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"cs\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"de\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"es\\\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"fr\\\":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"it\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"ja\\\":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],\\\"ko\\\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"pl\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"pt-BR\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"qps-ploc\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"ru\\\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"tr\\\":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\\\"zh-hans\\\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],\\\"zh-hant\\\":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}');\n});\nAmbiguousCharacters.cache = new LRUCachedComputed((locales) => {\n    function arrayToMap(arr) {\n        const result = new Map();\n        for (let i = 0; i < arr.length; i += 2) {\n            result.set(arr[i], arr[i + 1]);\n        }\n        return result;\n    }\n    function mergeMaps(map1, map2) {\n        const result = new Map(map1);\n        for (const [key, value] of map2) {\n            result.set(key, value);\n        }\n        return result;\n    }\n    function intersectMaps(map1, map2) {\n        if (!map1) {\n            return map2;\n        }\n        const result = new Map();\n        for (const [key, value] of map1) {\n            if (map2.has(key)) {\n                result.set(key, value);\n            }\n        }\n        return result;\n    }\n    const data = _a.ambiguousCharacterData.getValue();\n    let filteredLocales = locales.filter((l) => !l.startsWith('_') && l in data);\n    if (filteredLocales.length === 0) {\n        filteredLocales = ['_default'];\n    }\n    let languageSpecificMap = undefined;\n    for (const locale of filteredLocales) {\n        const map = arrayToMap(data[locale]);\n        languageSpecificMap = intersectMaps(languageSpecificMap, map);\n    }\n    const commonMap = arrayToMap(data['_common']);\n    const map = mergeMaps(commonMap, languageSpecificMap);\n    return new AmbiguousCharacters(map);\n});\nAmbiguousCharacters._locales = new Lazy(() => Object.keys(AmbiguousCharacters.ambiguousCharacterData.getValue()).filter((k) => !k.startsWith('_')));\nexport class InvisibleCharacters {\n    static getRawData() {\n        // Generated using https://github.com/hediet/vscode-unicode-data\n        return JSON.parse('[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]');\n    }\n    static getData() {\n        if (!this._data) {\n            this._data = new Set(InvisibleCharacters.getRawData());\n        }\n        return this._data;\n    }\n    static isInvisibleCharacter(codePoint) {\n        return InvisibleCharacters.getData().has(codePoint);\n    }\n    static get codePoints() {\n        return InvisibleCharacters.getData();\n    }\n}\nInvisibleCharacters._data = undefined;\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * A position in the editor.\n */\nexport class Position {\n    constructor(lineNumber, column) {\n        this.lineNumber = lineNumber;\n        this.column = column;\n    }\n    /**\n     * Create a new position from this position.\n     *\n     * @param newLineNumber new line number\n     * @param newColumn new column\n     */\n    with(newLineNumber = this.lineNumber, newColumn = this.column) {\n        if (newLineNumber === this.lineNumber && newColumn === this.column) {\n            return this;\n        }\n        else {\n            return new Position(newLineNumber, newColumn);\n        }\n    }\n    /**\n     * Derive a new position from this position.\n     *\n     * @param deltaLineNumber line number delta\n     * @param deltaColumn column delta\n     */\n    delta(deltaLineNumber = 0, deltaColumn = 0) {\n        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);\n    }\n    /**\n     * Test if this position equals other position\n     */\n    equals(other) {\n        return Position.equals(this, other);\n    }\n    /**\n     * Test if position `a` equals position `b`\n     */\n    static equals(a, b) {\n        if (!a && !b) {\n            return true;\n        }\n        return (!!a &&\n            !!b &&\n            a.lineNumber === b.lineNumber &&\n            a.column === b.column);\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be false.\n     */\n    isBefore(other) {\n        return Position.isBefore(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be false.\n     */\n    static isBefore(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column < b.column;\n    }\n    /**\n     * Test if this position is before other position.\n     * If the two positions are equal, the result will be true.\n     */\n    isBeforeOrEqual(other) {\n        return Position.isBeforeOrEqual(this, other);\n    }\n    /**\n     * Test if position `a` is before position `b`.\n     * If the two positions are equal, the result will be true.\n     */\n    static isBeforeOrEqual(a, b) {\n        if (a.lineNumber < b.lineNumber) {\n            return true;\n        }\n        if (b.lineNumber < a.lineNumber) {\n            return false;\n        }\n        return a.column <= b.column;\n    }\n    /**\n     * A function that compares positions, useful for sorting\n     */\n    static compare(a, b) {\n        const aLineNumber = a.lineNumber | 0;\n        const bLineNumber = b.lineNumber | 0;\n        if (aLineNumber === bLineNumber) {\n            const aColumn = a.column | 0;\n            const bColumn = b.column | 0;\n            return aColumn - bColumn;\n        }\n        return aLineNumber - bLineNumber;\n    }\n    /**\n     * Clone this position.\n     */\n    clone() {\n        return new Position(this.lineNumber, this.column);\n    }\n    /**\n     * Convert to a human-readable representation.\n     */\n    toString() {\n        return '(' + this.lineNumber + ',' + this.column + ')';\n    }\n    // ---\n    /**\n     * Create a `Position` from an `IPosition`.\n     */\n    static lift(pos) {\n        return new Position(pos.lineNumber, pos.column);\n    }\n    /**\n     * Test if `obj` is an `IPosition`.\n     */\n    static isIPosition(obj) {\n        return (obj\n            && (typeof obj.lineNumber === 'number')\n            && (typeof obj.column === 'number'));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\n/**\n * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)\n */\nexport class Range {\n    constructor(startLineNumber, startColumn, endLineNumber, endColumn) {\n        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {\n            this.startLineNumber = endLineNumber;\n            this.startColumn = endColumn;\n            this.endLineNumber = startLineNumber;\n            this.endColumn = startColumn;\n        }\n        else {\n            this.startLineNumber = startLineNumber;\n            this.startColumn = startColumn;\n            this.endLineNumber = endLineNumber;\n            this.endColumn = endColumn;\n        }\n    }\n    /**\n     * Test if this range is empty.\n     */\n    isEmpty() {\n        return Range.isEmpty(this);\n    }\n    /**\n     * Test if `range` is empty.\n     */\n    static isEmpty(range) {\n        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);\n    }\n    /**\n     * Test if position is in this range. If the position is at the edges, will return true.\n     */\n    containsPosition(position) {\n        return Range.containsPosition(this, position);\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return true.\n     */\n    static containsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `position` is in `range`. If the position is at the edges, will return false.\n     * @internal\n     */\n    static strictContainsPosition(range, position) {\n        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) {\n            return false;\n        }\n        if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if range is in this range. If the range is equal to this range, will return true.\n     */\n    containsRange(range) {\n        return Range.containsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.\n     */\n    static containsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.\n     */\n    strictContainsRange(range) {\n        return Range.strictContainsRange(this, range);\n    }\n    /**\n     * Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.\n     */\n    static strictContainsRange(range, otherRange) {\n        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {\n            return false;\n        }\n        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {\n            return false;\n        }\n        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    plusRange(range) {\n        return Range.plusRange(this, range);\n    }\n    /**\n     * A reunion of the two ranges.\n     * The smallest position will be used as the start point, and the largest one as the end point.\n     */\n    static plusRange(a, b) {\n        let startLineNumber;\n        let startColumn;\n        let endLineNumber;\n        let endColumn;\n        if (b.startLineNumber < a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = b.startColumn;\n        }\n        else if (b.startLineNumber === a.startLineNumber) {\n            startLineNumber = b.startLineNumber;\n            startColumn = Math.min(b.startColumn, a.startColumn);\n        }\n        else {\n            startLineNumber = a.startLineNumber;\n            startColumn = a.startColumn;\n        }\n        if (b.endLineNumber > a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = b.endColumn;\n        }\n        else if (b.endLineNumber === a.endLineNumber) {\n            endLineNumber = b.endLineNumber;\n            endColumn = Math.max(b.endColumn, a.endColumn);\n        }\n        else {\n            endLineNumber = a.endLineNumber;\n            endColumn = a.endColumn;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    intersectRanges(range) {\n        return Range.intersectRanges(this, range);\n    }\n    /**\n     * A intersection of the two ranges.\n     */\n    static intersectRanges(a, b) {\n        let resultStartLineNumber = a.startLineNumber;\n        let resultStartColumn = a.startColumn;\n        let resultEndLineNumber = a.endLineNumber;\n        let resultEndColumn = a.endColumn;\n        let otherStartLineNumber = b.startLineNumber;\n        let otherStartColumn = b.startColumn;\n        let otherEndLineNumber = b.endLineNumber;\n        let otherEndColumn = b.endColumn;\n        if (resultStartLineNumber < otherStartLineNumber) {\n            resultStartLineNumber = otherStartLineNumber;\n            resultStartColumn = otherStartColumn;\n        }\n        else if (resultStartLineNumber === otherStartLineNumber) {\n            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);\n        }\n        if (resultEndLineNumber > otherEndLineNumber) {\n            resultEndLineNumber = otherEndLineNumber;\n            resultEndColumn = otherEndColumn;\n        }\n        else if (resultEndLineNumber === otherEndLineNumber) {\n            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);\n        }\n        // Check if selection is now empty\n        if (resultStartLineNumber > resultEndLineNumber) {\n            return null;\n        }\n        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {\n            return null;\n        }\n        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);\n    }\n    /**\n     * Test if this range equals other.\n     */\n    equalsRange(other) {\n        return Range.equalsRange(this, other);\n    }\n    /**\n     * Test if range `a` equals `b`.\n     */\n    static equalsRange(a, b) {\n        return (!!a &&\n            !!b &&\n            a.startLineNumber === b.startLineNumber &&\n            a.startColumn === b.startColumn &&\n            a.endLineNumber === b.endLineNumber &&\n            a.endColumn === b.endColumn);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    getEndPosition() {\n        return Range.getEndPosition(this);\n    }\n    /**\n     * Return the end position (which will be after or equal to the start position)\n     */\n    static getEndPosition(range) {\n        return new Position(range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    getStartPosition() {\n        return Range.getStartPosition(this);\n    }\n    /**\n     * Return the start position (which will be before or equal to the end position)\n     */\n    static getStartPosition(range) {\n        return new Position(range.startLineNumber, range.startColumn);\n    }\n    /**\n     * Transform to a user presentable string representation.\n     */\n    toString() {\n        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';\n    }\n    /**\n     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n    }\n    /**\n     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    collapseToStart() {\n        return Range.collapseToStart(this);\n    }\n    /**\n     * Create a new empty range using this range's start position.\n     */\n    static collapseToStart(range) {\n        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);\n    }\n    // ---\n    static fromPositions(start, end = start) {\n        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    static lift(range) {\n        if (!range) {\n            return null;\n        }\n        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n    }\n    /**\n     * Test if `obj` is an `IRange`.\n     */\n    static isIRange(obj) {\n        return (obj\n            && (typeof obj.startLineNumber === 'number')\n            && (typeof obj.startColumn === 'number')\n            && (typeof obj.endLineNumber === 'number')\n            && (typeof obj.endColumn === 'number'));\n    }\n    /**\n     * Test if the two ranges are touching in any way.\n     */\n    static areIntersectingOrTouching(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * Test if the two ranges are intersecting. If the ranges are touching it returns true.\n     */\n    static areIntersecting(a, b) {\n        // Check if `a` is before `b`\n        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {\n            return false;\n        }\n        // Check if `b` is before `a`\n        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {\n            return false;\n        }\n        // These ranges must intersect\n        return true;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the startPosition and then on the endPosition\n     */\n    static compareRangesUsingStarts(a, b) {\n        if (a && b) {\n            const aStartLineNumber = a.startLineNumber | 0;\n            const bStartLineNumber = b.startLineNumber | 0;\n            if (aStartLineNumber === bStartLineNumber) {\n                const aStartColumn = a.startColumn | 0;\n                const bStartColumn = b.startColumn | 0;\n                if (aStartColumn === bStartColumn) {\n                    const aEndLineNumber = a.endLineNumber | 0;\n                    const bEndLineNumber = b.endLineNumber | 0;\n                    if (aEndLineNumber === bEndLineNumber) {\n                        const aEndColumn = a.endColumn | 0;\n                        const bEndColumn = b.endColumn | 0;\n                        return aEndColumn - bEndColumn;\n                    }\n                    return aEndLineNumber - bEndLineNumber;\n                }\n                return aStartColumn - bStartColumn;\n            }\n            return aStartLineNumber - bStartLineNumber;\n        }\n        const aExists = (a ? 1 : 0);\n        const bExists = (b ? 1 : 0);\n        return aExists - bExists;\n    }\n    /**\n     * A function that compares ranges, useful for sorting ranges\n     * It will first compare ranges on the endPosition and then on the startPosition\n     */\n    static compareRangesUsingEnds(a, b) {\n        if (a.endLineNumber === b.endLineNumber) {\n            if (a.endColumn === b.endColumn) {\n                if (a.startLineNumber === b.startLineNumber) {\n                    return a.startColumn - b.startColumn;\n                }\n                return a.startLineNumber - b.startLineNumber;\n            }\n            return a.endColumn - b.endColumn;\n        }\n        return a.endLineNumber - b.endLineNumber;\n    }\n    /**\n     * Test if the range spans multiple lines.\n     */\n    static spansMultipleLines(range) {\n        return range.endLineNumber > range.startLineNumber;\n    }\n    toJSON() {\n        return this;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from './position.js';\nimport { Range } from './range.js';\n/**\n * A selection in the editor.\n * The selection is a range that has an orientation.\n */\nexport class Selection extends Range {\n    constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {\n        super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);\n        this.selectionStartLineNumber = selectionStartLineNumber;\n        this.selectionStartColumn = selectionStartColumn;\n        this.positionLineNumber = positionLineNumber;\n        this.positionColumn = positionColumn;\n    }\n    /**\n     * Transform to a human-readable representation.\n     */\n    toString() {\n        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';\n    }\n    /**\n     * Test if equals other selection.\n     */\n    equalsSelection(other) {\n        return (Selection.selectionsEqual(this, other));\n    }\n    /**\n     * Test if the two selections are equal.\n     */\n    static selectionsEqual(a, b) {\n        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&\n            a.selectionStartColumn === b.selectionStartColumn &&\n            a.positionLineNumber === b.positionLineNumber &&\n            a.positionColumn === b.positionColumn);\n    }\n    /**\n     * Get directions (LTR or RTL).\n     */\n    getDirection() {\n        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {\n            return 0 /* LTR */;\n        }\n        return 1 /* RTL */;\n    }\n    /**\n     * Create a new selection with a different `positionLineNumber` and `positionColumn`.\n     */\n    setEndPosition(endLineNumber, endColumn) {\n        if (this.getDirection() === 0 /* LTR */) {\n            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);\n    }\n    /**\n     * Get the position at `positionLineNumber` and `positionColumn`.\n     */\n    getPosition() {\n        return new Position(this.positionLineNumber, this.positionColumn);\n    }\n    /**\n     * Get the position at the start of the selection.\n    */\n    getSelectionStart() {\n        return new Position(this.selectionStartLineNumber, this.selectionStartColumn);\n    }\n    /**\n     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.\n     */\n    setStartPosition(startLineNumber, startColumn) {\n        if (this.getDirection() === 0 /* LTR */) {\n            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);\n        }\n        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);\n    }\n    // ----\n    /**\n     * Create a `Selection` from one or two positions\n     */\n    static fromPositions(start, end = start) {\n        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);\n    }\n    /**\n     * Creates a `Selection` from a range, given a direction.\n     */\n    static fromRange(range, direction) {\n        if (direction === 0 /* LTR */) {\n            return new Selection(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);\n        }\n        else {\n            return new Selection(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);\n        }\n    }\n    /**\n     * Create a `Selection` from an `ISelection`.\n     */\n    static liftSelection(sel) {\n        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);\n    }\n    /**\n     * `a` equals `b`.\n     */\n    static selectionsArrEqual(a, b) {\n        if (a && !b || !a && b) {\n            return false;\n        }\n        if (!a && !b) {\n            return true;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (!this.selectionsEqual(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Test if `obj` is an `ISelection`.\n     */\n    static isISelection(obj) {\n        return (obj\n            && (typeof obj.selectionStartLineNumber === 'number')\n            && (typeof obj.selectionStartColumn === 'number')\n            && (typeof obj.positionLineNumber === 'number')\n            && (typeof obj.positionColumn === 'number'));\n    }\n    /**\n     * Create with a direction.\n     */\n    static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {\n        if (direction === 0 /* LTR */) {\n            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);\n        }\n        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// Avoid circular dependency on EventEmitter by implementing a subset of the interface.\nexport class ErrorHandler {\n    constructor() {\n        this.listeners = [];\n        this.unexpectedErrorHandler = function (e) {\n            setTimeout(() => {\n                if (e.stack) {\n                    throw new Error(e.message + '\\n\\n' + e.stack);\n                }\n                throw e;\n            }, 0);\n        };\n    }\n    emit(e) {\n        this.listeners.forEach((listener) => {\n            listener(e);\n        });\n    }\n    onUnexpectedError(e) {\n        this.unexpectedErrorHandler(e);\n        this.emit(e);\n    }\n    // For external errors, we don't want the listeners to be called\n    onUnexpectedExternalError(e) {\n        this.unexpectedErrorHandler(e);\n    }\n}\nexport const errorHandler = new ErrorHandler();\nexport function onUnexpectedError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        errorHandler.onUnexpectedError(e);\n    }\n    return undefined;\n}\nexport function onUnexpectedExternalError(e) {\n    // ignore errors from cancelled promises\n    if (!isCancellationError(e)) {\n        errorHandler.onUnexpectedExternalError(e);\n    }\n    return undefined;\n}\nexport function transformErrorForSerialization(error) {\n    if (error instanceof Error) {\n        let { name, message } = error;\n        const stack = error.stacktrace || error.stack;\n        return {\n            $isError: true,\n            name,\n            message,\n            stack\n        };\n    }\n    // return as is\n    return error;\n}\nconst canceledName = 'Canceled';\n/**\n * Checks if the given error is a promise in canceled state\n */\nexport function isCancellationError(error) {\n    if (error instanceof CancellationError) {\n        return true;\n    }\n    return error instanceof Error && error.name === canceledName && error.message === canceledName;\n}\n// !!!IMPORTANT!!!\n// Do NOT change this class because it is also used as an API-type.\nexport class CancellationError extends Error {\n    constructor() {\n        super(canceledName);\n        this.name = this.message;\n    }\n}\n/**\n * @deprecated use {@link CancellationError `new CancellationError()`} instead\n */\nexport function canceled() {\n    const error = new Error(canceledName);\n    error.name = error.message;\n    return error;\n}\nexport function illegalArgument(name) {\n    if (name) {\n        return new Error(`Illegal argument: ${name}`);\n    }\n    else {\n        return new Error('Illegal argument');\n    }\n}\nexport function illegalState(name) {\n    if (name) {\n        return new Error(`Illegal state: ${name}`);\n    }\n    else {\n        return new Error('Illegal state');\n    }\n}\nexport class NotSupportedError extends Error {\n    constructor(message) {\n        super('NotSupported');\n        if (message) {\n            this.message = message;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function once(fn) {\n    const _this = this;\n    let didCall = false;\n    let result;\n    return function () {\n        if (didCall) {\n            return result;\n        }\n        didCall = true;\n        result = fn.apply(_this, arguments);\n        return result;\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var Iterable;\n(function (Iterable) {\n    function is(thing) {\n        return thing && typeof thing === 'object' && typeof thing[Symbol.iterator] === 'function';\n    }\n    Iterable.is = is;\n    const _empty = Object.freeze([]);\n    function empty() {\n        return _empty;\n    }\n    Iterable.empty = empty;\n    function* single(element) {\n        yield element;\n    }\n    Iterable.single = single;\n    function from(iterable) {\n        return iterable || _empty;\n    }\n    Iterable.from = from;\n    function isEmpty(iterable) {\n        return !iterable || iterable[Symbol.iterator]().next().done === true;\n    }\n    Iterable.isEmpty = isEmpty;\n    function first(iterable) {\n        return iterable[Symbol.iterator]().next().value;\n    }\n    Iterable.first = first;\n    function some(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    Iterable.some = some;\n    function find(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                return element;\n            }\n        }\n        return undefined;\n    }\n    Iterable.find = find;\n    function* filter(iterable, predicate) {\n        for (const element of iterable) {\n            if (predicate(element)) {\n                yield element;\n            }\n        }\n    }\n    Iterable.filter = filter;\n    function* map(iterable, fn) {\n        let index = 0;\n        for (const element of iterable) {\n            yield fn(element, index++);\n        }\n    }\n    Iterable.map = map;\n    function* concat(...iterables) {\n        for (const iterable of iterables) {\n            for (const element of iterable) {\n                yield element;\n            }\n        }\n    }\n    Iterable.concat = concat;\n    function* concatNested(iterables) {\n        for (const iterable of iterables) {\n            for (const element of iterable) {\n                yield element;\n            }\n        }\n    }\n    Iterable.concatNested = concatNested;\n    function reduce(iterable, reducer, initialValue) {\n        let value = initialValue;\n        for (const element of iterable) {\n            value = reducer(value, element);\n        }\n        return value;\n    }\n    Iterable.reduce = reduce;\n    /**\n     * Returns an iterable slice of the array, with the same semantics as `array.slice()`.\n     */\n    function* slice(arr, from, to = arr.length) {\n        if (from < 0) {\n            from += arr.length;\n        }\n        if (to < 0) {\n            to += arr.length;\n        }\n        else if (to > arr.length) {\n            to = arr.length;\n        }\n        for (; from < to; from++) {\n            yield arr[from];\n        }\n    }\n    Iterable.slice = slice;\n    /**\n     * Consumes `atMost` elements from iterable and returns the consumed elements,\n     * and an iterable for the rest of the elements.\n     */\n    function consume(iterable, atMost = Number.POSITIVE_INFINITY) {\n        const consumed = [];\n        if (atMost === 0) {\n            return [consumed, iterable];\n        }\n        const iterator = iterable[Symbol.iterator]();\n        for (let i = 0; i < atMost; i++) {\n            const next = iterator.next();\n            if (next.done) {\n                return [consumed, Iterable.empty()];\n            }\n            consumed.push(next.value);\n        }\n        return [consumed, { [Symbol.iterator]() { return iterator; } }];\n    }\n    Iterable.consume = consume;\n    /**\n     * Returns whether the iterables are the same length and all items are\n     * equal using the comparator function.\n     */\n    function equals(a, b, comparator = (at, bt) => at === bt) {\n        const ai = a[Symbol.iterator]();\n        const bi = b[Symbol.iterator]();\n        while (true) {\n            const an = ai.next();\n            const bn = bi.next();\n            if (an.done !== bn.done) {\n                return false;\n            }\n            else if (an.done) {\n                return true;\n            }\n            else if (!comparator(an.value, bn.value)) {\n                return false;\n            }\n        }\n    }\n    Iterable.equals = equals;\n})(Iterable || (Iterable = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { once } from './functional.js';\nimport { Iterable } from './iterator.js';\n/**\n * Enables logging of potentially leaked disposables.\n *\n * A disposable is considered leaked if it is not disposed or not registered as the child of\n * another disposable. This tracking is very simple an only works for classes that either\n * extend Disposable or use a DisposableStore. This means there are a lot of false positives.\n */\nconst TRACK_DISPOSABLES = false;\nlet disposableTracker = null;\nexport function setDisposableTracker(tracker) {\n    disposableTracker = tracker;\n}\nif (TRACK_DISPOSABLES) {\n    const __is_disposable_tracked__ = '__is_disposable_tracked__';\n    setDisposableTracker(new class {\n        trackDisposable(x) {\n            const stack = new Error('Potentially leaked disposable').stack;\n            setTimeout(() => {\n                if (!x[__is_disposable_tracked__]) {\n                    console.log(stack);\n                }\n            }, 3000);\n        }\n        setParent(child, parent) {\n            if (child && child !== Disposable.None) {\n                try {\n                    child[__is_disposable_tracked__] = true;\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n        }\n        markAsDisposed(disposable) {\n            if (disposable && disposable !== Disposable.None) {\n                try {\n                    disposable[__is_disposable_tracked__] = true;\n                }\n                catch (_a) {\n                    // noop\n                }\n            }\n        }\n        markAsSingleton(disposable) { }\n    });\n}\nfunction trackDisposable(x) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.trackDisposable(x);\n    return x;\n}\nfunction markAsDisposed(disposable) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsDisposed(disposable);\n}\nfunction setParentOfDisposable(child, parent) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.setParent(child, parent);\n}\nfunction setParentOfDisposables(children, parent) {\n    if (!disposableTracker) {\n        return;\n    }\n    for (const child of children) {\n        disposableTracker.setParent(child, parent);\n    }\n}\n/**\n * Indicates that the given object is a singleton which does not need to be disposed.\n*/\nexport function markAsSingleton(singleton) {\n    disposableTracker === null || disposableTracker === void 0 ? void 0 : disposableTracker.markAsSingleton(singleton);\n    return singleton;\n}\nexport class MultiDisposeError extends Error {\n    constructor(errors) {\n        super(`Encountered errors while disposing of store. Errors: [${errors.join(', ')}]`);\n        this.errors = errors;\n    }\n}\nexport function isDisposable(thing) {\n    return typeof thing.dispose === 'function' && thing.dispose.length === 0;\n}\nexport function dispose(arg) {\n    if (Iterable.is(arg)) {\n        let errors = [];\n        for (const d of arg) {\n            if (d) {\n                try {\n                    d.dispose();\n                }\n                catch (e) {\n                    errors.push(e);\n                }\n            }\n        }\n        if (errors.length === 1) {\n            throw errors[0];\n        }\n        else if (errors.length > 1) {\n            throw new MultiDisposeError(errors);\n        }\n        return Array.isArray(arg) ? [] : arg;\n    }\n    else if (arg) {\n        arg.dispose();\n        return arg;\n    }\n}\nexport function combinedDisposable(...disposables) {\n    const parent = toDisposable(() => dispose(disposables));\n    setParentOfDisposables(disposables, parent);\n    return parent;\n}\nexport function toDisposable(fn) {\n    const self = trackDisposable({\n        dispose: once(() => {\n            markAsDisposed(self);\n            fn();\n        })\n    });\n    return self;\n}\nexport class DisposableStore {\n    constructor() {\n        this._toDispose = new Set();\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    /**\n     * Dispose of all registered disposables and mark this object as disposed.\n     *\n     * Any future disposables added to this object will be disposed of on `add`.\n     */\n    dispose() {\n        if (this._isDisposed) {\n            return;\n        }\n        markAsDisposed(this);\n        this._isDisposed = true;\n        this.clear();\n    }\n    /**\n     * Returns `true` if this object has been disposed\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * Dispose of all registered disposables but do not mark this object as disposed.\n     */\n    clear() {\n        try {\n            dispose(this._toDispose.values());\n        }\n        finally {\n            this._toDispose.clear();\n        }\n    }\n    add(o) {\n        if (!o) {\n            return o;\n        }\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        setParentOfDisposable(o, this);\n        if (this._isDisposed) {\n            if (!DisposableStore.DISABLE_DISPOSED_WARNING) {\n                console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);\n            }\n        }\n        else {\n            this._toDispose.add(o);\n        }\n        return o;\n    }\n}\nDisposableStore.DISABLE_DISPOSED_WARNING = false;\nexport class Disposable {\n    constructor() {\n        this._store = new DisposableStore();\n        trackDisposable(this);\n        setParentOfDisposable(this._store, this);\n    }\n    dispose() {\n        markAsDisposed(this);\n        this._store.dispose();\n    }\n    _register(o) {\n        if (o === this) {\n            throw new Error('Cannot register a disposable on itself!');\n        }\n        return this._store.add(o);\n    }\n}\nDisposable.None = Object.freeze({ dispose() { } });\n/**\n * Manages the lifecycle of a disposable value that may be changed.\n *\n * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can\n * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.\n */\nexport class MutableDisposable {\n    constructor() {\n        this._isDisposed = false;\n        trackDisposable(this);\n    }\n    get value() {\n        return this._isDisposed ? undefined : this._value;\n    }\n    set value(value) {\n        var _a;\n        if (this._isDisposed || value === this._value) {\n            return;\n        }\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        if (value) {\n            setParentOfDisposable(value, this);\n        }\n        this._value = value;\n    }\n    clear() {\n        this.value = undefined;\n    }\n    dispose() {\n        var _a;\n        this._isDisposed = true;\n        markAsDisposed(this);\n        (_a = this._value) === null || _a === void 0 ? void 0 : _a.dispose();\n        this._value = undefined;\n    }\n    /**\n     * Clears the value, but does not dispose it.\n     * The old value is returned.\n    */\n    clearAndLeak() {\n        const oldValue = this._value;\n        this._value = undefined;\n        if (oldValue) {\n            setParentOfDisposable(oldValue, null);\n        }\n        return oldValue;\n    }\n}\n/**\n * A safe disposable can be `unset` so that a leaked reference (listener)\n * can be cut-off.\n */\nexport class SafeDisposable {\n    constructor() {\n        this.dispose = () => { };\n        this.unset = () => { };\n        this.isset = () => false;\n        trackDisposable(this);\n    }\n    set(fn) {\n        let callback = fn;\n        this.unset = () => callback = undefined;\n        this.isset = () => callback !== undefined;\n        this.dispose = () => {\n            if (callback) {\n                callback();\n                callback = undefined;\n                markAsDisposed(this);\n            }\n        };\n        return this;\n    }\n}\nexport class ImmortalReference {\n    constructor(object) {\n        this.object = object;\n    }\n    dispose() { }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass Node {\n    constructor(element) {\n        this.element = element;\n        this.next = Node.Undefined;\n        this.prev = Node.Undefined;\n    }\n}\nNode.Undefined = new Node(undefined);\nexport class LinkedList {\n    constructor() {\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    get size() {\n        return this._size;\n    }\n    isEmpty() {\n        return this._first === Node.Undefined;\n    }\n    clear() {\n        let node = this._first;\n        while (node !== Node.Undefined) {\n            const next = node.next;\n            node.prev = Node.Undefined;\n            node.next = Node.Undefined;\n            node = next;\n        }\n        this._first = Node.Undefined;\n        this._last = Node.Undefined;\n        this._size = 0;\n    }\n    unshift(element) {\n        return this._insert(element, false);\n    }\n    push(element) {\n        return this._insert(element, true);\n    }\n    _insert(element, atTheEnd) {\n        const newNode = new Node(element);\n        if (this._first === Node.Undefined) {\n            this._first = newNode;\n            this._last = newNode;\n        }\n        else if (atTheEnd) {\n            // push\n            const oldLast = this._last;\n            this._last = newNode;\n            newNode.prev = oldLast;\n            oldLast.next = newNode;\n        }\n        else {\n            // unshift\n            const oldFirst = this._first;\n            this._first = newNode;\n            newNode.next = oldFirst;\n            oldFirst.prev = newNode;\n        }\n        this._size += 1;\n        let didRemove = false;\n        return () => {\n            if (!didRemove) {\n                didRemove = true;\n                this._remove(newNode);\n            }\n        };\n    }\n    shift() {\n        if (this._first === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._first.element;\n            this._remove(this._first);\n            return res;\n        }\n    }\n    pop() {\n        if (this._last === Node.Undefined) {\n            return undefined;\n        }\n        else {\n            const res = this._last.element;\n            this._remove(this._last);\n            return res;\n        }\n    }\n    _remove(node) {\n        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {\n            // middle\n            const anchor = node.prev;\n            anchor.next = node.next;\n            node.next.prev = anchor;\n        }\n        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {\n            // only node\n            this._first = Node.Undefined;\n            this._last = Node.Undefined;\n        }\n        else if (node.next === Node.Undefined) {\n            // last\n            this._last = this._last.prev;\n            this._last.next = Node.Undefined;\n        }\n        else if (node.prev === Node.Undefined) {\n            // first\n            this._first = this._first.next;\n            this._first.prev = Node.Undefined;\n        }\n        // done\n        this._size -= 1;\n    }\n    *[Symbol.iterator]() {\n        let node = this._first;\n        while (node !== Node.Undefined) {\n            yield node.element;\n            node = node.next;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar _a;\nconst LANGUAGE_DEFAULT = 'en';\nlet _isWindows = false;\nlet _isMacintosh = false;\nlet _isLinux = false;\nlet _isLinuxSnap = false;\nlet _isNative = false;\nlet _isWeb = false;\nlet _isElectron = false;\nlet _isIOS = false;\nlet _isCI = false;\nlet _locale = undefined;\nlet _language = LANGUAGE_DEFAULT;\nlet _translationsConfigFile = undefined;\nlet _userAgent = undefined;\nexport const globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {});\nlet nodeProcess = undefined;\nif (typeof globals.vscode !== 'undefined' && typeof globals.vscode.process !== 'undefined') {\n    // Native environment (sandboxed)\n    nodeProcess = globals.vscode.process;\n}\nelse if (typeof process !== 'undefined') {\n    // Native environment (non-sandboxed)\n    nodeProcess = process;\n}\nconst isElectronProcess = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === 'string';\nconst isElectronRenderer = isElectronProcess && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === 'renderer';\n// Web environment\nif (typeof navigator === 'object' && !isElectronRenderer) {\n    _userAgent = navigator.userAgent;\n    _isWindows = _userAgent.indexOf('Windows') >= 0;\n    _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;\n    _isIOS = (_userAgent.indexOf('Macintosh') >= 0 || _userAgent.indexOf('iPad') >= 0 || _userAgent.indexOf('iPhone') >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;\n    _isLinux = _userAgent.indexOf('Linux') >= 0;\n    _isWeb = true;\n    _locale = navigator.language;\n    _language = _locale;\n}\n// Native environment\nelse if (typeof nodeProcess === 'object') {\n    _isWindows = (nodeProcess.platform === 'win32');\n    _isMacintosh = (nodeProcess.platform === 'darwin');\n    _isLinux = (nodeProcess.platform === 'linux');\n    _isLinuxSnap = _isLinux && !!nodeProcess.env['SNAP'] && !!nodeProcess.env['SNAP_REVISION'];\n    _isElectron = isElectronProcess;\n    _isCI = !!nodeProcess.env['CI'] || !!nodeProcess.env['BUILD_ARTIFACTSTAGINGDIRECTORY'];\n    _locale = LANGUAGE_DEFAULT;\n    _language = LANGUAGE_DEFAULT;\n    const rawNlsConfig = nodeProcess.env['VSCODE_NLS_CONFIG'];\n    if (rawNlsConfig) {\n        try {\n            const nlsConfig = JSON.parse(rawNlsConfig);\n            const resolved = nlsConfig.availableLanguages['*'];\n            _locale = nlsConfig.locale;\n            // VSCode's default language is 'en'\n            _language = resolved ? resolved : LANGUAGE_DEFAULT;\n            _translationsConfigFile = nlsConfig._translationsConfigFile;\n        }\n        catch (e) {\n        }\n    }\n    _isNative = true;\n}\n// Unknown environment\nelse {\n    console.error('Unable to resolve platform.');\n}\nlet _platform = 0 /* Web */;\nif (_isMacintosh) {\n    _platform = 1 /* Mac */;\n}\nelse if (_isWindows) {\n    _platform = 3 /* Windows */;\n}\nelse if (_isLinux) {\n    _platform = 2 /* Linux */;\n}\nexport const isWindows = _isWindows;\nexport const isMacintosh = _isMacintosh;\nexport const isLinux = _isLinux;\nexport const isNative = _isNative;\nexport const isWeb = _isWeb;\nexport const isWebWorker = (_isWeb && typeof globals.importScripts === 'function');\nexport const isIOS = _isIOS;\nexport const userAgent = _userAgent;\n/**\n * The language used for the user interface. The format of\n * the string is all lower case (e.g. zh-tw for Traditional\n * Chinese)\n */\nexport const language = _language;\n/**\n * See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.\n *\n * Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay\n * that browsers set when the nesting level is > 5.\n */\nexport const setTimeout0 = (() => {\n    if (typeof globals.postMessage === 'function' && !globals.importScripts) {\n        let pending = [];\n        globals.addEventListener('message', (e) => {\n            if (e.data && e.data.vscodeScheduleAsyncWork) {\n                for (let i = 0, len = pending.length; i < len; i++) {\n                    const candidate = pending[i];\n                    if (candidate.id === e.data.vscodeScheduleAsyncWork) {\n                        pending.splice(i, 1);\n                        candidate.callback();\n                        return;\n                    }\n                }\n            }\n        });\n        let lastId = 0;\n        return (callback) => {\n            const myId = ++lastId;\n            pending.push({\n                id: myId,\n                callback: callback\n            });\n            globals.postMessage({ vscodeScheduleAsyncWork: myId }, '*');\n        };\n    }\n    return (callback) => setTimeout(callback);\n})();\nexport const OS = (_isMacintosh || _isIOS ? 2 /* Macintosh */ : (_isWindows ? 1 /* Windows */ : 3 /* Linux */));\nlet _isLittleEndian = true;\nlet _isLittleEndianComputed = false;\nexport function isLittleEndian() {\n    if (!_isLittleEndianComputed) {\n        _isLittleEndianComputed = true;\n        const test = new Uint8Array(2);\n        test[0] = 1;\n        test[1] = 2;\n        const view = new Uint16Array(test.buffer);\n        _isLittleEndian = (view[0] === (2 << 8) + 1);\n    }\n    return _isLittleEndian;\n}\nexport const isChrome = !!(userAgent && userAgent.indexOf('Chrome') >= 0);\nexport const isFirefox = !!(userAgent && userAgent.indexOf('Firefox') >= 0);\nexport const isSafari = !!(!isChrome && (userAgent && userAgent.indexOf('Safari') >= 0));\nexport const isEdge = !!(userAgent && userAgent.indexOf('Edg/') >= 0);\nexport const isAndroid = !!(userAgent && userAgent.indexOf('Android') >= 0);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { globals } from './platform.js';\nconst hasPerformanceNow = (globals.performance && typeof globals.performance.now === 'function');\nexport class StopWatch {\n    constructor(highResolution) {\n        this._highResolution = hasPerformanceNow && highResolution;\n        this._startTime = this._now();\n        this._stopTime = -1;\n    }\n    static create(highResolution = true) {\n        return new StopWatch(highResolution);\n    }\n    stop() {\n        this._stopTime = this._now();\n    }\n    elapsed() {\n        if (this._stopTime !== -1) {\n            return this._stopTime - this._startTime;\n        }\n        return this._now() - this._startTime;\n    }\n    _now() {\n        return this._highResolution ? globals.performance.now() : Date.now();\n    }\n}\n","import { onUnexpectedError } from './errors.js';\nimport { combinedDisposable, Disposable, DisposableStore, SafeDisposable, toDisposable } from './lifecycle.js';\nimport { LinkedList } from './linkedList.js';\nimport { StopWatch } from './stopwatch.js';\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever an emitter with listeners is disposed. That is a sign of code smell.\n// -----------------------------------------------------------------------------------------------------------------------\nlet _enableDisposeWithListenerWarning = false;\n// _enableDisposeWithListenerWarning = Boolean(\"TRUE\"); // causes a linter warning so that it cannot be pushed\n// -----------------------------------------------------------------------------------------------------------------------\n// Uncomment the next line to print warnings whenever a snapshotted event is used repeatedly without cleanup.\n// See https://github.com/microsoft/vscode/issues/142851\n// -----------------------------------------------------------------------------------------------------------------------\nlet _enableSnapshotPotentialLeakWarning = false;\nexport var Event;\n(function (Event) {\n    Event.None = () => Disposable.None;\n    function _addLeakageTraceLogic(options) {\n        if (_enableSnapshotPotentialLeakWarning) {\n            const { onListenerDidAdd: origListenerDidAdd } = options;\n            const stack = Stacktrace.create();\n            let count = 0;\n            options.onListenerDidAdd = () => {\n                if (++count === 2) {\n                    console.warn('snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here');\n                    stack.print();\n                }\n                origListenerDidAdd === null || origListenerDidAdd === void 0 ? void 0 : origListenerDidAdd();\n            };\n        }\n    }\n    /**\n     * Given an event, returns another event which only fires once.\n     */\n    function once(event) {\n        return (listener, thisArgs = null, disposables) => {\n            // we need this, in case the event fires during the listener call\n            let didFire = false;\n            let result;\n            result = event(e => {\n                if (didFire) {\n                    return;\n                }\n                else if (result) {\n                    result.dispose();\n                }\n                else {\n                    didFire = true;\n                }\n                return listener.call(thisArgs, e);\n            }, null, disposables);\n            if (didFire) {\n                result.dispose();\n            }\n            return result;\n        };\n    }\n    Event.once = once;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function map(event, map, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => listener.call(thisArgs, map(i)), null, disposables), disposable);\n    }\n    Event.map = map;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function forEach(event, each, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(i => { each(i); listener.call(thisArgs, i); }, null, disposables), disposable);\n    }\n    Event.forEach = forEach;\n    function filter(event, filter, disposable) {\n        return snapshot((listener, thisArgs = null, disposables) => event(e => filter(e) && listener.call(thisArgs, e), null, disposables), disposable);\n    }\n    Event.filter = filter;\n    /**\n     * Given an event, returns the same event but typed as `Event<void>`.\n     */\n    function signal(event) {\n        return event;\n    }\n    Event.signal = signal;\n    function any(...events) {\n        return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map(event => event(e => listener.call(thisArgs, e), null, disposables)));\n    }\n    Event.any = any;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function reduce(event, merge, initial, disposable) {\n        let output = initial;\n        return map(event, e => {\n            output = merge(output, e);\n            return output;\n        }, disposable);\n    }\n    Event.reduce = reduce;\n    function snapshot(event, disposable) {\n        let listener;\n        const options = {\n            onFirstListenerAdd() {\n                listener = event(emitter.fire, emitter);\n            },\n            onLastListenerRemove() {\n                listener.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        if (disposable) {\n            disposable.add(emitter);\n        }\n        return emitter.event;\n    }\n    function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold, disposable) {\n        let subscription;\n        let output = undefined;\n        let handle = undefined;\n        let numDebouncedCalls = 0;\n        const options = {\n            leakWarningThreshold,\n            onFirstListenerAdd() {\n                subscription = event(cur => {\n                    numDebouncedCalls++;\n                    output = merge(output, cur);\n                    if (leading && !handle) {\n                        emitter.fire(output);\n                        output = undefined;\n                    }\n                    clearTimeout(handle);\n                    handle = setTimeout(() => {\n                        const _output = output;\n                        output = undefined;\n                        handle = undefined;\n                        if (!leading || numDebouncedCalls > 1) {\n                            emitter.fire(_output);\n                        }\n                        numDebouncedCalls = 0;\n                    }, delay);\n                });\n            },\n            onLastListenerRemove() {\n                subscription.dispose();\n            }\n        };\n        if (!disposable) {\n            _addLeakageTraceLogic(options);\n        }\n        const emitter = new Emitter(options);\n        if (disposable) {\n            disposable.add(emitter);\n        }\n        return emitter.event;\n    }\n    Event.debounce = debounce;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function latch(event, equals = (a, b) => a === b, disposable) {\n        let firstCall = true;\n        let cache;\n        return filter(event, value => {\n            const shouldEmit = firstCall || !equals(value, cache);\n            firstCall = false;\n            cache = value;\n            return shouldEmit;\n        }, disposable);\n    }\n    Event.latch = latch;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function split(event, isT, disposable) {\n        return [\n            Event.filter(event, isT, disposable),\n            Event.filter(event, e => !isT(e), disposable),\n        ];\n    }\n    Event.split = split;\n    /**\n     * *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned\n     * event is accessible to \"third parties\", e.g the event is a public property. Otherwise a leaked listener on the\n     * returned event causes this utility to leak a listener on the original event.\n     */\n    function buffer(event, flushAfterTimeout = false, _buffer = []) {\n        let buffer = _buffer.slice();\n        let listener = event(e => {\n            if (buffer) {\n                buffer.push(e);\n            }\n            else {\n                emitter.fire(e);\n            }\n        });\n        const flush = () => {\n            if (buffer) {\n                buffer.forEach(e => emitter.fire(e));\n            }\n            buffer = null;\n        };\n        const emitter = new Emitter({\n            onFirstListenerAdd() {\n                if (!listener) {\n                    listener = event(e => emitter.fire(e));\n                }\n            },\n            onFirstListenerDidAdd() {\n                if (buffer) {\n                    if (flushAfterTimeout) {\n                        setTimeout(flush);\n                    }\n                    else {\n                        flush();\n                    }\n                }\n            },\n            onLastListenerRemove() {\n                if (listener) {\n                    listener.dispose();\n                }\n                listener = null;\n            }\n        });\n        return emitter.event;\n    }\n    Event.buffer = buffer;\n    class ChainableEvent {\n        constructor(event) {\n            this.event = event;\n        }\n        map(fn) {\n            return new ChainableEvent(map(this.event, fn));\n        }\n        forEach(fn) {\n            return new ChainableEvent(forEach(this.event, fn));\n        }\n        filter(fn) {\n            return new ChainableEvent(filter(this.event, fn));\n        }\n        reduce(merge, initial) {\n            return new ChainableEvent(reduce(this.event, merge, initial));\n        }\n        latch() {\n            return new ChainableEvent(latch(this.event));\n        }\n        debounce(merge, delay = 100, leading = false, leakWarningThreshold) {\n            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));\n        }\n        on(listener, thisArgs, disposables) {\n            return this.event(listener, thisArgs, disposables);\n        }\n        once(listener, thisArgs, disposables) {\n            return once(this.event)(listener, thisArgs, disposables);\n        }\n    }\n    /**\n     * @deprecated DO NOT use, this leaks memory\n     */\n    function chain(event) {\n        return new ChainableEvent(event);\n    }\n    Event.chain = chain;\n    function fromNodeEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.on(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromNodeEventEmitter = fromNodeEventEmitter;\n    function fromDOMEventEmitter(emitter, eventName, map = id => id) {\n        const fn = (...args) => result.fire(map(...args));\n        const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);\n        const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);\n        const result = new Emitter({ onFirstListenerAdd, onLastListenerRemove });\n        return result.event;\n    }\n    Event.fromDOMEventEmitter = fromDOMEventEmitter;\n    function toPromise(event) {\n        return new Promise(resolve => once(event)(resolve));\n    }\n    Event.toPromise = toPromise;\n    function runAndSubscribe(event, handler) {\n        handler(undefined);\n        return event(e => handler(e));\n    }\n    Event.runAndSubscribe = runAndSubscribe;\n    function runAndSubscribeWithStore(event, handler) {\n        let store = null;\n        function run(e) {\n            store === null || store === void 0 ? void 0 : store.dispose();\n            store = new DisposableStore();\n            handler(e, store);\n        }\n        run(undefined);\n        const disposable = event(e => run(e));\n        return toDisposable(() => {\n            disposable.dispose();\n            store === null || store === void 0 ? void 0 : store.dispose();\n        });\n    }\n    Event.runAndSubscribeWithStore = runAndSubscribeWithStore;\n})(Event || (Event = {}));\nclass EventProfiling {\n    constructor(name) {\n        this._listenerCount = 0;\n        this._invocationCount = 0;\n        this._elapsedOverall = 0;\n        this._name = `${name}_${EventProfiling._idPool++}`;\n    }\n    start(listenerCount) {\n        this._stopWatch = new StopWatch(true);\n        this._listenerCount = listenerCount;\n    }\n    stop() {\n        if (this._stopWatch) {\n            const elapsed = this._stopWatch.elapsed();\n            this._elapsedOverall += elapsed;\n            this._invocationCount += 1;\n            console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);\n            this._stopWatch = undefined;\n        }\n    }\n}\nEventProfiling._idPool = 0;\nlet _globalLeakWarningThreshold = -1;\nclass LeakageMonitor {\n    constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {\n        this.customThreshold = customThreshold;\n        this.name = name;\n        this._warnCountdown = 0;\n    }\n    dispose() {\n        if (this._stacks) {\n            this._stacks.clear();\n        }\n    }\n    check(stack, listenerCount) {\n        let threshold = _globalLeakWarningThreshold;\n        if (typeof this.customThreshold === 'number') {\n            threshold = this.customThreshold;\n        }\n        if (threshold <= 0 || listenerCount < threshold) {\n            return undefined;\n        }\n        if (!this._stacks) {\n            this._stacks = new Map();\n        }\n        const count = (this._stacks.get(stack.value) || 0);\n        this._stacks.set(stack.value, count + 1);\n        this._warnCountdown -= 1;\n        if (this._warnCountdown <= 0) {\n            // only warn on first exceed and then every time the limit\n            // is exceeded by 50% again\n            this._warnCountdown = threshold * 0.5;\n            // find most frequent listener and print warning\n            let topStack;\n            let topCount = 0;\n            for (const [stack, count] of this._stacks) {\n                if (!topStack || topCount < count) {\n                    topStack = stack;\n                    topCount = count;\n                }\n            }\n            console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);\n            console.warn(topStack);\n        }\n        return () => {\n            const count = (this._stacks.get(stack.value) || 0);\n            this._stacks.set(stack.value, count - 1);\n        };\n    }\n}\nclass Stacktrace {\n    constructor(value) {\n        this.value = value;\n    }\n    static create() {\n        var _a;\n        return new Stacktrace((_a = new Error().stack) !== null && _a !== void 0 ? _a : '');\n    }\n    print() {\n        console.warn(this.value.split('\\n').slice(2).join('\\n'));\n    }\n}\nclass Listener {\n    constructor(callback, callbackThis, stack) {\n        this.callback = callback;\n        this.callbackThis = callbackThis;\n        this.stack = stack;\n        this.subscription = new SafeDisposable();\n    }\n    invoke(e) {\n        this.callback.call(this.callbackThis, e);\n    }\n}\n/**\n * The Emitter can be used to expose an Event to the public\n * to fire it from the insides.\n * Sample:\n    class Document {\n\n        private readonly _onDidChange = new Emitter<(value:string)=>any>();\n\n        public onDidChange = this._onDidChange.event;\n\n        // getter-style\n        // get onDidChange(): Event<(value:string)=>any> {\n        // \treturn this._onDidChange.event;\n        // }\n\n        private _doIt() {\n            //...\n            this._onDidChange.fire(value);\n        }\n    }\n */\nexport class Emitter {\n    constructor(options) {\n        var _a;\n        this._disposed = false;\n        this._options = options;\n        this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : undefined;\n        this._perfMon = ((_a = this._options) === null || _a === void 0 ? void 0 : _a._profName) ? new EventProfiling(this._options._profName) : undefined;\n    }\n    dispose() {\n        var _a, _b, _c, _d;\n        if (!this._disposed) {\n            this._disposed = true;\n            // It is bad to have listeners at the time of disposing an emitter, it is worst to have listeners keep the emitter\n            // alive via the reference that's embedded in their disposables. Therefore we loop over all remaining listeners and\n            // unset their subscriptions/disposables. Looping and blaming remaining listeners is done on next tick because the\n            // the following programming pattern is very popular:\n            //\n            // const someModel = this._disposables.add(new ModelObject()); // (1) create and register model\n            // this._disposables.add(someModel.onDidChange(() => { ... }); // (2) subscribe and register model-event listener\n            // ...later...\n            // this._disposables.dispose(); disposes (1) then (2): don't warn after (1) but after the \"overall dispose\" is done\n            if (this._listeners) {\n                if (_enableDisposeWithListenerWarning) {\n                    const listeners = Array.from(this._listeners);\n                    queueMicrotask(() => {\n                        var _a;\n                        for (const listener of listeners) {\n                            if (listener.subscription.isset()) {\n                                listener.subscription.unset();\n                                (_a = listener.stack) === null || _a === void 0 ? void 0 : _a.print();\n                            }\n                        }\n                    });\n                }\n                this._listeners.clear();\n            }\n            (_a = this._deliveryQueue) === null || _a === void 0 ? void 0 : _a.clear();\n            (_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onLastListenerRemove) === null || _c === void 0 ? void 0 : _c.call(_b);\n            (_d = this._leakageMon) === null || _d === void 0 ? void 0 : _d.dispose();\n        }\n    }\n    /**\n     * For the public to allow to subscribe\n     * to events from this Emitter\n     */\n    get event() {\n        if (!this._event) {\n            this._event = (callback, thisArgs, disposables) => {\n                var _a, _b, _c;\n                if (!this._listeners) {\n                    this._listeners = new LinkedList();\n                }\n                const firstListener = this._listeners.isEmpty();\n                if (firstListener && ((_a = this._options) === null || _a === void 0 ? void 0 : _a.onFirstListenerAdd)) {\n                    this._options.onFirstListenerAdd(this);\n                }\n                let removeMonitor;\n                let stack;\n                if (this._leakageMon && this._listeners.size >= 30) {\n                    // check and record this emitter for potential leakage\n                    stack = Stacktrace.create();\n                    removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);\n                }\n                if (_enableDisposeWithListenerWarning) {\n                    stack = stack !== null && stack !== void 0 ? stack : Stacktrace.create();\n                }\n                const listener = new Listener(callback, thisArgs, stack);\n                const removeListener = this._listeners.push(listener);\n                if (firstListener && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onFirstListenerDidAdd)) {\n                    this._options.onFirstListenerDidAdd(this);\n                }\n                if ((_c = this._options) === null || _c === void 0 ? void 0 : _c.onListenerDidAdd) {\n                    this._options.onListenerDidAdd(this, callback, thisArgs);\n                }\n                const result = listener.subscription.set(() => {\n                    if (removeMonitor) {\n                        removeMonitor();\n                    }\n                    if (!this._disposed) {\n                        removeListener();\n                        if (this._options && this._options.onLastListenerRemove) {\n                            const hasListeners = (this._listeners && !this._listeners.isEmpty());\n                            if (!hasListeners) {\n                                this._options.onLastListenerRemove(this);\n                            }\n                        }\n                    }\n                });\n                if (disposables instanceof DisposableStore) {\n                    disposables.add(result);\n                }\n                else if (Array.isArray(disposables)) {\n                    disposables.push(result);\n                }\n                return result;\n            };\n        }\n        return this._event;\n    }\n    /**\n     * To be kept private to fire an event to\n     * subscribers\n     */\n    fire(event) {\n        var _a, _b;\n        if (this._listeners) {\n            // put all [listener,event]-pairs into delivery queue\n            // then emit all event. an inner/nested event might be\n            // the driver of this\n            if (!this._deliveryQueue) {\n                this._deliveryQueue = new LinkedList();\n            }\n            for (let listener of this._listeners) {\n                this._deliveryQueue.push([listener, event]);\n            }\n            // start/stop performance insight collection\n            (_a = this._perfMon) === null || _a === void 0 ? void 0 : _a.start(this._deliveryQueue.size);\n            while (this._deliveryQueue.size > 0) {\n                const [listener, event] = this._deliveryQueue.shift();\n                try {\n                    listener.invoke(event);\n                }\n                catch (e) {\n                    onUnexpectedError(e);\n                }\n            }\n            (_b = this._perfMon) === null || _b === void 0 ? void 0 : _b.stop();\n        }\n    }\n}\nexport class PauseableEmitter extends Emitter {\n    constructor(options) {\n        super(options);\n        this._isPaused = 0;\n        this._eventQueue = new LinkedList();\n        this._mergeFn = options === null || options === void 0 ? void 0 : options.merge;\n    }\n    pause() {\n        this._isPaused++;\n    }\n    resume() {\n        if (this._isPaused !== 0 && --this._isPaused === 0) {\n            if (this._mergeFn) {\n                // use the merge function to create a single composite\n                // event. make a copy in case firing pauses this emitter\n                const events = Array.from(this._eventQueue);\n                this._eventQueue.clear();\n                super.fire(this._mergeFn(events));\n            }\n            else {\n                // no merging, fire each event individually and test\n                // that this emitter isn't paused halfway through\n                while (!this._isPaused && this._eventQueue.size !== 0) {\n                    super.fire(this._eventQueue.shift());\n                }\n            }\n        }\n    }\n    fire(event) {\n        if (this._listeners) {\n            if (this._isPaused !== 0) {\n                this._eventQueue.push(event);\n            }\n            else {\n                super.fire(event);\n            }\n        }\n    }\n}\nexport class DebounceEmitter extends PauseableEmitter {\n    constructor(options) {\n        var _a;\n        super(options);\n        this._delay = (_a = options.delay) !== null && _a !== void 0 ? _a : 100;\n    }\n    fire(event) {\n        if (!this._handle) {\n            this.pause();\n            this._handle = setTimeout(() => {\n                this._handle = undefined;\n                this.resume();\n            }, this._delay);\n        }\n        super.fire(event);\n    }\n}\n/**\n * The EventBufferer is useful in situations in which you want\n * to delay firing your events during some code.\n * You can wrap that code and be sure that the event will not\n * be fired during that wrap.\n *\n * ```\n * const emitter: Emitter;\n * const delayer = new EventDelayer();\n * const delayedEvent = delayer.wrapEvent(emitter.event);\n *\n * delayedEvent(console.log);\n *\n * delayer.bufferEvents(() => {\n *   emitter.fire(); // event will not be fired yet\n * });\n *\n * // event will only be fired at this point\n * ```\n */\nexport class EventBufferer {\n    constructor() {\n        this.buffers = [];\n    }\n    wrapEvent(event) {\n        return (listener, thisArgs, disposables) => {\n            return event(i => {\n                const buffer = this.buffers[this.buffers.length - 1];\n                if (buffer) {\n                    buffer.push(() => listener.call(thisArgs, i));\n                }\n                else {\n                    listener.call(thisArgs, i);\n                }\n            }, undefined, disposables);\n        };\n    }\n    bufferEvents(fn) {\n        const buffer = [];\n        this.buffers.push(buffer);\n        const r = fn();\n        this.buffers.pop();\n        buffer.forEach(flush => flush());\n        return r;\n    }\n}\n/**\n * A Relay is an event forwarder which functions as a replugabble event pipe.\n * Once created, you can connect an input event to it and it will simply forward\n * events from that input event through its own `event` property. The `input`\n * can be changed at any point in time.\n */\nexport class Relay {\n    constructor() {\n        this.listening = false;\n        this.inputEvent = Event.None;\n        this.inputEventListener = Disposable.None;\n        this.emitter = new Emitter({\n            onFirstListenerDidAdd: () => {\n                this.listening = true;\n                this.inputEventListener = this.inputEvent(this.emitter.fire, this.emitter);\n            },\n            onLastListenerRemove: () => {\n                this.listening = false;\n                this.inputEventListener.dispose();\n            }\n        });\n        this.event = this.emitter.event;\n    }\n    set input(event) {\n        this.inputEvent = event;\n        if (this.listening) {\n            this.inputEventListener.dispose();\n            this.inputEventListener = event(this.emitter.fire, this.emitter);\n        }\n    }\n    dispose() {\n        this.inputEventListener.dispose();\n        this.emitter.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\\\|;:\\'\",.<>/?';\n/**\n * Create a word definition regular expression based on default word separators.\n * Optionally provide allowed separators that should be included in words.\n *\n * The default would look like this:\n * /(-?\\d*\\.\\d\\w*)|([^\\`\\~\\!\\@\\#\\$\\%\\^\\&\\*\\(\\)\\-\\=\\+\\[\\{\\]\\}\\\\\\|\\;\\:\\'\\\"\\,\\.\\<\\>\\/\\?\\s]+)/g\n */\nfunction createWordRegExp(allowInWords = '') {\n    let source = '(-?\\\\d*\\\\.\\\\d\\\\w*)|([^';\n    for (const sep of USUAL_WORD_SEPARATORS) {\n        if (allowInWords.indexOf(sep) >= 0) {\n            continue;\n        }\n        source += '\\\\' + sep;\n    }\n    source += '\\\\s]+)';\n    return new RegExp(source, 'g');\n}\n// catches numbers (including floating numbers) in the first group, and alphanum in the second\nexport const DEFAULT_WORD_REGEXP = createWordRegExp();\nexport function ensureValidWordDefinition(wordDefinition) {\n    let result = DEFAULT_WORD_REGEXP;\n    if (wordDefinition && (wordDefinition instanceof RegExp)) {\n        if (!wordDefinition.global) {\n            let flags = 'g';\n            if (wordDefinition.ignoreCase) {\n                flags += 'i';\n            }\n            if (wordDefinition.multiline) {\n                flags += 'm';\n            }\n            if (wordDefinition.unicode) {\n                flags += 'u';\n            }\n            result = new RegExp(wordDefinition.source, flags);\n        }\n        else {\n            result = wordDefinition;\n        }\n    }\n    result.lastIndex = 0;\n    return result;\n}\nconst _defaultConfig = {\n    maxLen: 1000,\n    windowSize: 15,\n    timeBudget: 150\n};\nexport function getWordAtText(column, wordDefinition, text, textOffset, config = _defaultConfig) {\n    if (text.length > config.maxLen) {\n        // don't throw strings that long at the regexp\n        // but use a sub-string in which a word must occur\n        let start = column - config.maxLen / 2;\n        if (start < 0) {\n            start = 0;\n        }\n        else {\n            textOffset += start;\n        }\n        text = text.substring(start, column + config.maxLen / 2);\n        return getWordAtText(column, wordDefinition, text, textOffset, config);\n    }\n    const t1 = Date.now();\n    const pos = column - 1 - textOffset;\n    let prevRegexIndex = -1;\n    let match = null;\n    for (let i = 1;; i++) {\n        // check time budget\n        if (Date.now() - t1 >= config.timeBudget) {\n            break;\n        }\n        // reset the index at which the regexp should start matching, also know where it\n        // should stop so that subsequent search don't repeat previous searches\n        const regexIndex = pos - config.windowSize * i;\n        wordDefinition.lastIndex = Math.max(0, regexIndex);\n        const thisMatch = _findRegexMatchEnclosingPosition(wordDefinition, text, pos, prevRegexIndex);\n        if (!thisMatch && match) {\n            // stop: we have something\n            break;\n        }\n        match = thisMatch;\n        // stop: searched at start\n        if (regexIndex <= 0) {\n            break;\n        }\n        prevRegexIndex = regexIndex;\n    }\n    if (match) {\n        const result = {\n            word: match[0],\n            startColumn: textOffset + 1 + match.index,\n            endColumn: textOffset + 1 + match.index + match[0].length\n        };\n        wordDefinition.lastIndex = 0;\n        return result;\n    }\n    return null;\n}\nfunction _findRegexMatchEnclosingPosition(wordDefinition, text, pos, stopPos) {\n    let match;\n    while (match = wordDefinition.exec(text)) {\n        const matchIndex = match.index || 0;\n        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {\n            return match;\n        }\n        else if (stopPos > 0 && matchIndex > stopPos) {\n            return null;\n        }\n    }\n    return null;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* Other */:\n                return true;\n            case 1 /* Comment */:\n                return this._inComment;\n            case 2 /* String */:\n                return this._inString;\n            case 3 /* RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* Digit0 */, 57 /* Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* a */, 122 /* z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* A */, 90 /* Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.colorizedBracketPairs) {\n            this._colorizedBracketPairs = filterValidBrackets(config.colorizedBracketPairs.map(b => [b[0], b[1]]));\n        }\n        else if (config.brackets) {\n            this._colorizedBracketPairs = filterValidBrackets(config.brackets\n                .map((b) => [b[0], b[1]])\n                // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n                // This leads to problems when colorizing this bracket, so we exclude it by default.\n                // Languages can still override this by configuring `colorizedBracketPairs`\n                // https://github.com/microsoft/vscode/issues/132476\n                .filter((p) => !(p[0] === '<' && p[1] === '>')));\n        }\n        else {\n            this._colorizedBracketPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBefore = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet() {\n        return this._autoCloseBefore;\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n    getColorizedBrackets() {\n        return this._colorizedBracketPairs;\n    }\n}\nCharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = ';:.,=}])> \\n\\t';\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\n","/**\n * Returns the last element of an array.\n * @param array The array.\n * @param n Which element from the end (default is zero).\n */\nexport function tail(array, n = 0) {\n    return array[array.length - (1 + n)];\n}\nexport function tail2(arr) {\n    if (arr.length === 0) {\n        throw new Error('Invalid tail call');\n    }\n    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];\n}\nexport function equals(one, other, itemEquals = (a, b) => a === b) {\n    if (one === other) {\n        return true;\n    }\n    if (!one || !other) {\n        return false;\n    }\n    if (one.length !== other.length) {\n        return false;\n    }\n    for (let i = 0, len = one.length; i < len; i++) {\n        if (!itemEquals(one[i], other[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nexport function binarySearch(array, key, comparator) {\n    let low = 0, high = array.length - 1;\n    while (low <= high) {\n        const mid = ((low + high) / 2) | 0;\n        const comp = comparator(array[mid], key);\n        if (comp < 0) {\n            low = mid + 1;\n        }\n        else if (comp > 0) {\n            high = mid - 1;\n        }\n        else {\n            return mid;\n        }\n    }\n    return -(low + 1);\n}\n/**\n * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false\n * are located before all elements where p(x) is true.\n * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.\n */\nexport function findFirstInSorted(array, p) {\n    let low = 0, high = array.length;\n    if (high === 0) {\n        return 0; // no children\n    }\n    while (low < high) {\n        const mid = Math.floor((low + high) / 2);\n        if (p(array[mid])) {\n            high = mid;\n        }\n        else {\n            low = mid + 1;\n        }\n    }\n    return low;\n}\nexport function quickSelect(nth, data, compare) {\n    nth = nth | 0;\n    if (nth >= data.length) {\n        throw new TypeError('invalid index');\n    }\n    let pivotValue = data[Math.floor(data.length * Math.random())];\n    let lower = [];\n    let higher = [];\n    let pivots = [];\n    for (let value of data) {\n        const val = compare(value, pivotValue);\n        if (val < 0) {\n            lower.push(value);\n        }\n        else if (val > 0) {\n            higher.push(value);\n        }\n        else {\n            pivots.push(value);\n        }\n    }\n    if (nth < lower.length) {\n        return quickSelect(nth, lower, compare);\n    }\n    else if (nth < lower.length + pivots.length) {\n        return pivots[0];\n    }\n    else {\n        return quickSelect(nth - (lower.length + pivots.length), higher, compare);\n    }\n}\nexport function groupBy(data, compare) {\n    const result = [];\n    let currentGroup = undefined;\n    for (const element of data.slice(0).sort(compare)) {\n        if (!currentGroup || compare(currentGroup[0], element) !== 0) {\n            currentGroup = [element];\n            result.push(currentGroup);\n        }\n        else {\n            currentGroup.push(element);\n        }\n    }\n    return result;\n}\n/**\n * @returns New array with all falsy values removed. The original array IS NOT modified.\n */\nexport function coalesce(array) {\n    return array.filter(e => !!e);\n}\n/**\n * @returns false if the provided object is an array and not empty.\n */\nexport function isFalsyOrEmpty(obj) {\n    return !Array.isArray(obj) || obj.length === 0;\n}\nexport function isNonEmptyArray(obj) {\n    return Array.isArray(obj) && obj.length > 0;\n}\n/**\n * Removes duplicates from the given array. The optional keyFn allows to specify\n * how elements are checked for equality by returning an alternate value for each.\n */\nexport function distinct(array, keyFn = value => value) {\n    const seen = new Set();\n    return array.filter(element => {\n        const key = keyFn(element);\n        if (seen.has(key)) {\n            return false;\n        }\n        seen.add(key);\n        return true;\n    });\n}\nexport function findLast(arr, predicate) {\n    const idx = lastIndex(arr, predicate);\n    if (idx === -1) {\n        return undefined;\n    }\n    return arr[idx];\n}\nexport function lastIndex(array, fn) {\n    for (let i = array.length - 1; i >= 0; i--) {\n        const element = array[i];\n        if (fn(element)) {\n            return i;\n        }\n    }\n    return -1;\n}\nexport function firstOrDefault(array, notFoundValue) {\n    return array.length > 0 ? array[0] : notFoundValue;\n}\nexport function flatten(arr) {\n    return [].concat(...arr);\n}\nexport function range(arg, to) {\n    let from = typeof to === 'number' ? arg : 0;\n    if (typeof to === 'number') {\n        from = arg;\n    }\n    else {\n        from = 0;\n        to = arg;\n    }\n    const result = [];\n    if (from <= to) {\n        for (let i = from; i < to; i++) {\n            result.push(i);\n        }\n    }\n    else {\n        for (let i = from; i > to; i--) {\n            result.push(i);\n        }\n    }\n    return result;\n}\n/**\n * Insert `insertArr` inside `target` at `insertIndex`.\n * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array\n */\nexport function arrayInsert(target, insertIndex, insertArr) {\n    const before = target.slice(0, insertIndex);\n    const after = target.slice(insertIndex);\n    return before.concat(insertArr, after);\n}\n/**\n * Pushes an element to the start of the array, if found.\n */\nexport function pushToStart(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.unshift(value);\n    }\n}\n/**\n * Pushes an element to the end of the array, if found.\n */\nexport function pushToEnd(arr, value) {\n    const index = arr.indexOf(value);\n    if (index > -1) {\n        arr.splice(index, 1);\n        arr.push(value);\n    }\n}\nexport function asArray(x) {\n    return Array.isArray(x) ? x : [x];\n}\n/**\n * Insert the new items in the array.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start inserting elements.\n * @param newItems The items to be inserted\n */\nexport function insertInto(array, start, newItems) {\n    const startIdx = getActualStartIndex(array, start);\n    const originalLength = array.length;\n    const newItemsLength = newItems.length;\n    array.length = originalLength + newItemsLength;\n    // Move the items after the start index, start from the end so that we don't overwrite any value.\n    for (let i = originalLength - 1; i >= startIdx; i--) {\n        array[i + newItemsLength] = array[i];\n    }\n    for (let i = 0; i < newItemsLength; i++) {\n        array[i + startIdx] = newItems[i];\n    }\n}\n/**\n * Removes elements from an array and inserts new elements in their place, returning the deleted elements. Alternative to the native Array.splice method, it\n * can only support limited number of items due to the maximum call stack size limit.\n * @param array The original array.\n * @param start The zero-based location in the array from which to start removing elements.\n * @param deleteCount The number of elements to remove.\n * @returns An array containing the elements that were deleted.\n */\nexport function splice(array, start, deleteCount, newItems) {\n    const index = getActualStartIndex(array, start);\n    const result = array.splice(index, deleteCount);\n    insertInto(array, index, newItems);\n    return result;\n}\n/**\n * Determine the actual start index (same logic as the native splice() or slice())\n * If greater than the length of the array, start will be set to the length of the array. In this case, no element will be deleted but the method will behave as an adding function, adding as many element as item[n*] provided.\n * If negative, it will begin that many elements from the end of the array. (In this case, the origin -1, meaning -n is the index of the nth last element, and is therefore equivalent to the index of array.length - n.) If array.length + start is less than 0, it will begin from index 0.\n * @param array The target array.\n * @param start The operation index.\n */\nfunction getActualStartIndex(array, start) {\n    return start < 0 ? Math.max(start + array.length, 0) : Math.min(start, array.length);\n}\nexport function compareBy(selector, comparator) {\n    return (a, b) => comparator(selector(a), selector(b));\n}\n/**\n * The natural order on numbers.\n*/\nexport const numberComparator = (a, b) => a - b;\n/**\n * Returns the first item that is equal to or greater than every other item.\n*/\nexport function findMaxBy(items, comparator) {\n    if (items.length === 0) {\n        return undefined;\n    }\n    let max = items[0];\n    for (let i = 1; i < items.length; i++) {\n        const item = items[i];\n        if (comparator(item, max) > 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the last item that is equal to or greater than every other item.\n*/\nexport function findLastMaxBy(items, comparator) {\n    if (items.length === 0) {\n        return undefined;\n    }\n    let max = items[0];\n    for (let i = 1; i < items.length; i++) {\n        const item = items[i];\n        if (comparator(item, max) >= 0) {\n            max = item;\n        }\n    }\n    return max;\n}\n/**\n * Returns the first item that is equal to or less than every other item.\n*/\nexport function findMinBy(items, comparator) {\n    return findMaxBy(items, (a, b) => -comparator(a, b));\n}\nexport class ArrayQueue {\n    /**\n     * Constructs a queue that is backed by the given array. Runtime is O(1).\n    */\n    constructor(items) {\n        this.items = items;\n        this.firstIdx = 0;\n        this.lastIdx = this.items.length - 1;\n    }\n    /**\n     * Consumes elements from the beginning of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned. Has a runtime of O(result.length).\n    */\n    takeWhile(predicate) {\n        // P(k) := k <= this.lastIdx && predicate(this.items[k])\n        // Find s := min { k | k >= this.firstIdx && !P(k) } and return this.data[this.firstIdx...s)\n        let startIdx = this.firstIdx;\n        while (startIdx < this.items.length && predicate(this.items[startIdx])) {\n            startIdx++;\n        }\n        const result = startIdx === this.firstIdx ? null : this.items.slice(this.firstIdx, startIdx);\n        this.firstIdx = startIdx;\n        return result;\n    }\n    /**\n     * Consumes elements from the end of the queue as long as the predicate returns true.\n     * If no elements were consumed, `null` is returned.\n     * The result has the same order as the underlying array!\n    */\n    takeFromEndWhile(predicate) {\n        // P(k) := this.firstIdx >= k && predicate(this.items[k])\n        // Find s := max { k | k <= this.lastIdx && !P(k) } and return this.data(s...this.lastIdx]\n        let endIdx = this.lastIdx;\n        while (endIdx >= 0 && predicate(this.items[endIdx])) {\n            endIdx--;\n        }\n        const result = endIdx === this.lastIdx ? null : this.items.slice(endIdx + 1, this.lastIdx + 1);\n        this.lastIdx = endIdx;\n        return result;\n    }\n    peek() {\n        return this.items[this.firstIdx];\n    }\n    dequeue() {\n        const result = this.items[this.firstIdx];\n        this.firstIdx++;\n        return result;\n    }\n    takeCount(count) {\n        const result = this.items.slice(this.firstIdx, this.firstIdx + count);\n        this.firstIdx += count;\n        return result;\n    }\n}\n","const hasBuffer = (typeof Buffer !== 'undefined');\nlet textDecoder;\nexport class VSBuffer {\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * Math.pow(2, 24)\n        + source[offset + 1] * Math.pow(2, 16)\n        + source[offset + 2] * Math.pow(2, 8)\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport const hasTextDecoder = (typeof TextDecoder !== 'undefined');\nexport let createStringBuilder;\nexport let decodeUTF16LE;\nif (hasTextDecoder) {\n    createStringBuilder = (capacity) => new StringBuilder(capacity);\n    decodeUTF16LE = standardDecodeUTF16LE;\n}\nelse {\n    createStringBuilder = (capacity) => new CompatStringBuilder();\n    decodeUTF16LE = compatDecodeUTF16LE;\n}\nfunction standardDecodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nclass StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    write1(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCII(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendASCIIString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\nclass CompatStringBuilder {\n    constructor() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    reset() {\n        this._pieces = [];\n        this._piecesLen = 0;\n    }\n    build() {\n        return this._pieces.join('');\n    }\n    write1(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCII(charCode) {\n        this._pieces[this._piecesLen++] = String.fromCharCode(charCode);\n    }\n    appendASCIIString(str) {\n        this._pieces[this._piecesLen++] = str;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nfunction createBracketOrRegExp(pieces) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        if (stringBuilder.hasTextDecoder) {\n            // create a Uint16Array and then use a TextDecoder to create a string\n            const arr = new Uint16Array(str.length);\n            let offset = 0;\n            for (let i = str.length - 1; i >= 0; i--) {\n                arr[offset++] = str.charCodeAt(i);\n            }\n            return stringBuilder.getPlatformTextDecoder().decode(arr);\n        }\n        else {\n            const result = [];\n            let resultLen = 0;\n            for (let i = str.length - 1; i >= 0; i--) {\n                result[resultLen++] = str.charAt(i);\n            }\n            return result.join('');\n        }\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// ------ internal util\nexport var _util;\n(function (_util) {\n    _util.serviceIds = new Map();\n    _util.DI_TARGET = '$di$target';\n    _util.DI_DEPENDENCIES = '$di$dependencies';\n    function getServiceDependencies(ctor) {\n        return ctor[_util.DI_DEPENDENCIES] || [];\n    }\n    _util.getServiceDependencies = getServiceDependencies;\n})(_util || (_util = {}));\nexport const IInstantiationService = createDecorator('instantiationService');\nfunction storeServiceDependency(id, target, index) {\n    if (target[_util.DI_TARGET] === target) {\n        target[_util.DI_DEPENDENCIES].push({ id, index });\n    }\n    else {\n        target[_util.DI_DEPENDENCIES] = [{ id, index }];\n        target[_util.DI_TARGET] = target;\n    }\n}\n/**\n * The *only* valid way to create a {{ServiceIdentifier}}.\n */\nexport function createDecorator(serviceId) {\n    if (_util.serviceIds.has(serviceId)) {\n        return _util.serviceIds.get(serviceId);\n    }\n    const id = function (target, key, index) {\n        if (arguments.length !== 3) {\n            throw new Error('@IServiceName-decorator can only be used to decorate a parameter');\n        }\n        storeServiceDependency(id, target, index);\n    };\n    id.toString = () => serviceId;\n    _util.serviceIds.set(serviceId, id);\n    return id;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IConfigurationService = createDecorator('configurationService');\nexport function toValuesTree(properties, conflictReporter) {\n    const root = Object.create(null);\n    for (let key in properties) {\n        addToValueTree(root, key, properties[key], conflictReporter);\n    }\n    return root;\n}\nexport function addToValueTree(settingsTreeRoot, key, value, conflictReporter) {\n    const segments = key.split('.');\n    const last = segments.pop();\n    let curr = settingsTreeRoot;\n    for (let i = 0; i < segments.length; i++) {\n        let s = segments[i];\n        let obj = curr[s];\n        switch (typeof obj) {\n            case 'undefined':\n                obj = curr[s] = Object.create(null);\n                break;\n            case 'object':\n                break;\n            default:\n                conflictReporter(`Ignoring ${key} as ${segments.slice(0, i + 1).join('.')} is ${JSON.stringify(obj)}`);\n                return;\n        }\n        curr = obj;\n    }\n    if (typeof curr === 'object' && curr !== null) {\n        try {\n            curr[last] = value; // workaround https://github.com/microsoft/vscode/issues/13606\n        }\n        catch (e) {\n            conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n        }\n    }\n    else {\n        conflictReporter(`Ignoring ${key} as ${segments.join('.')} is ${JSON.stringify(curr)}`);\n    }\n}\nexport function removeFromValueTree(valueTree, key) {\n    const segments = key.split('.');\n    doRemoveFromValueTree(valueTree, segments);\n}\nfunction doRemoveFromValueTree(valueTree, segments) {\n    const first = segments.shift();\n    if (segments.length === 0) {\n        // Reached last segment\n        delete valueTree[first];\n        return;\n    }\n    if (Object.keys(valueTree).indexOf(first) !== -1) {\n        const value = valueTree[first];\n        if (typeof value === 'object' && !Array.isArray(value)) {\n            doRemoveFromValueTree(value, segments);\n            if (Object.keys(value).length === 0) {\n                delete valueTree[first];\n            }\n        }\n    }\n}\n/**\n * A helper function to get the configuration value with a specific settings path (e.g. config.some.setting)\n */\nexport function getConfigurationValue(config, settingPath, defaultValue) {\n    function accessSetting(config, path) {\n        let current = config;\n        for (const component of path) {\n            if (typeof current !== 'object' || current === null) {\n                return undefined;\n            }\n            current = current[component];\n        }\n        return current;\n    }\n    const path = settingPath.split('.');\n    const result = accessSetting(config, path);\n    return typeof result === 'undefined' ? defaultValue : result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ILanguageService = createDecorator('languageService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SyncDescriptor {\n    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {\n        this.ctor = ctor;\n        this.staticArguments = staticArguments;\n        this.supportsDelayedInstantiation = supportsDelayedInstantiation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SyncDescriptor } from './descriptors.js';\nconst _registry = [];\nexport function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {\n    if (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n        ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], supportsDelayedInstantiation);\n    }\n    _registry.push([id, ctorOrDescriptor]);\n}\nexport function getSingletonServiceDescriptors() {\n    return _registry;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { IndentAction, AutoClosingPairs } from './languageConfiguration.js';\nimport { createScopedLineTokens } from './supports.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(LanguageConfigurationRegistry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, configurationService, languageService) {\n    let languageConfig = LanguageConfigurationRegistry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            throw new Error(`Language id \"${languageId}\" is not configured nor known`);\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistryImpl {\n    constructor() {\n        this._entries = new Map();\n        this._onDidChange = new Emitter();\n        this.onDidChange = this._onDidChange.event;\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;\n    }\n    getComments(languageId) {\n        const value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.comments || null;\n    }\n    // begin Indent Rules\n    getIndentRulesSupport(languageId) {\n        const value = this.getLanguageConfiguration(languageId);\n        if (!value) {\n            return null;\n        }\n        return value.indentRulesSupport || null;\n    }\n    /**\n     * Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.\n     * Result:\n     * -1: run into the boundary of embedded languages\n     * 0: every line above are invalid\n     * else: nearest preceding line of the same language\n     */\n    getPrecedingValidLine(model, lineNumber, indentRulesSupport) {\n        const languageId = model.getLanguageIdAtPosition(lineNumber, 0);\n        if (lineNumber > 1) {\n            let lastLineNumber;\n            let resultLineNumber = -1;\n            for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {\n                if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) {\n                    return resultLineNumber;\n                }\n                const text = model.getLineContent(lastLineNumber);\n                if (indentRulesSupport.shouldIgnore(text) || /^\\s+$/.test(text) || text === '') {\n                    resultLineNumber = lastLineNumber;\n                    continue;\n                }\n                return lastLineNumber;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Get inherited indentation from above lines.\n     * 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.\n     * 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.\n     * 3. If this line doesn't match any indent rules\n     *   a. check whether the line above it matches indentNextLinePattern\n     *   b. If not, the indent level of this line is the result\n     *   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).\n     * 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`\n     *\n     * This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.\n     */\n    getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber <= 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);\n        if (precedingUnIgnoredLine < 0) {\n            return null;\n        }\n        else if (precedingUnIgnoredLine < 1) {\n            return {\n                indentation: '',\n                action: null\n            };\n        }\n        const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);\n        if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: IndentAction.Indent,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) {\n            return {\n                indentation: strings.getLeadingWhitespace(precedingUnIgnoredLineContent),\n                action: null,\n                line: precedingUnIgnoredLine\n            };\n        }\n        else {\n            // precedingUnIgnoredLine can not be ignored.\n            // it doesn't increase indent of following lines\n            // it doesn't increase just next line\n            // so current line is not affect by precedingUnIgnoredLine\n            // and then we should get a correct inheritted indentation from above lines\n            if (precedingUnIgnoredLine === 1) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            const previousLine = precedingUnIgnoredLine - 1;\n            const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));\n            if (!(previousLineIndentMetadata & (1 /* INCREASE_MASK */ | 2 /* DECREASE_MASK */)) &&\n                (previousLineIndentMetadata & 4 /* INDENT_NEXTLINE_MASK */)) {\n                let stopLine = 0;\n                for (let i = previousLine - 1; i > 0; i--) {\n                    if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                        continue;\n                    }\n                    stopLine = i;\n                    break;\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                    action: null,\n                    line: stopLine + 1\n                };\n            }\n            if (honorIntentialIndent) {\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),\n                    action: null,\n                    line: precedingUnIgnoredLine\n                };\n            }\n            else {\n                // search from precedingUnIgnoredLine until we find one whose indent is not temporary\n                for (let i = precedingUnIgnoredLine; i > 0; i--) {\n                    const lineContent = model.getLineContent(i);\n                    if (indentRulesSupport.shouldIncrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: IndentAction.Indent,\n                            line: i\n                        };\n                    }\n                    else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {\n                        let stopLine = 0;\n                        for (let j = i - 1; j > 0; j--) {\n                            if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) {\n                                continue;\n                            }\n                            stopLine = j;\n                            break;\n                        }\n                        return {\n                            indentation: strings.getLeadingWhitespace(model.getLineContent(stopLine + 1)),\n                            action: null,\n                            line: stopLine + 1\n                        };\n                    }\n                    else if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        return {\n                            indentation: strings.getLeadingWhitespace(lineContent),\n                            action: null,\n                            line: i\n                        };\n                    }\n                }\n                return {\n                    indentation: strings.getLeadingWhitespace(model.getLineContent(1)),\n                    action: null,\n                    line: 1\n                };\n            }\n        }\n    }\n    getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const richEditSupport = this.getLanguageConfiguration(languageId);\n        if (!richEditSupport) {\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);\n        const lineContent = virtualModel.getLineContent(lineNumber);\n        if (indent) {\n            const inheritLine = indent.line;\n            if (inheritLine !== undefined) {\n                const enterResult = richEditSupport.onEnter(autoIndent, '', virtualModel.getLineContent(inheritLine), '');\n                if (enterResult) {\n                    let indentation = strings.getLeadingWhitespace(virtualModel.getLineContent(inheritLine));\n                    if (enterResult.removeText) {\n                        indentation = indentation.substring(0, indentation.length - enterResult.removeText);\n                    }\n                    if ((enterResult.indentAction === IndentAction.Indent) ||\n                        (enterResult.indentAction === IndentAction.IndentOutdent)) {\n                        indentation = indentConverter.shiftIndent(indentation);\n                    }\n                    else if (enterResult.indentAction === IndentAction.Outdent) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (indentRulesSupport.shouldDecrease(lineContent)) {\n                        indentation = indentConverter.unshiftIndent(indentation);\n                    }\n                    if (enterResult.appendText) {\n                        indentation += enterResult.appendText;\n                    }\n                    return strings.getLeadingWhitespace(indentation);\n                }\n            }\n            if (indentRulesSupport.shouldDecrease(lineContent)) {\n                if (indent.action === IndentAction.Indent) {\n                    return indent.indentation;\n                }\n                else {\n                    return indentConverter.unshiftIndent(indent.indentation);\n                }\n            }\n            else {\n                if (indent.action === IndentAction.Indent) {\n                    return indentConverter.shiftIndent(indent.indentation);\n                }\n                else {\n                    return indent.indentation;\n                }\n            }\n        }\n        return null;\n    }\n    getIndentForEnter(autoIndent, model, range, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        model.forceTokenization(range.startLineNumber);\n        const lineTokens = model.getLineTokens(range.startLineNumber);\n        const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);\n        const scopedLineText = scopedLineTokens.getLineContent();\n        let embeddedLanguage = false;\n        let beforeEnterText;\n        if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {\n            // we are in the embeded language content\n            embeddedLanguage = true; // if embeddedLanguage is true, then we don't touch the indentation of current line\n            beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);\n        }\n        let afterEnterText;\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const beforeEnterResult = beforeEnterText;\n        const beforeEnterIndent = strings.getLeadingWhitespace(beforeEnterText);\n        const virtualModel = {\n            getLineTokens: (lineNumber) => {\n                return model.getLineTokens(lineNumber);\n            },\n            getLanguageId: () => {\n                return model.getLanguageId();\n            },\n            getLanguageIdAtPosition: (lineNumber, column) => {\n                return model.getLanguageIdAtPosition(lineNumber, column);\n            },\n            getLineContent: (lineNumber) => {\n                if (lineNumber === range.startLineNumber) {\n                    return beforeEnterResult;\n                }\n                else {\n                    return model.getLineContent(lineNumber);\n                }\n            }\n        };\n        const currentLineIndent = strings.getLeadingWhitespace(lineTokens.getLineContent());\n        const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);\n        if (!afterEnterAction) {\n            const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;\n            return {\n                beforeEnter: beforeEnter,\n                afterEnter: beforeEnter\n            };\n        }\n        let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;\n        if (afterEnterAction.action === IndentAction.Indent) {\n            afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);\n        }\n        if (indentRulesSupport.shouldDecrease(afterEnterText)) {\n            afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);\n        }\n        return {\n            beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,\n            afterEnter: afterEnterIndent\n        };\n    }\n    /**\n     * We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of\n     * this line doesn't match decreaseIndentPattern, we should not adjust the indentation.\n     */\n    getIndentActionForType(autoIndent, model, range, ch, indentConverter) {\n        if (autoIndent < 4 /* Full */) {\n            return null;\n        }\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        if (scopedLineTokens.firstCharOffset) {\n            // this line has mixed languages and indentation rules will not work\n            return null;\n        }\n        const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);\n        if (!indentRulesSupport) {\n            return null;\n        }\n        const scopedLineText = scopedLineTokens.getLineContent();\n        const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        // selection support\n        let afterTypeText;\n        if (range.isEmpty()) {\n            afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterTypeText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        // If previous content already matches decreaseIndentPattern, it means indentation of this line should already be adjusted\n        // Users might change the indentation by purpose and we should honor that instead of readjusting.\n        if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {\n            // after typing `ch`, the content matches decreaseIndentPattern, we should adjust the indent to a good manner.\n            // 1. Get inherited indent action\n            const r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);\n            if (!r) {\n                return null;\n            }\n            let indentation = r.indentation;\n            if (r.action !== IndentAction.Indent) {\n                indentation = indentConverter.unshiftIndent(indentation);\n            }\n            return indentation;\n        }\n        return null;\n    }\n    getIndentMetadata(model, lineNumber) {\n        const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());\n        if (!indentRulesSupport) {\n            return null;\n        }\n        if (lineNumber < 1 || lineNumber > model.getLineCount()) {\n            return null;\n        }\n        return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));\n    }\n    // end Indent Rules\n    // begin onEnter\n    getEnterAction(autoIndent, model, range) {\n        const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);\n        const richEditSupport = this.getLanguageConfiguration(scopedLineTokens.languageId);\n        if (!richEditSupport) {\n            return null;\n        }\n        const scopedLineText = scopedLineTokens.getLineContent();\n        const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        // selection support\n        let afterEnterText;\n        if (range.isEmpty()) {\n            afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        else {\n            const endScopedLineTokens = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn);\n            afterEnterText = endScopedLineTokens.getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);\n        }\n        let previousLineText = '';\n        if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {\n            // This is not the first line and the entire line belongs to this mode\n            const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);\n            if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) {\n                // The line above ends with text belonging to the same mode\n                previousLineText = oneLineAboveScopedLineTokens.getLineContent();\n            }\n        }\n        const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n        if (!enterResult) {\n            return null;\n        }\n        const indentAction = enterResult.indentAction;\n        let appendText = enterResult.appendText;\n        const removeText = enterResult.removeText || 0;\n        // Here we add `\\t` to appendText first because enterAction is leveraging appendText and removeText to change indentation.\n        if (!appendText) {\n            if ((indentAction === IndentAction.Indent) ||\n                (indentAction === IndentAction.IndentOutdent)) {\n                appendText = '\\t';\n            }\n            else {\n                appendText = '';\n            }\n        }\n        else if (indentAction === IndentAction.Indent) {\n            appendText = '\\t' + appendText;\n        }\n        let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);\n        if (removeText) {\n            indentation = indentation.substring(0, indentation.length - removeText);\n        }\n        return {\n            indentAction: indentAction,\n            appendText: appendText,\n            removeText: removeText,\n            indentation: indentation\n        };\n    }\n    getIndentationAtPosition(model, lineNumber, column) {\n        const lineText = model.getLineContent(lineNumber);\n        let indentation = strings.getLeadingWhitespace(lineText);\n        if (indentation.length > column - 1) {\n            indentation = indentation.substring(0, column - 1);\n        }\n        return indentation;\n    }\n    getScopedLineTokens(model, lineNumber, columnNumber) {\n        model.forceTokenization(lineNumber);\n        const lineTokens = model.getLineTokens(lineNumber);\n        const column = (typeof columnNumber === 'undefined' ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);\n        return createScopedLineTokens(lineTokens, column);\n    }\n}\n/**\n * @deprecated Use ILanguageConfigurationService instead.\n*/\nexport const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet() {\n        return this.characterPair.getAutoCloseBeforeSet();\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { LanguageConfigurationRegistry } from '../languages/languageConfigurationRegistry.js';\nconst repeatCache = Object.create(null);\nexport function cachedStringRepeat(str, count) {\n    if (count <= 0) {\n        return '';\n    }\n    if (!repeatCache[str]) {\n        repeatCache[str] = ['', str];\n    }\n    const cache = repeatCache[str];\n    for (let i = cache.length; i <= count; i++) {\n        cache[i] = cache[i - 1] + str;\n    }\n    return cache[count];\n}\nexport class ShiftCommand {\n    constructor(range, opts) {\n        this._opts = opts;\n        this._selection = range;\n        this._selectionId = null;\n        this._useLastEditRangeForCursorEndPosition = false;\n        this._selectionStartColumnStaysPut = false;\n    }\n    static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {\n        // Determine the visible column where the content starts\n        const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);\n        if (insertSpaces) {\n            const indent = cachedStringRepeat(' ', indentSize);\n            const desiredTabStop = CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize);\n            const indentCount = desiredTabStop / indentSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n        else {\n            const indent = '\\t';\n            const desiredTabStop = CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize);\n            const indentCount = desiredTabStop / tabSize; // will be an integer\n            return cachedStringRepeat(indent, indentCount);\n        }\n    }\n    _addEditOperation(builder, range, text) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            builder.addTrackedEditOperation(range, text);\n        }\n        else {\n            builder.addEditOperation(range, text);\n        }\n    }\n    getEditOperations(model, builder) {\n        const startLine = this._selection.startLineNumber;\n        let endLine = this._selection.endLineNumber;\n        if (this._selection.endColumn === 1 && startLine !== endLine) {\n            endLine = endLine - 1;\n        }\n        const { tabSize, indentSize, insertSpaces } = this._opts;\n        const shouldIndentEmptyLines = (startLine === endLine);\n        if (this._opts.useTabStops) {\n            // if indenting or outdenting on a whitespace only line\n            if (this._selection.isEmpty()) {\n                if (/^\\s*$/.test(model.getLineContent(startLine))) {\n                    this._useLastEditRangeForCursorEndPosition = true;\n                }\n            }\n            // keep track of previous line's \"miss-alignment\"\n            let previousLineExtraSpaces = 0, extraSpaces = 0;\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {\n                extraSpaces = 0;\n                const lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (lineNumber > 1) {\n                    const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize);\n                    if (contentStartVisibleColumn % indentSize !== 0) {\n                        // The current line is \"miss-aligned\", so let's see if this is expected...\n                        // This can only happen when it has trailing commas in the indent\n                        if (model.isCheapToTokenize(lineNumber - 1)) {\n                            const enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model, new Range(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)));\n                            if (enterAction) {\n                                extraSpaces = previousLineExtraSpaces;\n                                if (enterAction.appendText) {\n                                    for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) {\n                                        if (enterAction.appendText.charCodeAt(j) === 32 /* Space */) {\n                                            extraSpaces++;\n                                        }\n                                        else {\n                                            break;\n                                        }\n                                    }\n                                }\n                                if (enterAction.removeText) {\n                                    extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);\n                                }\n                                // Act as if `prefixSpaces` is not part of the indentation\n                                for (let j = 0; j < extraSpaces; j++) {\n                                    if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32 /* Space */) {\n                                        break;\n                                    }\n                                    indentationEndIndex--;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                let desiredIndent;\n                if (this._opts.isUnshift) {\n                    desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                else {\n                    desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);\n                }\n                this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);\n                if (lineNumber === startLine && !this._selection.isEmpty()) {\n                    // Force the startColumn to stay put because we're inserting after it\n                    this._selectionStartColumnStaysPut = (this._selection.startColumn <= indentationEndIndex + 1);\n                }\n            }\n        }\n        else {\n            // if indenting or outdenting on a whitespace only line\n            if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) {\n                this._useLastEditRangeForCursorEndPosition = true;\n            }\n            const oneIndent = (insertSpaces ? cachedStringRepeat(' ', indentSize) : '\\t');\n            for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {\n                const lineText = model.getLineContent(lineNumber);\n                let indentationEndIndex = strings.firstNonWhitespaceIndex(lineText);\n                if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) {\n                    // empty line or line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) {\n                    // do not indent empty lines => nothing to do\n                    continue;\n                }\n                if (indentationEndIndex === -1) {\n                    // the entire line is whitespace\n                    indentationEndIndex = lineText.length;\n                }\n                if (this._opts.isUnshift && indentationEndIndex === 0) {\n                    // line with no leading whitespace => nothing to do\n                    continue;\n                }\n                if (this._opts.isUnshift) {\n                    indentationEndIndex = Math.min(indentationEndIndex, indentSize);\n                    for (let i = 0; i < indentationEndIndex; i++) {\n                        const chr = lineText.charCodeAt(i);\n                        if (chr === 9 /* Tab */) {\n                            indentationEndIndex = i + 1;\n                            break;\n                        }\n                    }\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, indentationEndIndex + 1), '');\n                }\n                else {\n                    this._addEditOperation(builder, new Range(lineNumber, 1, lineNumber, 1), oneIndent);\n                    if (lineNumber === startLine && !this._selection.isEmpty()) {\n                        // Force the startColumn to stay put because we're inserting after it\n                        this._selectionStartColumnStaysPut = (this._selection.startColumn === 1);\n                    }\n                }\n            }\n        }\n        this._selectionId = builder.trackSelection(this._selection);\n    }\n    computeCursorState(model, helper) {\n        if (this._useLastEditRangeForCursorEndPosition) {\n            const lastOp = helper.getInverseEditOperations()[0];\n            return new Selection(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);\n        }\n        const result = helper.getTrackedSelection(this._selectionId);\n        if (this._selectionStartColumnStaysPut) {\n            // The selection start should not move\n            const initialStartColumn = this._selection.startColumn;\n            const resultStartColumn = result.startColumn;\n            if (resultStartColumn <= initialStartColumn) {\n                return result;\n            }\n            if (result.getDirection() === 0 /* LTR */) {\n                return new Selection(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);\n            }\n            return new Selection(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);\n        }\n        return result;\n    }\n}\n","// @ts-nocheck\n/**\n * An adapter to make CodeMirror's vim bindings work with monaco\n */\nimport {\n  KeyCode,\n  Range,\n  Position,\n  Selection,\n  SelectionDirection,\n  editor as monacoEditor,\n} from \"monaco-editor/esm/vs/editor/editor.api\";\nimport { ShiftCommand } from \"monaco-editor/esm/vs/editor/common/commands/shiftCommand\";\nconst VerticalRevealType = {\n  Bottom: 4,\n};\n\n// for monaco 0.19.x where x < 3\nconst EditorOptConstants = {\n  readOnly: 65,\n  cursorWidth: 20,\n  fontInfo: 32,\n};\n\nconst nonASCIISingleCaseWordChar =\n  /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n\nfunction isWordCharBasic(ch) {\n  return (\n    /\\w/.test(ch) ||\n    (ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() ||\n        nonASCIISingleCaseWordChar.test(ch)))\n  );\n}\n\nfunction Pos(line, column) {\n  if (!(this instanceof Pos)) {\n    return new Pos(line, column);\n  }\n\n  this.line = line;\n  this.ch = column;\n}\n\nfunction signal(cm, signal, args) {\n  cm.dispatch(signal, args);\n}\n\nfunction dummy(key) {\n  return function () {\n    // console.log(key, 'dummy function called with', Array.prototype.slice.call(arguments));\n  };\n}\n\nlet doFold, noFold;\n\nif (String.prototype.normalize) {\n  doFold = function (str) {\n    return str.normalize(\"NFD\").toLowerCase();\n  };\n  noFold = function (str) {\n    return str.normalize(\"NFD\");\n  };\n} else {\n  doFold = function (str) {\n    return str.toLowerCase();\n  };\n  noFold = function (str) {\n    return str;\n  };\n}\n\nvar StringStream = function (string, tabSize) {\n  this.pos = this.start = 0;\n  this.string = string;\n  this.tabSize = tabSize || 8;\n  this.lastColumnPos = this.lastColumnValue = 0;\n  this.lineStart = 0;\n};\n\nStringStream.prototype = {\n  eol: function () {\n    return this.pos >= this.string.length;\n  },\n  sol: function () {\n    return this.pos == this.lineStart;\n  },\n  peek: function () {\n    return this.string.charAt(this.pos) || undefined;\n  },\n  next: function () {\n    if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n  },\n  eat: function (match) {\n    var ch = this.string.charAt(this.pos);\n    if (typeof match == \"string\") var ok = ch == match;\n    else var ok = ch && (match.test ? match.test(ch) : match(ch));\n    if (ok) {\n      ++this.pos;\n      return ch;\n    }\n  },\n  eatWhile: function (match) {\n    var start = this.pos;\n    while (this.eat(match)) {}\n    return this.pos > start;\n  },\n  eatSpace: function () {\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n    return this.pos > start;\n  },\n  skipToEnd: function () {\n    this.pos = this.string.length;\n  },\n  skipTo: function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {\n      this.pos = found;\n      return true;\n    }\n  },\n  backUp: function (n) {\n    this.pos -= n;\n  },\n  column: function () {\n    throw \"not implemented\";\n  },\n  indentation: function () {\n    throw \"not implemented\";\n  },\n  match: function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) {\n        return caseInsensitive ? str.toLowerCase() : str;\n      };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) this.pos += pattern.length;\n        return true;\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) return null;\n      if (match && consume !== false) this.pos += match[0].length;\n      return match;\n    }\n  },\n  current: function () {\n    return this.string.slice(this.start, this.pos);\n  },\n  hideFirstChars: function (n, inner) {\n    this.lineStart += n;\n    try {\n      return inner();\n    } finally {\n      this.lineStart -= n;\n    }\n  },\n};\n\nfunction toCmPos(pos) {\n  return new Pos(pos.lineNumber - 1, pos.column - 1);\n}\n\nfunction toMonacoPos(pos) {\n  return new Position(pos.line + 1, pos.ch + 1);\n}\n\nclass Marker {\n  constructor(cm, id, line, ch) {\n    this.cm = cm;\n    this.id = id;\n    this.lineNumber = line + 1;\n    this.column = ch + 1;\n    cm.marks[this.id] = this;\n  }\n\n  clear() {\n    delete this.cm.marks[this.id];\n  }\n\n  find() {\n    return toCmPos(this);\n  }\n}\n\nfunction monacoToCmKey(e, skip = false) {\n  let addQuotes = true;\n  let keyName = KeyCode[e.keyCode];\n\n  if (e.key) {\n    keyName = e.key;\n    addQuotes = false;\n  }\n\n  let key = keyName;\n  let skipOnlyShiftCheck = skip;\n\n  switch (e.keyCode) {\n    case KeyCode.Shift:\n    case KeyCode.Meta:\n    case KeyCode.Alt:\n    case KeyCode.Ctrl:\n      return key;\n    case KeyCode.Escape:\n      skipOnlyShiftCheck = true;\n      key = \"Esc\";\n      break;\n    case KeyCode.Space:\n      skipOnlyShiftCheck = true;\n      break;\n  }\n\n  // `Key` check for monaco >= 0.30.0\n  if (keyName.startsWith(\"Key\") || keyName.startsWith(\"KEY_\")) {\n    key = keyName[keyName.length - 1].toLowerCase();\n  } else if (keyName.startsWith(\"Digit\")) {\n    key = keyName.slice(5, 6);\n  } else if (keyName.startsWith(\"Numpad\")) {\n    key = keyName.slice(6, 7);\n  } else if (keyName.endsWith(\"Arrow\")) {\n    skipOnlyShiftCheck = true;\n    key = keyName.substring(0, keyName.length - 5);\n  } else if (\n    keyName.startsWith(\"US_\") ||\n    // `Bracket` check for monaco >= 0.30.0\n    keyName.startsWith(\"Bracket\") ||\n    !key\n  ) {\n    key = e.browserEvent.key;\n  }\n\n  if (!skipOnlyShiftCheck && !e.altKey && !e.ctrlKey && !e.metaKey) {\n    key = e.key || e.browserEvent.key;\n  } else {\n    if (e.altKey) {\n      key = `Alt-${key}`;\n    }\n    if (e.ctrlKey) {\n      key = `Ctrl-${key}`;\n    }\n    if (e.metaKey) {\n      key = `Meta-${key}`;\n    }\n    if (e.shiftKey) {\n      key = `Shift-${key}`;\n    }\n  }\n\n  if (key.length === 1 && addQuotes) {\n    key = `'${key}'`;\n  }\n\n  return key;\n}\n\nclass CMAdapter {\n  static Pos = Pos;\n  static signal = signal;\n  static on = dummy(\"on\");\n  static off = dummy(\"off\");\n  static addClass = dummy(\"addClass\");\n  static rmClass = dummy(\"rmClass\");\n  static defineOption = dummy(\"defineOption\");\n  static keyMap = {\n    default: function (key) {\n      return function (cm) {\n        return true;\n      };\n    },\n  };\n  static matchingBrackets = {\n    \"(\": \")>\",\n    \")\": \"(<\",\n    \"[\": \"]>\",\n    \"]\": \"[<\",\n    \"{\": \"}>\",\n    \"}\": \"{<\",\n    \"<\": \">>\",\n    \">\": \"<<\",\n  };\n  static isWordChar = isWordCharBasic;\n  static keyName = monacoToCmKey;\n  static StringStream = StringStream;\n  static e_stop = function (e) {\n    if (e.stopPropagation) {\n      e.stopPropagation();\n    } else {\n      e.cancelBubble = true;\n    }\n    CMAdapter.e_preventDefault(e);\n    return false;\n  };\n\n  static e_preventDefault = function (e) {\n    if (e.preventDefault) {\n      e.preventDefault();\n\n      if (e.browserEvent) {\n        e.browserEvent.preventDefault();\n      }\n    } else {\n      e.returnValue = false;\n    }\n\n    return false;\n  };\n\n  static commands = {\n    redo: function (cm) {\n      cm.editor.getModel().redo();\n    },\n    undo: function (cm) {\n      cm.editor.getModel().undo();\n    },\n    newlineAndIndent: function (cm) {\n      cm.triggerEditorAction(\"editor.action.insertLineAfter\");\n    },\n  };\n\n  static lookupKey = function lookupKey(key, map, handle) {\n    if (typeof map === \"string\") {\n      map = CMAdapter.keyMap[map];\n    }\n    const found = typeof map == \"function\" ? map(key) : map[key];\n\n    if (found === false) return \"nothing\";\n    if (found === \"...\") return \"multi\";\n    if (found != null && handle(found)) return \"handled\";\n\n    if (map.fallthrough) {\n      if (!Array.isArray(map.fallthrough))\n        return lookupKey(key, map.fallthrough, handle);\n      for (var i = 0; i < map.fallthrough.length; i++) {\n        var result = lookupKey(key, map.fallthrough[i], handle);\n        if (result) return result;\n      }\n    }\n  };\n\n  static defineExtension = function (name, fn) {\n    CMAdapter.prototype[name] = fn;\n  };\n\n  constructor(editor) {\n    this.editor = editor;\n    this.state = {\n      keyMap: \"vim\",\n    };\n    this.marks = {};\n    this.$uid = 0;\n    this.disposables = [];\n    this.listeners = {};\n    this.curOp = {};\n    this.attached = false;\n    this.statusBar = null;\n    this.options = {};\n    this.addLocalListeners();\n    this.ctxInsert = this.editor.createContextKey(\"insertMode\", true);\n  }\n\n  attach() {\n    CMAdapter.keyMap.vim.attach(this);\n  }\n\n  addLocalListeners() {\n    this.disposables.push(\n      this.editor.onDidChangeCursorPosition(this.handleCursorChange),\n      this.editor.onDidChangeModelContent(this.handleChange),\n      this.editor.onKeyDown(this.handleKeyDown),\n    );\n  }\n\n  handleKeyDown = (e) => {\n    // Allow previously registered keydown listeners to handle the event and\n    // prevent this extension from also handling it.\n    if (e.browserEvent.defaultPrevented & (e.keyCode !== KeyCode.Escape)) {\n      return;\n    }\n\n    if (!this.attached) {\n      return;\n    }\n\n    const key = monacoToCmKey(e);\n\n    if (this.replaceMode) {\n      this.handleReplaceMode(key, e);\n    }\n\n    if (!key) {\n      return;\n    }\n\n    const keymap = this.state.keyMap;\n    if (CMAdapter.keyMap[keymap] && CMAdapter.keyMap[keymap].call) {\n      const cmd = CMAdapter.keyMap[keymap].call(key, this);\n      if (cmd) {\n        e.preventDefault();\n        e.stopPropagation();\n\n        try {\n          cmd();\n        } catch (err) {\n          console.error(err);\n        }\n      }\n    }\n  };\n\n  handleReplaceMode(key, e) {\n    let fromReplace = false;\n    let char = key;\n    const pos = this.editor.getPosition();\n    let range = new Range(\n      pos.lineNumber,\n      pos.column,\n      pos.lineNumber,\n      pos.column + 1,\n    );\n    let forceMoveMarkers = true;\n\n    if (key.startsWith(\"'\")) {\n      char = key[1];\n    } else if (char === \"Enter\") {\n      char = \"\\n\";\n    } else if (char === \"Backspace\") {\n      const lastItem = this.replaceStack.pop();\n\n      if (!lastItem) {\n        return;\n      }\n\n      fromReplace = true;\n      char = lastItem;\n      range = new Range(\n        pos.lineNumber,\n        pos.column,\n        pos.lineNumber,\n        pos.column - 1,\n      );\n    } else {\n      return;\n    }\n\n    e.preventDefault();\n    e.stopPropagation();\n\n    if (!this.replaceStack) {\n      this.replaceStack = [];\n    }\n\n    if (!fromReplace) {\n      this.replaceStack.push(this.editor.getModel().getValueInRange(range));\n    }\n\n    this.editor.executeEdits(\"vim\", [\n      {\n        text: char,\n        range,\n        forceMoveMarkers,\n      },\n    ]);\n\n    if (fromReplace) {\n      this.editor.setPosition(range.getStartPosition());\n    }\n  }\n\n  handleCursorChange = (e) => {\n    const { position, source } = e;\n    const { editor } = this;\n    const selection = editor.getSelection();\n\n    if (!this.ctxInsert.get() && e.source === \"mouse\" && selection.isEmpty()) {\n      const maxCol = editor.getModel().getLineMaxColumn(position.lineNumber);\n\n      if (e.position.column === maxCol) {\n        editor.setPosition(new Position(e.position.lineNumber, maxCol - 1));\n        return;\n      }\n    }\n\n    this.dispatch(\"cursorActivity\", this, e);\n  };\n\n  handleChange = (e) => {\n    const { changes } = e;\n    const change = {\n      text: changes.reduce((acc, change) => {\n        acc.push(change.text);\n        return acc;\n      }, []),\n      origin: \"+input\",\n    };\n    const curOp = (this.curOp = this.curOp || {});\n\n    if (!curOp.changeHandlers) {\n      curOp.changeHandlers =\n        this.listeners[\"change\"] && this.listeners[\"change\"].slice();\n    }\n\n    if (this.virtualSelectionMode()) {\n      return;\n    }\n\n    if (!curOp.lastChange) {\n      curOp.lastChange = curOp.change = change;\n    } else {\n      curOp.lastChange.next = curOp.lastChange = change;\n    }\n\n    this.dispatch(\"change\", this, change);\n  };\n\n  setOption(key, value) {\n    this.state[key] = value;\n\n    if (key === \"theme\") {\n      monacoEditor.setTheme(value);\n    }\n  }\n\n  getConfiguration() {\n    const { editor } = this;\n    let opts = EditorOptConstants;\n\n    if (typeof editor.getConfiguration === \"function\") {\n      return editor.getConfiguration();\n    } else if (\"EditorOption\" in monacoEditor) {\n      // for monaco 0.19.3 onwards\n      opts = monacoEditor.EditorOption;\n    }\n\n    return {\n      readOnly: editor.getOption(opts.readOnly),\n      viewInfo: {\n        cursorWidth: editor.getOption(opts.cursorWidth),\n      },\n      fontInfo: editor.getOption(opts.fontInfo),\n    };\n  }\n\n  getOption(key) {\n    if (key === \"readOnly\") {\n      return this.getConfiguration().readOnly;\n    } else if (key === \"firstLineNumber\") {\n      return this.firstLine() + 1;\n    } else if (key === \"indentWithTabs\") {\n      return !this.editor.getModel().getOptions().insertSpaces;\n    } else {\n      if (typeof this.editor.getConfiguration === \"function\") {\n        return this.editor.getRawConfiguration()[key];\n      }\n      return this.editor.getRawOptions()[key];\n    }\n  }\n\n  dispatch(signal, ...args) {\n    const listeners = this.listeners[signal];\n    if (!listeners) {\n      return;\n    }\n\n    listeners.forEach((handler) => handler(...args));\n  }\n\n  on(event, handler) {\n    if (!this.listeners[event]) {\n      this.listeners[event] = [];\n    }\n\n    this.listeners[event].push(handler);\n  }\n\n  off(event, handler) {\n    const listeners = this.listeners[event];\n    if (!listeners) {\n      return;\n    }\n\n    this.listeners[event] = listeners.filter((l) => l !== handler);\n  }\n\n  firstLine() {\n    return 0;\n  }\n\n  lastLine() {\n    return this.lineCount() - 1;\n  }\n\n  lineCount() {\n    return this.editor.getModel().getLineCount();\n  }\n\n  defaultTextHeight() {\n    return 1;\n  }\n\n  getLine(line) {\n    if (line < 0) {\n      return \"\";\n    }\n    const model = this.editor.getModel();\n    const maxLines = model.getLineCount();\n\n    if (line + 1 > maxLines) {\n      line = maxLines - 1;\n    }\n\n    return this.editor.getModel().getLineContent(line + 1);\n  }\n\n  getAnchorForSelection(selection) {\n    if (selection.isEmpty()) {\n      return selection.getPosition();\n    }\n\n    const selDir = selection.getDirection();\n    return selDir === SelectionDirection.LTR\n      ? selection.getStartPosition()\n      : selection.getEndPosition();\n  }\n\n  getHeadForSelection(selection) {\n    if (selection.isEmpty()) {\n      return selection.getPosition();\n    }\n\n    const selDir = selection.getDirection();\n    return selDir === SelectionDirection.LTR\n      ? selection.getEndPosition()\n      : selection.getStartPosition();\n  }\n\n  getCursor(type = null) {\n    if (!type) {\n      return toCmPos(this.editor.getPosition());\n    }\n\n    const sel = this.editor.getSelection();\n    let pos;\n\n    if (sel.isEmpty()) {\n      pos = sel.getPosition();\n    } else if (type === \"anchor\") {\n      pos = this.getAnchorForSelection(sel);\n    } else {\n      pos = this.getHeadForSelection(sel);\n    }\n\n    return toCmPos(pos);\n  }\n\n  getRange(start, end) {\n    const p1 = toMonacoPos(start);\n    const p2 = toMonacoPos(end);\n\n    return this.editor.getModel().getValueInRange(Range.fromPositions(p1, p2));\n  }\n\n  getSelection() {\n    var list = [];\n    var editor = this.editor;\n    editor.getSelections().map(function (sel) {\n      list.push(editor.getModel().getValueInRange(sel));\n    });\n    return list.join(\"\\n\");\n  }\n\n  replaceRange(text, start, end) {\n    const p1 = toMonacoPos(start);\n    const p2 = !end ? p1 : toMonacoPos(end);\n\n    this.editor.executeEdits(\"vim\", [\n      {\n        text,\n        range: Range.fromPositions(p1, p2),\n      },\n    ]);\n    // @TODO - Check if this breaks any other expectation\n    this.pushUndoStop();\n  }\n\n  pushUndoStop() {\n    this.editor.pushUndoStop();\n  }\n\n  setCursor(line, ch) {\n    let pos = line;\n\n    if (typeof line !== \"object\") {\n      pos = {};\n      pos.line = line;\n      pos.ch = ch;\n    }\n\n    const monacoPos = this.editor.getModel().validatePosition(toMonacoPos(pos));\n    this.editor.setPosition(toMonacoPos(pos));\n    this.editor.revealPosition(monacoPos);\n  }\n\n  somethingSelected() {\n    return !this.editor.getSelection().isEmpty();\n  }\n\n  operation(fn, force) {\n    return fn();\n  }\n\n  listSelections() {\n    const selections = this.editor.getSelections();\n\n    if (!selections.length || this.inVirtualSelectionMode) {\n      return [\n        {\n          anchor: this.getCursor(\"anchor\"),\n          head: this.getCursor(\"head\"),\n        },\n      ];\n    }\n\n    return selections.map((sel) => {\n      const pos = sel.getPosition();\n      const start = sel.getStartPosition();\n      const end = sel.getEndPosition();\n\n      return {\n        anchor: this.clipPos(toCmPos(this.getAnchorForSelection(sel))),\n        head: this.clipPos(toCmPos(this.getHeadForSelection(sel))),\n      };\n    });\n  }\n\n  focus() {\n    this.editor.focus();\n  }\n\n  setSelections(selections, primIndex) {\n    const hasSel = !!this.editor.getSelections().length;\n    const sels = selections.map((sel, index) => {\n      const { anchor, head } = sel;\n\n      if (hasSel) {\n        return Selection.fromPositions(toMonacoPos(anchor), toMonacoPos(head));\n      } else {\n        return Selection.fromPositions(toMonacoPos(head), toMonacoPos(anchor));\n      }\n    });\n\n    if (!primIndex) {\n    } else if (sels[primIndex]) {\n      sels.push(sels.splice(primIndex, 1)[0]);\n    }\n\n    if (!sels.length) {\n      return;\n    }\n\n    const sel = sels[0];\n    let posToReveal;\n\n    if (sel.getDirection() === SelectionDirection.LTR) {\n      posToReveal = sel.getEndPosition();\n    } else {\n      posToReveal = sel.getStartPosition();\n    }\n\n    this.editor.setSelections(sels);\n    this.editor.revealPosition(posToReveal);\n  }\n\n  setSelection(frm, to) {\n    const range = Range.fromPositions(toMonacoPos(frm), toMonacoPos(to));\n    this.editor.setSelection(range);\n  }\n\n  getSelections() {\n    const { editor } = this;\n    return editor\n      .getSelections()\n      .map((sel) => editor.getModel().getValueInRange(sel));\n  }\n\n  replaceSelections(texts) {\n    const { editor } = this;\n\n    editor.getSelections().forEach((sel, index) => {\n      editor.executeEdits(\"vim\", [\n        {\n          range: sel,\n          text: texts[index],\n          forceMoveMarkers: false,\n        },\n      ]);\n    });\n  }\n\n  toggleOverwrite(toggle) {\n    if (toggle) {\n      this.enterVimMode();\n      this.replaceMode = true;\n    } else {\n      this.leaveVimMode();\n      this.replaceMode = false;\n      this.replaceStack = [];\n    }\n  }\n\n  charCoords(pos, mode) {\n    return {\n      top: pos.line,\n      left: pos.ch,\n    };\n  }\n\n  coordsChar(pos, mode) {\n    if (mode === \"local\") {\n    }\n  }\n\n  clipPos(p) {\n    const pos = this.editor.getModel().validatePosition(toMonacoPos(p));\n    return toCmPos(pos);\n  }\n\n  setBookmark(cursor, options) {\n    const bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);\n\n    if (!options || !options.insertLeft) {\n      bm.$insertRight = true;\n    }\n\n    this.marks[bm.id] = bm;\n    return bm;\n  }\n\n  getScrollInfo() {\n    const { editor } = this;\n    const [range] = editor.getVisibleRanges();\n\n    return {\n      left: 0,\n      top: range.startLineNumber - 1,\n      height: editor.getModel().getLineCount(),\n      clientHeight: range.endLineNumber - range.startLineNumber + 1,\n    };\n  }\n\n  triggerEditorAction(action) {\n    this.editor.trigger(\"vim\", action);\n  }\n\n  dispose() {\n    this.dispatch(\"dispose\");\n    this.removeOverlay();\n\n    if (CMAdapter.keyMap.vim) {\n      CMAdapter.keyMap.vim.detach(this);\n    }\n\n    this.disposables.forEach((d) => d.dispose());\n  }\n\n  getInputField() {}\n  getWrapperElement() {}\n\n  enterVimMode(toVim = true) {\n    this.ctxInsert.set(false);\n    const config = this.getConfiguration();\n    this.initialCursorWidth = config.viewInfo.cursorWidth || 0;\n\n    this.editor.updateOptions({\n      cursorWidth: config.fontInfo.typicalFullwidthCharacterWidth,\n      cursorBlinking: \"solid\",\n      cursorStyle: \"block\",\n    });\n  }\n\n  leaveVimMode() {\n    this.ctxInsert.set(true);\n\n    this.editor.updateOptions({\n      cursorWidth: this.initialCursorWidth || 0,\n      cursorBlinking: \"blink\",\n      cursorStyle: \"line\",\n    });\n  }\n\n  virtualSelectionMode() {\n    return this.inVirtualSelectionMode;\n  }\n\n  markText() {\n    // only used for fat-cursor, not needed\n    return { clear: function () {}, find: function () {} };\n  }\n\n  getUserVisibleLines() {\n    const ranges = this.editor.getVisibleRanges();\n    if (!ranges.length) {\n      return {\n        top: 0,\n        bottom: 0,\n      };\n    }\n\n    const res = {\n      top: Infinity,\n      bottom: 0,\n    };\n\n    ranges.reduce((acc, range) => {\n      if (range.startLineNumber < acc.top) {\n        acc.top = range.startLineNumber;\n      }\n\n      if (range.endLineNumber > acc.bottom) {\n        acc.bottom = range.endLineNumber;\n      }\n\n      return acc;\n    }, res);\n\n    res.top -= 1;\n    res.bottom -= 1;\n\n    return res;\n  }\n\n  findPosV(startPos, amount, unit) {\n    const { editor } = this;\n    let finalAmount = amount;\n    let finalUnit = unit;\n    const pos = toMonacoPos(startPos);\n\n    if (unit === \"page\") {\n      const editorHeight = editor.getLayoutInfo().height;\n      const lineHeight = this.getConfiguration().fontInfo.lineHeight;\n      finalAmount = finalAmount * Math.floor(editorHeight / lineHeight);\n      finalUnit = \"line\";\n    }\n\n    if (finalUnit === \"line\") {\n      pos.lineNumber += finalAmount;\n    }\n\n    return toCmPos(pos);\n  }\n\n  findMatchingBracket(pos) {\n    const mPos = toMonacoPos(pos);\n    const model = this.editor.getModel();\n    let res;\n    // for monaco versions >= 0.28.0\n    if (model.bracketPairs) {\n      res = model.bracketPairs.matchBracket(mPos);\n    } else {\n      res = model.matchBracket?.(mPos);\n    }\n\n    if (!res || !(res.length === 2)) {\n      return {\n        to: null,\n      };\n    }\n\n    return {\n      to: toCmPos(res[1].getStartPosition()),\n    };\n  }\n\n  findFirstNonWhiteSpaceCharacter(line) {\n    return this.editor.getModel().getLineFirstNonWhitespaceColumn(line + 1) - 1;\n  }\n\n  scrollTo(x, y) {\n    if (!x && !y) {\n      return;\n    }\n    if (!x) {\n      if (y < 0) {\n        y = this.editor.getPosition().lineNumber - y;\n      }\n      this.editor.setScrollTop(this.editor.getTopForLineNumber(y + 1));\n    }\n  }\n\n  moveCurrentLineTo(viewPosition) {\n    const { editor } = this;\n    const pos = editor.getPosition();\n    const range = Range.fromPositions(pos, pos);\n\n    switch (viewPosition) {\n      case \"top\":\n        editor.revealRangeAtTop(range);\n        return;\n      case \"center\":\n        editor.revealRangeInCenter(range);\n        return;\n      case \"bottom\":\n        // private api. no other way\n        editor._revealRange?.(range, VerticalRevealType.Bottom);\n        return;\n    }\n  }\n\n  getSearchCursor(query, pos) {\n    let matchCase = false;\n    let isRegex = false;\n\n    if (query instanceof RegExp && !query.global) {\n      matchCase = !query.ignoreCase;\n      query = query.source;\n      isRegex = true;\n    }\n\n    if (pos.ch == undefined) pos.ch = Number.MAX_VALUE;\n\n    const monacoPos = toMonacoPos(pos);\n    const context = this;\n    const { editor } = this;\n    let lastSearch = null;\n    const model = editor.getModel();\n    const matches = model.findMatches(query, false, isRegex, matchCase) || [];\n\n    return {\n      getMatches() {\n        return matches;\n      },\n      findNext() {\n        return this.find(false);\n      },\n      findPrevious() {\n        return this.find(true);\n      },\n      jumpTo(index) {\n        if (!matches || !matches.length) {\n          return false;\n        }\n        var match = matches[index];\n        lastSearch = match.range;\n        context.highlightRanges([lastSearch], \"currentFindMatch\");\n        context.highlightRanges(\n          matches.map((m) => m.range).filter((r) => !r.equalsRange(lastSearch)),\n        );\n\n        return lastSearch;\n      },\n      find(back) {\n        if (!matches || !matches.length) {\n          return false;\n        }\n\n        let match;\n\n        if (back) {\n          const pos = lastSearch ? lastSearch.getStartPosition() : monacoPos;\n          match = model.findPreviousMatch(query, pos, isRegex, matchCase);\n\n          if (!match || !match.range.getStartPosition().isBeforeOrEqual(pos)) {\n            return false;\n          }\n        } else {\n          const pos = lastSearch\n            ? model.getPositionAt(\n                model.getOffsetAt(lastSearch.getEndPosition()) + 1,\n              )\n            : monacoPos;\n          match = model.findNextMatch(query, pos, isRegex, matchCase);\n          if (!match || !pos.isBeforeOrEqual(match.range.getStartPosition())) {\n            return false;\n          }\n        }\n\n        lastSearch = match.range;\n        context.highlightRanges([lastSearch], \"currentFindMatch\");\n        context.highlightRanges(\n          matches.map((m) => m.range).filter((r) => !r.equalsRange(lastSearch)),\n        );\n\n        return lastSearch;\n      },\n      from() {\n        return lastSearch && toCmPos(lastSearch.getStartPosition());\n      },\n      to() {\n        return lastSearch && toCmPos(lastSearch.getEndPosition());\n      },\n      replace(text) {\n        if (lastSearch) {\n          editor.executeEdits(\n            \"vim\",\n            [\n              {\n                range: lastSearch,\n                text,\n                forceMoveMarkers: true,\n              },\n            ],\n            function (edits) {\n              const { endLineNumber, endColumn } = edits[0].range;\n              lastSearch = lastSearch.setEndPosition(endLineNumber, endColumn);\n            },\n          );\n          editor.setPosition(lastSearch.getStartPosition());\n        }\n      },\n    };\n  }\n\n  highlightRanges(ranges, className = \"findMatch\") {\n    const decorationKey = `decoration${className}`;\n    this[decorationKey] = this.editor.deltaDecorations(\n      this[decorationKey] || [],\n      ranges.map((range) => ({\n        range,\n        options: {\n          stickiness:\n            monacoEditor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,\n          zIndex: 13,\n          className,\n          showIfCollapsed: true,\n        },\n      })),\n    );\n\n    return this[decorationKey];\n  }\n\n  addOverlay({ query }, hasBoundary, style) {\n    let matchCase = false;\n    let isRegex = false;\n\n    if (query && query instanceof RegExp && !query.global) {\n      isRegex = true;\n      matchCase = !query.ignoreCase;\n      query = query.source;\n    }\n\n    const match = this.editor\n      .getModel()\n      .findNextMatch(query, this.editor.getPosition(), isRegex, matchCase);\n\n    if (!match || !match.range) {\n      return;\n    }\n\n    this.highlightRanges([match.range]);\n  }\n\n  removeOverlay() {\n    [\"currentFindMatch\", \"findMatch\"].forEach((key) => {\n      this.editor.deltaDecorations(this[`decoration${key}`] || [], []);\n    });\n  }\n\n  scrollIntoView(pos) {\n    if (!pos) {\n      return;\n    }\n    this.editor.revealPosition(toMonacoPos(pos));\n  }\n\n  moveH(units, type) {\n    if (type !== \"char\") {\n      return;\n    }\n    const pos = this.editor.getPosition();\n    this.editor.setPosition(new Position(pos.lineNumber, pos.column + units));\n  }\n\n  scanForBracket(pos, dir, dd, config) {\n    const { bracketRegex } = config;\n    let mPos = toMonacoPos(pos);\n    const model = this.editor.getModel();\n\n    const searchFunc = (\n      dir === -1 ? model.findPreviousMatch : model.findNextMatch\n    ).bind(model);\n    const stack = [];\n    let iterations = 0;\n\n    while (true) {\n      if (iterations > 10) {\n        // Searched too far, give up.\n        return undefined;\n      }\n\n      const match = searchFunc(\n        bracketRegex.source,\n        mPos,\n        true,\n        true,\n        null,\n        true,\n      );\n      const thisBracket = match.matches[0];\n\n      if (match === undefined) {\n        return undefined;\n      }\n\n      const matchingBracket = CMAdapter.matchingBrackets[thisBracket];\n\n      if (matchingBracket && (matchingBracket.charAt(1) === \">\") == dir > 0) {\n        stack.push(thisBracket);\n      } else if (stack.length === 0) {\n        const res = match.range.getStartPosition();\n\n        return {\n          pos: toCmPos(res),\n        };\n      } else {\n        stack.pop();\n      }\n\n      mPos = model.getPositionAt(\n        model.getOffsetAt(match.range.getStartPosition()) + dir,\n      );\n      iterations += 1;\n    }\n  }\n\n  indexFromPos(pos) {\n    return this.editor.getModel().getOffsetAt(toMonacoPos(pos));\n  }\n\n  posFromIndex(offset) {\n    return toCmPos(this.editor.getModel().getPositionAt(offset));\n  }\n\n  indentLine(line, indentRight = true) {\n    const { editor } = this;\n    let cursorConfig;\n    // Monaco >= 0.21.x\n    if (editor._getViewModel) {\n      cursorConfig = editor._getViewModel().cursorConfig;\n    } else {\n      cursorConfig = editor._getCursors().context.config;\n    }\n    const pos = new Position(line + 1, 1);\n    const sel = Selection.fromPositions(pos, pos);\n    // no other way than to use internal apis to preserve the undoStack for a batch of indents\n    editor.executeCommand(\n      \"vim\",\n      new ShiftCommand(sel, {\n        isUnshift: !indentRight,\n        tabSize: cursorConfig.tabSize,\n        indentSize: cursorConfig.indentSize,\n        insertSpaces: cursorConfig.insertSpaces,\n        useTabStops: cursorConfig.useTabStops,\n        autoIndent: cursorConfig.autoIndent,\n      }),\n    );\n  }\n\n  setStatusBar(statusBar) {\n    this.statusBar = statusBar;\n  }\n\n  openDialog(html, callback, options) {\n    if (!this.statusBar) {\n      return;\n    }\n\n    return this.statusBar.setSec(html, callback, options);\n  }\n\n  openNotification(html) {\n    if (!this.statusBar) {\n      return;\n    }\n\n    this.statusBar.showNotification(html);\n  }\n\n  smartIndent() {\n    // Only works if a formatter is added for the current language.\n    // reindentselectedlines does not work here.\n    this.editor.getAction(\"editor.action.formatSelection\").run();\n  }\n\n  moveCursorTo(to) {\n    const newPos = this.editor.getPosition();\n    if (to === \"start\") {\n      newPos.column = 1;\n    } else if (to === \"end\") {\n      newPos.column = this.editor\n        .getModel()\n        .getLineMaxColumn(newPos.lineNumber);\n    }\n    this.editor.setPosition(newPos);\n  }\n\n  execCommand(command) {\n    switch (command) {\n      case \"goLineLeft\":\n        this.moveCursorTo(\"start\");\n        break;\n      case \"goLineRight\":\n        this.moveCursorTo(\"end\");\n        break;\n      case \"indentAuto\":\n        this.smartIndent();\n        break;\n    }\n  }\n}\n\nexport default CMAdapter;\n","// @ts-nocheck\n/**\nMIT License\n\nCopyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n */\nimport CodeMirror from \"../cm_adapter\";\n\nvar Pos = CodeMirror.Pos;\n\nfunction transformCursor(cm, range) {\n  var vim = cm.state.vim;\n  if (!vim || vim.insertMode) return range.head;\n  var head = vim.sel.head;\n  if (!head) return range.head;\n\n  if (vim.visualBlock) {\n    if (range.head.line != head.line) {\n      return;\n    }\n  }\n  if (range.from() == range.anchor && !range.empty()) {\n    if (range.head.line == head.line && range.head.ch != head.ch)\n      return new Pos(range.head.line, range.head.ch - 1);\n  }\n\n  return range.head;\n}\n\nvar defaultKeymap = [\n  // Key to key mapping. This goes first to make it possible to override\n  // existing mappings.\n  { keys: \"<Left>\", type: \"keyToKey\", toKeys: \"h\" },\n  { keys: \"<Right>\", type: \"keyToKey\", toKeys: \"l\" },\n  { keys: \"<Up>\", type: \"keyToKey\", toKeys: \"k\" },\n  { keys: \"<Down>\", type: \"keyToKey\", toKeys: \"j\" },\n  { keys: \"g<Up>\", type: \"keyToKey\", toKeys: \"gk\" },\n  { keys: \"g<Down>\", type: \"keyToKey\", toKeys: \"gj\" },\n  { keys: \"<Space>\", type: \"keyToKey\", toKeys: \"l\" },\n  { keys: \"<BS>\", type: \"keyToKey\", toKeys: \"h\", context: \"normal\" },\n  { keys: \"<Del>\", type: \"keyToKey\", toKeys: \"x\", context: \"normal\" },\n  { keys: \"<C-Space>\", type: \"keyToKey\", toKeys: \"W\" },\n  { keys: \"<C-BS>\", type: \"keyToKey\", toKeys: \"B\", context: \"normal\" },\n  { keys: \"<S-Space>\", type: \"keyToKey\", toKeys: \"w\" },\n  { keys: \"<S-BS>\", type: \"keyToKey\", toKeys: \"b\", context: \"normal\" },\n  { keys: \"<C-n>\", type: \"keyToKey\", toKeys: \"j\" },\n  { keys: \"<C-p>\", type: \"keyToKey\", toKeys: \"k\" },\n  { keys: \"<C-[>\", type: \"keyToKey\", toKeys: \"<Esc>\" },\n  { keys: \"<C-c>\", type: \"keyToKey\", toKeys: \"<Esc>\" },\n  { keys: \"<C-[>\", type: \"keyToKey\", toKeys: \"<Esc>\", context: \"insert\" },\n  { keys: \"<C-c>\", type: \"keyToKey\", toKeys: \"<Esc>\", context: \"insert\" },\n  { keys: \"s\", type: \"keyToKey\", toKeys: \"cl\", context: \"normal\" },\n  { keys: \"s\", type: \"keyToKey\", toKeys: \"c\", context: \"visual\" },\n  { keys: \"S\", type: \"keyToKey\", toKeys: \"cc\", context: \"normal\" },\n  { keys: \"S\", type: \"keyToKey\", toKeys: \"VdO\", context: \"visual\" },\n  { keys: \"<Home>\", type: \"keyToKey\", toKeys: \"0\" },\n  { keys: \"<End>\", type: \"keyToKey\", toKeys: \"$\" },\n  { keys: \"<PageUp>\", type: \"keyToKey\", toKeys: \"<C-b>\" },\n  { keys: \"<PageDown>\", type: \"keyToKey\", toKeys: \"<C-f>\" },\n  { keys: \"<CR>\", type: \"keyToKey\", toKeys: \"j^\", context: \"normal\" },\n  { keys: \"<Ins>\", type: \"keyToKey\", toKeys: \"i\", context: \"normal\" },\n  {\n    keys: \"<Ins>\",\n    type: \"action\",\n    action: \"toggleOverwrite\",\n    context: \"insert\",\n  },\n  // Motions\n  {\n    keys: \"H\",\n    type: \"motion\",\n    motion: \"moveToTopLine\",\n    motionArgs: { linewise: true, toJumplist: true },\n  },\n  {\n    keys: \"M\",\n    type: \"motion\",\n    motion: \"moveToMiddleLine\",\n    motionArgs: { linewise: true, toJumplist: true },\n  },\n  {\n    keys: \"L\",\n    type: \"motion\",\n    motion: \"moveToBottomLine\",\n    motionArgs: { linewise: true, toJumplist: true },\n  },\n  {\n    keys: \"h\",\n    type: \"motion\",\n    motion: \"moveByCharacters\",\n    motionArgs: { forward: false },\n  },\n  {\n    keys: \"l\",\n    type: \"motion\",\n    motion: \"moveByCharacters\",\n    motionArgs: { forward: true },\n  },\n  {\n    keys: \"j\",\n    type: \"motion\",\n    motion: \"moveByLines\",\n    motionArgs: { forward: true, linewise: true },\n  },\n  {\n    keys: \"k\",\n    type: \"motion\",\n    motion: \"moveByLines\",\n    motionArgs: { forward: false, linewise: true },\n  },\n  {\n    keys: \"gj\",\n    type: \"motion\",\n    motion: \"moveByDisplayLines\",\n    motionArgs: { forward: true },\n  },\n  {\n    keys: \"gk\",\n    type: \"motion\",\n    motion: \"moveByDisplayLines\",\n    motionArgs: { forward: false },\n  },\n  {\n    keys: \"w\",\n    type: \"motion\",\n    motion: \"moveByWords\",\n    motionArgs: { forward: true, wordEnd: false },\n  },\n  {\n    keys: \"W\",\n    type: \"motion\",\n    motion: \"moveByWords\",\n    motionArgs: { forward: true, wordEnd: false, bigWord: true },\n  },\n  {\n    keys: \"e\",\n    type: \"motion\",\n    motion: \"moveByWords\",\n    motionArgs: { forward: true, wordEnd: true, inclusive: true },\n  },\n  {\n    keys: \"E\",\n    type: \"motion\",\n    motion: \"moveByWords\",\n    motionArgs: {\n      forward: true,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true,\n    },\n  },\n  {\n    keys: \"b\",\n    type: \"motion\",\n    motion: \"moveByWords\",\n    motionArgs: { forward: false, wordEnd: false },\n  },\n  {\n    keys: \"B\",\n    type: \"motion\",\n    motion: \"moveByWords\",\n    motionArgs: { forward: false, wordEnd: false, bigWord: true },\n  },\n  {\n    keys: \"ge\",\n    type: \"motion\",\n    motion: \"moveByWords\",\n    motionArgs: { forward: false, wordEnd: true, inclusive: true },\n  },\n  {\n    keys: \"gE\",\n    type: \"motion\",\n    motion: \"moveByWords\",\n    motionArgs: {\n      forward: false,\n      wordEnd: true,\n      bigWord: true,\n      inclusive: true,\n    },\n  },\n  {\n    keys: \"{\",\n    type: \"motion\",\n    motion: \"moveByParagraph\",\n    motionArgs: { forward: false, toJumplist: true },\n  },\n  {\n    keys: \"}\",\n    type: \"motion\",\n    motion: \"moveByParagraph\",\n    motionArgs: { forward: true, toJumplist: true },\n  },\n  {\n    keys: \"(\",\n    type: \"motion\",\n    motion: \"moveBySentence\",\n    motionArgs: { forward: false },\n  },\n  {\n    keys: \")\",\n    type: \"motion\",\n    motion: \"moveBySentence\",\n    motionArgs: { forward: true },\n  },\n  {\n    keys: \"<C-f>\",\n    type: \"motion\",\n    motion: \"moveByPage\",\n    motionArgs: { forward: true },\n  },\n  {\n    keys: \"<C-b>\",\n    type: \"motion\",\n    motion: \"moveByPage\",\n    motionArgs: { forward: false },\n  },\n  {\n    keys: \"<C-d>\",\n    type: \"motion\",\n    motion: \"moveByScroll\",\n    motionArgs: { forward: true, explicitRepeat: true },\n  },\n  {\n    keys: \"<C-u>\",\n    type: \"motion\",\n    motion: \"moveByScroll\",\n    motionArgs: { forward: false, explicitRepeat: true },\n  },\n  {\n    keys: \"gg\",\n    type: \"motion\",\n    motion: \"moveToLineOrEdgeOfDocument\",\n    motionArgs: {\n      forward: false,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true,\n    },\n  },\n  {\n    keys: \"G\",\n    type: \"motion\",\n    motion: \"moveToLineOrEdgeOfDocument\",\n    motionArgs: {\n      forward: true,\n      explicitRepeat: true,\n      linewise: true,\n      toJumplist: true,\n    },\n  },\n  { keys: \"g$\", type: \"motion\", motion: \"moveToEndOfDisplayLine\" },\n  { keys: \"g^\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n  { keys: \"g0\", type: \"motion\", motion: \"moveToStartOfDisplayLine\" },\n  { keys: \"0\", type: \"motion\", motion: \"moveToStartOfLine\" },\n  { keys: \"^\", type: \"motion\", motion: \"moveToFirstNonWhiteSpaceCharacter\" },\n  {\n    keys: \"+\",\n    type: \"motion\",\n    motion: \"moveByLines\",\n    motionArgs: { forward: true, toFirstChar: true },\n  },\n  {\n    keys: \"-\",\n    type: \"motion\",\n    motion: \"moveByLines\",\n    motionArgs: { forward: false, toFirstChar: true },\n  },\n  {\n    keys: \"_\",\n    type: \"motion\",\n    motion: \"moveByLines\",\n    motionArgs: { forward: true, toFirstChar: true, repeatOffset: -1 },\n  },\n  {\n    keys: \"$\",\n    type: \"motion\",\n    motion: \"moveToEol\",\n    motionArgs: { inclusive: true },\n  },\n  {\n    keys: \"%\",\n    type: \"motion\",\n    motion: \"moveToMatchedSymbol\",\n    motionArgs: { inclusive: true, toJumplist: true },\n  },\n  {\n    keys: \"f<character>\",\n    type: \"motion\",\n    motion: \"moveToCharacter\",\n    motionArgs: { forward: true, inclusive: true },\n  },\n  {\n    keys: \"F<character>\",\n    type: \"motion\",\n    motion: \"moveToCharacter\",\n    motionArgs: { forward: false },\n  },\n  {\n    keys: \"t<character>\",\n    type: \"motion\",\n    motion: \"moveTillCharacter\",\n    motionArgs: { forward: true, inclusive: true },\n  },\n  {\n    keys: \"T<character>\",\n    type: \"motion\",\n    motion: \"moveTillCharacter\",\n    motionArgs: { forward: false },\n  },\n  {\n    keys: \";\",\n    type: \"motion\",\n    motion: \"repeatLastCharacterSearch\",\n    motionArgs: { forward: true },\n  },\n  {\n    keys: \",\",\n    type: \"motion\",\n    motion: \"repeatLastCharacterSearch\",\n    motionArgs: { forward: false },\n  },\n  {\n    keys: \"'<character>\",\n    type: \"motion\",\n    motion: \"goToMark\",\n    motionArgs: { toJumplist: true, linewise: true },\n  },\n  {\n    keys: \"`<character>\",\n    type: \"motion\",\n    motion: \"goToMark\",\n    motionArgs: { toJumplist: true },\n  },\n  {\n    keys: \"]`\",\n    type: \"motion\",\n    motion: \"jumpToMark\",\n    motionArgs: { forward: true },\n  },\n  {\n    keys: \"[`\",\n    type: \"motion\",\n    motion: \"jumpToMark\",\n    motionArgs: { forward: false },\n  },\n  {\n    keys: \"]'\",\n    type: \"motion\",\n    motion: \"jumpToMark\",\n    motionArgs: { forward: true, linewise: true },\n  },\n  {\n    keys: \"['\",\n    type: \"motion\",\n    motion: \"jumpToMark\",\n    motionArgs: { forward: false, linewise: true },\n  },\n  // the next two aren't motions but must come before more general motion declarations\n  {\n    keys: \"]p\",\n    type: \"action\",\n    action: \"paste\",\n    isEdit: true,\n    actionArgs: { after: true, isEdit: true, matchIndent: true },\n  },\n  {\n    keys: \"[p\",\n    type: \"action\",\n    action: \"paste\",\n    isEdit: true,\n    actionArgs: { after: false, isEdit: true, matchIndent: true },\n  },\n  {\n    keys: \"]<character>\",\n    type: \"motion\",\n    motion: \"moveToSymbol\",\n    motionArgs: { forward: true, toJumplist: true },\n  },\n  {\n    keys: \"[<character>\",\n    type: \"motion\",\n    motion: \"moveToSymbol\",\n    motionArgs: { forward: false, toJumplist: true },\n  },\n  { keys: \"|\", type: \"motion\", motion: \"moveToColumn\" },\n  {\n    keys: \"o\",\n    type: \"motion\",\n    motion: \"moveToOtherHighlightedEnd\",\n    context: \"visual\",\n  },\n  {\n    keys: \"O\",\n    type: \"motion\",\n    motion: \"moveToOtherHighlightedEnd\",\n    motionArgs: { sameLine: true },\n    context: \"visual\",\n  },\n  // Operators\n  { keys: \"d\", type: \"operator\", operator: \"delete\" },\n  { keys: \"y\", type: \"operator\", operator: \"yank\" },\n  { keys: \"c\", type: \"operator\", operator: \"change\" },\n  { keys: \"=\", type: \"operator\", operator: \"indentAuto\" },\n  {\n    keys: \">\",\n    type: \"operator\",\n    operator: \"indent\",\n    operatorArgs: { indentRight: true },\n  },\n  {\n    keys: \"<\",\n    type: \"operator\",\n    operator: \"indent\",\n    operatorArgs: { indentRight: false },\n  },\n  { keys: \"g~\", type: \"operator\", operator: \"changeCase\" },\n  {\n    keys: \"gu\",\n    type: \"operator\",\n    operator: \"changeCase\",\n    operatorArgs: { toLower: true },\n    isEdit: true,\n  },\n  {\n    keys: \"gU\",\n    type: \"operator\",\n    operator: \"changeCase\",\n    operatorArgs: { toLower: false },\n    isEdit: true,\n  },\n  {\n    keys: \"n\",\n    type: \"motion\",\n    motion: \"findNext\",\n    motionArgs: { forward: true, toJumplist: true },\n  },\n  {\n    keys: \"N\",\n    type: \"motion\",\n    motion: \"findNext\",\n    motionArgs: { forward: false, toJumplist: true },\n  },\n  {\n    keys: \"gn\",\n    type: \"motion\",\n    motion: \"findAndSelectNextInclusive\",\n    motionArgs: { forward: true },\n  },\n  {\n    keys: \"gN\",\n    type: \"motion\",\n    motion: \"findAndSelectNextInclusive\",\n    motionArgs: { forward: false },\n  },\n  // Operator-Motion dual commands\n  {\n    keys: \"x\",\n    type: \"operatorMotion\",\n    operator: \"delete\",\n    motion: \"moveByCharacters\",\n    motionArgs: { forward: true },\n    operatorMotionArgs: { visualLine: false },\n  },\n  {\n    keys: \"X\",\n    type: \"operatorMotion\",\n    operator: \"delete\",\n    motion: \"moveByCharacters\",\n    motionArgs: { forward: false },\n    operatorMotionArgs: { visualLine: true },\n  },\n  {\n    keys: \"D\",\n    type: \"operatorMotion\",\n    operator: \"delete\",\n    motion: \"moveToEol\",\n    motionArgs: { inclusive: true },\n    context: \"normal\",\n  },\n  {\n    keys: \"D\",\n    type: \"operator\",\n    operator: \"delete\",\n    operatorArgs: { linewise: true },\n    context: \"visual\",\n  },\n  {\n    keys: \"Y\",\n    type: \"operatorMotion\",\n    operator: \"yank\",\n    motion: \"expandToLine\",\n    motionArgs: { linewise: true },\n    context: \"normal\",\n  },\n  {\n    keys: \"Y\",\n    type: \"operator\",\n    operator: \"yank\",\n    operatorArgs: { linewise: true },\n    context: \"visual\",\n  },\n  {\n    keys: \"C\",\n    type: \"operatorMotion\",\n    operator: \"change\",\n    motion: \"moveToEol\",\n    motionArgs: { inclusive: true },\n    context: \"normal\",\n  },\n  {\n    keys: \"C\",\n    type: \"operator\",\n    operator: \"change\",\n    operatorArgs: { linewise: true },\n    context: \"visual\",\n  },\n  {\n    keys: \"~\",\n    type: \"operatorMotion\",\n    operator: \"changeCase\",\n    motion: \"moveByCharacters\",\n    motionArgs: { forward: true },\n    operatorArgs: { shouldMoveCursor: true },\n    context: \"normal\",\n  },\n  { keys: \"~\", type: \"operator\", operator: \"changeCase\", context: \"visual\" },\n  {\n    keys: \"<C-u>\",\n    type: \"operatorMotion\",\n    operator: \"delete\",\n    motion: \"moveToStartOfLine\",\n    context: \"insert\",\n  },\n  {\n    keys: \"<C-w>\",\n    type: \"operatorMotion\",\n    operator: \"delete\",\n    motion: \"moveByWords\",\n    motionArgs: { forward: false, wordEnd: false },\n    context: \"insert\",\n  },\n  //ignore C-w in normal mode\n  { keys: \"<C-w>\", type: \"idle\", context: \"normal\" },\n  // Actions\n  {\n    keys: \"<C-i>\",\n    type: \"action\",\n    action: \"jumpListWalk\",\n    actionArgs: { forward: true },\n  },\n  {\n    keys: \"<C-o>\",\n    type: \"action\",\n    action: \"jumpListWalk\",\n    actionArgs: { forward: false },\n  },\n  {\n    keys: \"<C-e>\",\n    type: \"action\",\n    action: \"scroll\",\n    actionArgs: { forward: true, linewise: true },\n  },\n  {\n    keys: \"<C-y>\",\n    type: \"action\",\n    action: \"scroll\",\n    actionArgs: { forward: false, linewise: true },\n  },\n  {\n    keys: \"a\",\n    type: \"action\",\n    action: \"enterInsertMode\",\n    isEdit: true,\n    actionArgs: { insertAt: \"charAfter\" },\n    context: \"normal\",\n  },\n  {\n    keys: \"A\",\n    type: \"action\",\n    action: \"enterInsertMode\",\n    isEdit: true,\n    actionArgs: { insertAt: \"eol\" },\n    context: \"normal\",\n  },\n  {\n    keys: \"A\",\n    type: \"action\",\n    action: \"enterInsertMode\",\n    isEdit: true,\n    actionArgs: { insertAt: \"endOfSelectedArea\" },\n    context: \"visual\",\n  },\n  {\n    keys: \"i\",\n    type: \"action\",\n    action: \"enterInsertMode\",\n    isEdit: true,\n    actionArgs: { insertAt: \"inplace\" },\n    context: \"normal\",\n  },\n  {\n    keys: \"gi\",\n    type: \"action\",\n    action: \"enterInsertMode\",\n    isEdit: true,\n    actionArgs: { insertAt: \"lastEdit\" },\n    context: \"normal\",\n  },\n  {\n    keys: \"I\",\n    type: \"action\",\n    action: \"enterInsertMode\",\n    isEdit: true,\n    actionArgs: { insertAt: \"firstNonBlank\" },\n    context: \"normal\",\n  },\n  {\n    keys: \"gI\",\n    type: \"action\",\n    action: \"enterInsertMode\",\n    isEdit: true,\n    actionArgs: { insertAt: \"bol\" },\n    context: \"normal\",\n  },\n  {\n    keys: \"I\",\n    type: \"action\",\n    action: \"enterInsertMode\",\n    isEdit: true,\n    actionArgs: { insertAt: \"startOfSelectedArea\" },\n    context: \"visual\",\n  },\n  {\n    keys: \"o\",\n    type: \"action\",\n    action: \"newLineAndEnterInsertMode\",\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: { after: true },\n    context: \"normal\",\n  },\n  {\n    keys: \"O\",\n    type: \"action\",\n    action: \"newLineAndEnterInsertMode\",\n    isEdit: true,\n    interlaceInsertRepeat: true,\n    actionArgs: { after: false },\n    context: \"normal\",\n  },\n  { keys: \"v\", type: \"action\", action: \"toggleVisualMode\" },\n  {\n    keys: \"V\",\n    type: \"action\",\n    action: \"toggleVisualMode\",\n    actionArgs: { linewise: true },\n  },\n  {\n    keys: \"<C-v>\",\n    type: \"action\",\n    action: \"toggleVisualMode\",\n    actionArgs: { blockwise: true },\n  },\n  {\n    keys: \"<C-q>\",\n    type: \"action\",\n    action: \"toggleVisualMode\",\n    actionArgs: { blockwise: true },\n  },\n  { keys: \"gv\", type: \"action\", action: \"reselectLastSelection\" },\n  { keys: \"J\", type: \"action\", action: \"joinLines\", isEdit: true },\n  {\n    keys: \"gJ\",\n    type: \"action\",\n    action: \"joinLines\",\n    actionArgs: { keepSpaces: true },\n    isEdit: true,\n  },\n  {\n    keys: \"p\",\n    type: \"action\",\n    action: \"paste\",\n    isEdit: true,\n    actionArgs: { after: true, isEdit: true },\n  },\n  {\n    keys: \"P\",\n    type: \"action\",\n    action: \"paste\",\n    isEdit: true,\n    actionArgs: { after: false, isEdit: true },\n  },\n  { keys: \"r<character>\", type: \"action\", action: \"replace\", isEdit: true },\n  { keys: \"@<character>\", type: \"action\", action: \"replayMacro\" },\n  { keys: \"q<character>\", type: \"action\", action: \"enterMacroRecordMode\" },\n  // Handle Replace-mode as a special case of insert mode.\n  {\n    keys: \"R\",\n    type: \"action\",\n    action: \"enterInsertMode\",\n    isEdit: true,\n    actionArgs: { replace: true },\n    context: \"normal\",\n  },\n  {\n    keys: \"R\",\n    type: \"operator\",\n    operator: \"change\",\n    operatorArgs: { linewise: true, fullLine: true },\n    context: \"visual\",\n    exitVisualBlock: true,\n  },\n  { keys: \"u\", type: \"action\", action: \"undo\", context: \"normal\" },\n  {\n    keys: \"u\",\n    type: \"operator\",\n    operator: \"changeCase\",\n    operatorArgs: { toLower: true },\n    context: \"visual\",\n    isEdit: true,\n  },\n  {\n    keys: \"U\",\n    type: \"operator\",\n    operator: \"changeCase\",\n    operatorArgs: { toLower: false },\n    context: \"visual\",\n    isEdit: true,\n  },\n  { keys: \"<C-r>\", type: \"action\", action: \"redo\" },\n  { keys: \"m<character>\", type: \"action\", action: \"setMark\" },\n  { keys: '\"<character>', type: \"action\", action: \"setRegister\" },\n  {\n    keys: \"zz\",\n    type: \"action\",\n    action: \"scrollToCursor\",\n    actionArgs: { position: \"center\" },\n  },\n  {\n    keys: \"z.\",\n    type: \"action\",\n    action: \"scrollToCursor\",\n    actionArgs: { position: \"center\" },\n    motion: \"moveToFirstNonWhiteSpaceCharacter\",\n  },\n  {\n    keys: \"zt\",\n    type: \"action\",\n    action: \"scrollToCursor\",\n    actionArgs: { position: \"top\" },\n  },\n  {\n    keys: \"z<CR>\",\n    type: \"action\",\n    action: \"scrollToCursor\",\n    actionArgs: { position: \"top\" },\n    motion: \"moveToFirstNonWhiteSpaceCharacter\",\n  },\n  {\n    keys: \"z-\",\n    type: \"action\",\n    action: \"scrollToCursor\",\n    actionArgs: { position: \"bottom\" },\n  },\n  {\n    keys: \"zb\",\n    type: \"action\",\n    action: \"scrollToCursor\",\n    actionArgs: { position: \"bottom\" },\n    motion: \"moveToFirstNonWhiteSpaceCharacter\",\n  },\n  { keys: \".\", type: \"action\", action: \"repeatLastEdit\" },\n  {\n    keys: \"<C-a>\",\n    type: \"action\",\n    action: \"incrementNumberToken\",\n    isEdit: true,\n    actionArgs: { increase: true, backtrack: false },\n  },\n  {\n    keys: \"<C-x>\",\n    type: \"action\",\n    action: \"incrementNumberToken\",\n    isEdit: true,\n    actionArgs: { increase: false, backtrack: false },\n  },\n  {\n    keys: \"<C-t>\",\n    type: \"action\",\n    action: \"indent\",\n    actionArgs: { indentRight: true },\n    context: \"insert\",\n  },\n  {\n    keys: \"<C-d>\",\n    type: \"action\",\n    action: \"indent\",\n    actionArgs: { indentRight: false },\n    context: \"insert\",\n  },\n  // Text object motions\n  { keys: \"a<character>\", type: \"motion\", motion: \"textObjectManipulation\" },\n  {\n    keys: \"i<character>\",\n    type: \"motion\",\n    motion: \"textObjectManipulation\",\n    motionArgs: { textObjectInner: true },\n  },\n  // Search\n  {\n    keys: \"/\",\n    type: \"search\",\n    searchArgs: { forward: true, querySrc: \"prompt\", toJumplist: true },\n  },\n  {\n    keys: \"?\",\n    type: \"search\",\n    searchArgs: { forward: false, querySrc: \"prompt\", toJumplist: true },\n  },\n  {\n    keys: \"*\",\n    type: \"search\",\n    searchArgs: {\n      forward: true,\n      querySrc: \"wordUnderCursor\",\n      wholeWordOnly: true,\n      toJumplist: true,\n    },\n  },\n  {\n    keys: \"#\",\n    type: \"search\",\n    searchArgs: {\n      forward: false,\n      querySrc: \"wordUnderCursor\",\n      wholeWordOnly: true,\n      toJumplist: true,\n    },\n  },\n  {\n    keys: \"g*\",\n    type: \"search\",\n    searchArgs: {\n      forward: true,\n      querySrc: \"wordUnderCursor\",\n      toJumplist: true,\n    },\n  },\n  {\n    keys: \"g#\",\n    type: \"search\",\n    searchArgs: {\n      forward: false,\n      querySrc: \"wordUnderCursor\",\n      toJumplist: true,\n    },\n  },\n  // Ex command\n  { keys: \":\", type: \"ex\" },\n];\nvar defaultKeymapLength = defaultKeymap.length;\n\n/**\n * Ex commands\n * Care must be taken when adding to the default Ex command map. For any\n * pair of commands that have a shared prefix, at least one of their\n * shortNames must not match the prefix of the other command.\n */\nvar defaultExCommandMap = [\n  { name: \"colorscheme\", shortName: \"colo\" },\n  { name: \"map\" },\n  { name: \"imap\", shortName: \"im\" },\n  { name: \"nmap\", shortName: \"nm\" },\n  { name: \"vmap\", shortName: \"vm\" },\n  { name: \"unmap\" },\n  { name: \"write\", shortName: \"w\" },\n  { name: \"undo\", shortName: \"u\" },\n  { name: \"redo\", shortName: \"red\" },\n  { name: \"set\", shortName: \"se\" },\n  { name: \"setlocal\", shortName: \"setl\" },\n  { name: \"setglobal\", shortName: \"setg\" },\n  { name: \"sort\", shortName: \"sor\" },\n  { name: \"substitute\", shortName: \"s\", possiblyAsync: true },\n  { name: \"nohlsearch\", shortName: \"noh\" },\n  { name: \"yank\", shortName: \"y\" },\n  { name: \"delmarks\", shortName: \"delm\" },\n  { name: \"registers\", shortName: \"reg\", excludeFromCommandHistory: true },\n  { name: \"vglobal\", shortName: \"v\" },\n  { name: \"global\", shortName: \"g\" },\n];\n\nvar Vim = function () {\n  function enterVimMode(cm) {\n    cm.setOption(\"disableInput\", true);\n    cm.setOption(\"showCursorWhenSelecting\", false);\n    CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n    cm.on(\"cursorActivity\", onCursorActivity);\n    maybeInitVimState(cm);\n    // CodeMirror.on(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.enterVimMode();\n  }\n\n  function leaveVimMode(cm) {\n    cm.setOption(\"disableInput\", false);\n    cm.off(\"cursorActivity\", onCursorActivity);\n    // CodeMirror.off(cm.getInputField(), 'paste', getOnPasteFn(cm));\n    cm.state.vim = null;\n    if (highlightTimeout) clearTimeout(highlightTimeout);\n    cm.leaveVimMode();\n  }\n\n  function detachVimMap(cm, next) {\n    cm.attached = false;\n    if (this == CodeMirror.keyMap.vim) {\n      cm.options.$customCursor = null;\n      // CodeMirror.rmClass(cm.getWrapperElement(), \"cm-fat-cursor\");\n    }\n\n    if (!next || next.attach != attachVimMap) leaveVimMode(cm);\n  }\n  function attachVimMap(cm, prev) {\n    if (this == CodeMirror.keyMap.vim) {\n      cm.attached = true;\n      if (cm.curOp) cm.curOp.selectionChanged = true;\n      cm.options.$customCursor = transformCursor;\n    }\n\n    if (!prev || prev.attach != attachVimMap) enterVimMode(cm);\n  }\n\n  // Deprecated, simply setting the keymap works again.\n  CodeMirror.defineOption(\"vimMode\", false, function (cm, val, prev) {\n    if (val && cm.getOption(\"keyMap\") != \"vim\") cm.setOption(\"keyMap\", \"vim\");\n    else if (\n      !val &&\n      prev != CodeMirror.Init &&\n      /^vim/.test(cm.getOption(\"keyMap\"))\n    )\n      cm.setOption(\"keyMap\", \"default\");\n  });\n\n  function cmKey(key, cm) {\n    if (!cm) {\n      return undefined;\n    }\n    if (this[key]) {\n      return this[key];\n    }\n    var vimKey = cmKeyToVimKey(key);\n    if (!vimKey) {\n      return false;\n    }\n    var cmd = vimApi.findKey(cm, vimKey);\n    if (typeof cmd == \"function\") {\n      CodeMirror.signal(cm, \"vim-keypress\", vimKey);\n    }\n    return cmd;\n  }\n\n  var modifiers = {\n    Shift: \"S\",\n    Ctrl: \"C\",\n    Alt: \"A\",\n    Cmd: \"D\",\n    Mod: \"A\",\n    CapsLock: \"\",\n  };\n  var specialKeys = {\n    Enter: \"CR\",\n    Backspace: \"BS\",\n    Delete: \"Del\",\n    Insert: \"Ins\",\n  };\n  function cmKeyToVimKey(key) {\n    if (key.charAt(0) == \"'\") {\n      // Keypress character binding of format \"'a'\"\n      return key.charAt(1);\n    }\n    if (key === \"AltGraph\") {\n      return false;\n    }\n    var pieces = key.split(/-(?!$)/);\n    var lastPiece = pieces[pieces.length - 1];\n    if (pieces.length == 1 && pieces[0].length == 1) {\n      // No-modifier bindings use literal character bindings above. Skip.\n      return false;\n    } else if (\n      pieces.length == 2 &&\n      pieces[0] == \"Shift\" &&\n      lastPiece.length == 1\n    ) {\n      // Ignore Shift+char bindings as they should be handled by literal character.\n      return false;\n    }\n    var hasCharacter = false;\n    for (var i = 0; i < pieces.length; i++) {\n      var piece = pieces[i];\n      if (piece in modifiers) {\n        pieces[i] = modifiers[piece];\n      } else {\n        hasCharacter = true;\n      }\n      if (piece in specialKeys) {\n        pieces[i] = specialKeys[piece];\n      }\n    }\n    if (!hasCharacter) {\n      // Vim does not support modifier only keys.\n      return false;\n    }\n    // TODO: Current bindings expect the character to be lower case, but\n    // it looks like vim key notation uses upper case.\n    if (isUpperCase(lastPiece)) {\n      pieces[pieces.length - 1] = lastPiece.toLowerCase();\n    }\n    return \"<\" + pieces.join(\"-\") + \">\";\n  }\n\n  // function getOnPasteFn(cm) {\n  //   var vim = cm.state.vim;\n  //   if (!vim.onPasteFn) {\n  //     vim.onPasteFn = function () {\n  //       if (!vim.insertMode) {\n  //         cm.setCursor(offsetCursor(cm.getCursor(), 0, 1));\n  //         actions.enterInsertMode(cm, {}, vim);\n  //       }\n  //     };\n  //   }\n  //   return vim.onPasteFn;\n  // }\n\n  var numberRegex = /[\\d]/;\n  var wordCharTest = [\n      CodeMirror.isWordChar,\n      function (ch) {\n        return ch && !CodeMirror.isWordChar(ch) && !/\\s/.test(ch);\n      },\n    ],\n    bigWordCharTest = [\n      function (ch) {\n        return /\\S/.test(ch);\n      },\n    ];\n  function makeKeyRange(start, size) {\n    var keys = [];\n    for (var i = start; i < start + size; i++) {\n      keys.push(String.fromCharCode(i));\n    }\n    return keys;\n  }\n  var upperCaseAlphabet = makeKeyRange(65, 26);\n  var lowerCaseAlphabet = makeKeyRange(97, 26);\n  var numbers = makeKeyRange(48, 10);\n  var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, [\n    \"<\",\n    \">\",\n  ]);\n  var validRegisters = [].concat(\n    upperCaseAlphabet,\n    lowerCaseAlphabet,\n    numbers,\n    [\"-\", '\"', \".\", \":\", \"_\", \"/\"]\n  );\n  var upperCaseChars;\n  try {\n    upperCaseChars = new RegExp(\"^[\\\\p{Lu}]$\", \"u\");\n  } catch (_) {\n    upperCaseChars = /^[A-Z]$/;\n  }\n\n  function isLine(cm, line) {\n    return line >= cm.firstLine() && line <= cm.lastLine();\n  }\n  function isLowerCase(k) {\n    return /^[a-z]$/.test(k);\n  }\n  function isMatchableSymbol(k) {\n    return \"()[]{}\".indexOf(k) != -1;\n  }\n  function isNumber(k) {\n    return numberRegex.test(k);\n  }\n  function isUpperCase(k) {\n    return upperCaseChars.test(k);\n  }\n  function isWhiteSpaceString(k) {\n    return /^\\s*$/.test(k);\n  }\n  function isEndOfSentenceSymbol(k) {\n    return \".?!\".indexOf(k) != -1;\n  }\n  function inArray(val, arr) {\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i] == val) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  var options = {};\n  function defineOption(name, defaultValue, type, aliases, callback) {\n    if (defaultValue === undefined && !callback) {\n      throw Error(\"defaultValue is required unless callback is provided\");\n    }\n    if (!type) {\n      type = \"string\";\n    }\n    options[name] = {\n      type: type,\n      defaultValue: defaultValue,\n      callback: callback,\n    };\n    if (aliases) {\n      for (var i = 0; i < aliases.length; i++) {\n        options[aliases[i]] = options[name];\n      }\n    }\n    if (defaultValue) {\n      setOption(name, defaultValue);\n    }\n  }\n\n  function setOption(name, value, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error(\"Unknown option: \" + name);\n    }\n    if (option.type == \"boolean\") {\n      if (value && value !== true) {\n        return new Error(\"Invalid argument: \" + name + \"=\" + value);\n      } else if (value !== false) {\n        // Boolean options are set to true if value is not defined.\n        value = true;\n      }\n    }\n    if (option.callback) {\n      if (scope !== \"local\") {\n        option.callback(value, undefined);\n      }\n      if (scope !== \"global\" && cm) {\n        option.callback(value, cm);\n      }\n    } else {\n      if (scope !== \"local\") {\n        option.value = option.type == \"boolean\" ? !!value : value;\n      }\n      if (scope !== \"global\" && cm) {\n        cm.state.vim.options[name] = { value: value };\n      }\n    }\n  }\n\n  function getOption(name, cm, cfg) {\n    var option = options[name];\n    cfg = cfg || {};\n    var scope = cfg.scope;\n    if (!option) {\n      return new Error(\"Unknown option: \" + name);\n    }\n    if (option.callback) {\n      var local = cm && option.callback(undefined, cm);\n      if (scope !== \"global\" && local !== undefined) {\n        return local;\n      }\n      if (scope !== \"local\") {\n        return option.callback();\n      }\n      return;\n    } else {\n      var local = scope !== \"global\" && cm && cm.state.vim.options[name];\n      return (local || (scope !== \"local\" && option) || {}).value;\n    }\n  }\n\n  defineOption(\"filetype\", undefined, \"string\", [\"ft\"], function (name, cm) {\n    // Option is local. Do nothing for global.\n    if (cm === undefined) {\n      return;\n    }\n    // The 'filetype' option proxies to the CodeMirror 'mode' option.\n    if (name === undefined) {\n      var mode = cm.getOption(\"mode\");\n      return mode == \"null\" ? \"\" : mode;\n    } else {\n      var mode = name == \"\" ? \"null\" : name;\n      cm.setOption(\"mode\", mode);\n    }\n  });\n\n  var createCircularJumpList = function () {\n    var size = 100;\n    var pointer = -1;\n    var head = 0;\n    var tail = 0;\n    var buffer = new Array(size);\n    function add(cm, oldCur, newCur) {\n      var current = pointer % size;\n      var curMark = buffer[current];\n      function useNextSlot(cursor) {\n        var next = ++pointer % size;\n        var trashMark = buffer[next];\n        if (trashMark) {\n          trashMark.clear();\n        }\n        buffer[next] = cm.setBookmark(cursor);\n      }\n      if (curMark) {\n        var markPos = curMark.find();\n        // avoid recording redundant cursor position\n        if (markPos && !cursorEqual(markPos, oldCur)) {\n          useNextSlot(oldCur);\n        }\n      } else {\n        useNextSlot(oldCur);\n      }\n      useNextSlot(newCur);\n      head = pointer;\n      tail = pointer - size + 1;\n      if (tail < 0) {\n        tail = 0;\n      }\n    }\n    function move(cm, offset) {\n      pointer += offset;\n      if (pointer > head) {\n        pointer = head;\n      } else if (pointer < tail) {\n        pointer = tail;\n      }\n      var mark = buffer[(size + pointer) % size];\n      // skip marks that are temporarily removed from text buffer\n      if (mark && !mark.find()) {\n        var inc = offset > 0 ? 1 : -1;\n        var newCur;\n        var oldCur = cm.getCursor();\n        do {\n          pointer += inc;\n          mark = buffer[(size + pointer) % size];\n          // skip marks that are the same as current position\n          if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) {\n            break;\n          }\n        } while (pointer < head && pointer > tail);\n      }\n      return mark;\n    }\n    function find(cm, offset) {\n      var oldPointer = pointer;\n      var mark = move(cm, offset);\n      pointer = oldPointer;\n      return mark && mark.find();\n    }\n    return {\n      cachedCursor: undefined, //used for # and * jumps\n      add: add,\n      find: find,\n      move: move,\n    };\n  };\n\n  // Returns an object to track the changes associated insert mode.  It\n  // clones the object that is passed in, or creates an empty object one if\n  // none is provided.\n  var createInsertModeChanges = function (c) {\n    if (c) {\n      // Copy construction\n      return {\n        changes: c.changes,\n        expectCursorActivityForChange: c.expectCursorActivityForChange,\n      };\n    }\n    return {\n      // Change list\n      changes: [],\n      // Set to true on change, false on cursorActivity.\n      expectCursorActivityForChange: false,\n    };\n  };\n\n  function MacroModeState() {\n    this.latestRegister = undefined;\n    this.isPlaying = false;\n    this.isRecording = false;\n    this.replaySearchQueries = [];\n    this.onRecordingDone = undefined;\n    this.lastInsertModeChanges = createInsertModeChanges();\n  }\n  MacroModeState.prototype = {\n    exitMacroRecordMode: function () {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.onRecordingDone) {\n        macroModeState.onRecordingDone(); // close dialog\n      }\n      macroModeState.onRecordingDone = undefined;\n      macroModeState.isRecording = false;\n    },\n    enterMacroRecordMode: function (cm, registerName) {\n      var register =\n        vimGlobalState.registerController.getRegister(registerName);\n      if (register) {\n        register.clear();\n        this.latestRegister = registerName;\n        if (cm.openDialog) {\n          this.onRecordingDone = cm.openDialog(\n            document.createTextNode(\"(recording)[\" + registerName + \"]\"),\n            null,\n            { bottom: true }\n          );\n        }\n        this.isRecording = true;\n      }\n    },\n  };\n\n  function maybeInitVimState(cm) {\n    if (!cm.state.vim) {\n      // Store instance state in the CodeMirror object.\n      cm.state.vim = {\n        inputState: new InputState(),\n        // Vim's input state that triggered the last edit, used to repeat\n        // motions and operators with '.'.\n        lastEditInputState: undefined,\n        // Vim's action command before the last edit, used to repeat actions\n        // with '.' and insert mode repeat.\n        lastEditActionCommand: undefined,\n        // When using jk for navigation, if you move from a longer line to a\n        // shorter line, the cursor may clip to the end of the shorter line.\n        // If j is pressed again and cursor goes to the next line, the\n        // cursor should go back to its horizontal position on the longer\n        // line if it can. This is to keep track of the horizontal position.\n        lastHPos: -1,\n        // Doing the same with screen-position for gj/gk\n        lastHSPos: -1,\n        // The last motion command run. Cleared if a non-motion command gets\n        // executed in between.\n        lastMotion: null,\n        marks: {},\n        insertMode: false,\n        // Repeat count for changes made in insert mode, triggered by key\n        // sequences like 3,i. Only exists when insertMode is true.\n        insertModeRepeat: undefined,\n        visualMode: false,\n        // If we are in visual line mode. No effect if visualMode is false.\n        visualLine: false,\n        visualBlock: false,\n        lastSelection: null,\n        lastPastedText: null,\n        sel: {},\n        // Buffer-local/window-local values of vim options.\n        options: {},\n      };\n    }\n    return cm.state.vim;\n  }\n  var vimGlobalState;\n  function resetVimGlobalState() {\n    vimGlobalState = {\n      // The current search query.\n      searchQuery: null,\n      // Whether we are searching backwards.\n      searchIsReversed: false,\n      // Replace part of the last substituted pattern\n      lastSubstituteReplacePart: undefined,\n      jumpList: createCircularJumpList(),\n      macroModeState: new MacroModeState(),\n      // Recording latest f, t, F or T motion command.\n      lastCharacterSearch: {\n        increment: 0,\n        forward: true,\n        selectedCharacter: \"\",\n      },\n      registerController: new RegisterController({}),\n      // search history buffer\n      searchHistoryController: new HistoryController(),\n      // ex Command history buffer\n      exCommandHistoryController: new HistoryController(),\n    };\n    for (var optionName in options) {\n      var option = options[optionName];\n      option.value = option.defaultValue;\n    }\n  }\n\n  var lastInsertModeKeyTimer;\n  var vimApi = {\n    buildKeyMap: function () {\n      // TODO: Convert keymap into dictionary format for fast lookup.\n    },\n    // Testing hook, though it might be useful to expose the register\n    // controller anyway.\n    getRegisterController: function () {\n      return vimGlobalState.registerController;\n    },\n    // Testing hook.\n    resetVimGlobalState_: resetVimGlobalState,\n\n    // Testing hook.\n    getVimGlobalState_: function () {\n      return vimGlobalState;\n    },\n\n    // Testing hook.\n    maybeInitVimState_: maybeInitVimState,\n\n    suppressErrorLogging: false,\n\n    InsertModeKey: InsertModeKey,\n    map: function (lhs, rhs, ctx) {\n      // Add user defined key bindings.\n      exCommandDispatcher.map(lhs, rhs, ctx);\n    },\n    unmap: function (lhs, ctx) {\n      return exCommandDispatcher.unmap(lhs, ctx);\n    },\n    // Non-recursive map function.\n    // NOTE: This will not create mappings to key maps that aren't present\n    // in the default key map. See TODO at bottom of function.\n    noremap: function (lhs, rhs, ctx) {\n      function toCtxArray(ctx) {\n        return ctx ? [ctx] : [\"normal\", \"insert\", \"visual\"];\n      }\n      var ctxsToMap = toCtxArray(ctx);\n      // Look through all actual defaults to find a map candidate.\n      var actualLength = defaultKeymap.length,\n        origLength = defaultKeymapLength;\n      for (\n        var i = actualLength - origLength;\n        i < actualLength && ctxsToMap.length;\n        i++\n      ) {\n        var mapping = defaultKeymap[i];\n        // Omit mappings that operate in the wrong context(s) and those of invalid type.\n        if (\n          mapping.keys == rhs &&\n          (!ctx || !mapping.context || mapping.context === ctx) &&\n          mapping.type.substr(0, 2) !== \"ex\" &&\n          mapping.type.substr(0, 3) !== \"key\"\n        ) {\n          // Make a shallow copy of the original keymap entry.\n          var newMapping = {};\n          for (var key in mapping) {\n            newMapping[key] = mapping[key];\n          }\n          // Modify it point to the new mapping with the proper context.\n          newMapping.keys = lhs;\n          if (ctx && !newMapping.context) {\n            newMapping.context = ctx;\n          }\n          // Add it to the keymap with a higher priority than the original.\n          this._mapCommand(newMapping);\n          // Record the mapped contexts as complete.\n          var mappedCtxs = toCtxArray(mapping.context);\n          ctxsToMap = ctxsToMap.filter(function (el) {\n            return mappedCtxs.indexOf(el) === -1;\n          });\n        }\n      }\n      // TODO: Create non-recursive keyToKey mappings for the unmapped contexts once those exist.\n    },\n    // Remove all user-defined mappings for the provided context.\n    mapclear: function (ctx) {\n      // Partition the existing keymap into user-defined and true defaults.\n      var actualLength = defaultKeymap.length,\n        origLength = defaultKeymapLength;\n      var userKeymap = defaultKeymap.slice(0, actualLength - origLength);\n      defaultKeymap = defaultKeymap.slice(actualLength - origLength);\n      if (ctx) {\n        // If a specific context is being cleared, we need to keep mappings\n        // from all other contexts.\n        for (var i = userKeymap.length - 1; i >= 0; i--) {\n          var mapping = userKeymap[i];\n          if (ctx !== mapping.context) {\n            if (mapping.context) {\n              this._mapCommand(mapping);\n            } else {\n              // `mapping` applies to all contexts so create keymap copies\n              // for each context except the one being cleared.\n              var contexts = [\"normal\", \"insert\", \"visual\"];\n              for (var j in contexts) {\n                if (contexts[j] !== ctx) {\n                  var newMapping = {};\n                  for (var key in mapping) {\n                    newMapping[key] = mapping[key];\n                  }\n                  newMapping.context = contexts[j];\n                  this._mapCommand(newMapping);\n                }\n              }\n            }\n          }\n        }\n      }\n    },\n    // TODO: Expose setOption and getOption as instance methods. Need to decide how to namespace\n    // them, or somehow make them work with the existing CodeMirror setOption/getOption API.\n    setOption: setOption,\n    getOption: getOption,\n    defineOption: defineOption,\n    defineEx: function (name, prefix, func) {\n      if (!prefix) {\n        prefix = name;\n      } else if (name.indexOf(prefix) !== 0) {\n        throw new Error(\n          '(Vim.defineEx) \"' +\n            prefix +\n            '\" is not a prefix of \"' +\n            name +\n            '\", command not registered'\n        );\n      }\n      exCommands[name] = func;\n      exCommandDispatcher.commandMap_[prefix] = {\n        name: name,\n        shortName: prefix,\n        type: \"api\",\n      };\n    },\n    handleKey: function (cm, key, origin) {\n      var command = this.findKey(cm, key, origin);\n      if (typeof command === \"function\") {\n        return command();\n      }\n    },\n    /**\n     * This is the outermost function called by CodeMirror, after keys have\n     * been mapped to their Vim equivalents.\n     *\n     * Finds a command based on the key (and cached keys if there is a\n     * multi-key sequence). Returns `undefined` if no key is matched, a noop\n     * function if a partial match is found (multi-key), and a function to\n     * execute the bound command if a a key is matched. The function always\n     * returns true.\n     */\n    findKey: function (cm, key, origin) {\n      var vim = maybeInitVimState(cm);\n      function handleMacroRecording() {\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          if (key == \"q\") {\n            macroModeState.exitMacroRecordMode();\n            clearInputState(cm);\n            return true;\n          }\n          if (origin != \"mapping\") {\n            logKey(macroModeState, key);\n          }\n        }\n      }\n      function handleEsc() {\n        if (key == \"<Esc>\") {\n          if (vim.visualMode) {\n            // Get back to normal mode.\n            exitVisualMode(cm);\n          } else if (vim.insertMode) {\n            // Get back to normal mode.\n            exitInsertMode(cm);\n          } else {\n            // We're already in normal mode. Let '<Esc>' be handled normally.\n            return;\n          }\n          clearInputState(cm);\n          return true;\n        }\n      }\n      function doKeyToKey(keys) {\n        // TODO: prevent infinite recursion.\n        var match;\n        while (keys) {\n          // Pull off one command key, which is either a single character\n          // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n          match = /<\\w+-.+?>|<\\w+>|./.exec(keys);\n          key = match[0];\n          keys = keys.substring(match.index + key.length);\n          vimApi.handleKey(cm, key, \"mapping\");\n        }\n      }\n\n      function handleKeyInsertMode() {\n        if (handleEsc()) {\n          return true;\n        }\n        var keys = (vim.inputState.keyBuffer = vim.inputState.keyBuffer + key);\n        var keysAreChars = key.length == 1;\n        var match = commandDispatcher.matchCommand(\n          keys,\n          defaultKeymap,\n          vim.inputState,\n          \"insert\"\n        );\n        // Need to check all key substrings in insert mode.\n        while (keys.length > 1 && match.type != \"full\") {\n          var keys = (vim.inputState.keyBuffer = keys.slice(1));\n          var thisMatch = commandDispatcher.matchCommand(\n            keys,\n            defaultKeymap,\n            vim.inputState,\n            \"insert\"\n          );\n          if (thisMatch.type != \"none\") {\n            match = thisMatch;\n          }\n        }\n        if (match.type == \"none\") {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == \"partial\") {\n          if (lastInsertModeKeyTimer) {\n            window.clearTimeout(lastInsertModeKeyTimer);\n          }\n          lastInsertModeKeyTimer = window.setTimeout(function () {\n            if (vim.insertMode && vim.inputState.keyBuffer) {\n              clearInputState(cm);\n            }\n          }, getOption(\"insertModeEscKeysTimeout\"));\n          return !keysAreChars;\n        }\n\n        if (lastInsertModeKeyTimer) {\n          window.clearTimeout(lastInsertModeKeyTimer);\n        }\n        if (keysAreChars) {\n          var selections = cm.listSelections();\n          for (var i = 0; i < selections.length; i++) {\n            var here = selections[i].head;\n            cm.replaceRange(\n              \"\",\n              offsetCursor(here, 0, -(keys.length - 1)),\n              here,\n              \"+input\"\n            );\n          }\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();\n        }\n        clearInputState(cm);\n        return match.command;\n      }\n\n      function handleKeyNonInsertMode() {\n        if (handleMacroRecording() || handleEsc()) {\n          return true;\n        }\n\n        var keys = (vim.inputState.keyBuffer = vim.inputState.keyBuffer + key);\n        if (/^[1-9]\\d*$/.test(keys)) {\n          return true;\n        }\n\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (!keysMatcher) {\n          clearInputState(cm);\n          return false;\n        }\n        var context = vim.visualMode ? \"visual\" : \"normal\";\n        var mainKey = keysMatcher[2] || keysMatcher[1];\n        if (\n          vim.inputState.operatorShortcut &&\n          vim.inputState.operatorShortcut.slice(-1) == mainKey\n        ) {\n          // multikey operators act linewise by repeating only the last character\n          mainKey = vim.inputState.operatorShortcut;\n        }\n        var match = commandDispatcher.matchCommand(\n          mainKey,\n          defaultKeymap,\n          vim.inputState,\n          context\n        );\n        if (match.type == \"none\") {\n          clearInputState(cm);\n          return false;\n        } else if (match.type == \"partial\") {\n          return true;\n        }\n\n        vim.inputState.keyBuffer = \"\";\n        var keysMatcher = /^(\\d*)(.*)$/.exec(keys);\n        if (keysMatcher[1] && keysMatcher[1] != \"0\") {\n          vim.inputState.pushRepeatDigit(keysMatcher[1]);\n        }\n        return match.command;\n      }\n\n      var command;\n      if (vim.insertMode) {\n        command = handleKeyInsertMode();\n      } else {\n        command = handleKeyNonInsertMode();\n      }\n      if (command === false) {\n        return !vim.insertMode && key.length === 1\n          ? function () {\n              return true;\n            }\n          : undefined;\n      } else if (command === true) {\n        // TODO: Look into using CodeMirror's multi-key handling.\n        // Return no-op since we are caching the key. Counts as handled, but\n        // don't want act on it just yet.\n        return function () {\n          return true;\n        };\n      } else {\n        return function () {\n          return cm.operation(function () {\n            cm.curOp.isVimOp = true;\n            try {\n              if (command.type == \"keyToKey\") {\n                doKeyToKey(command.toKeys);\n              } else {\n                commandDispatcher.processCommand(cm, vim, command);\n              }\n            } catch (e) {\n              // clear VIM state in case it's in a bad state.\n              cm.state.vim = undefined;\n              maybeInitVimState(cm);\n              if (!vimApi.suppressErrorLogging) {\n                console[\"log\"](e);\n              }\n              throw e;\n            }\n            return true;\n          });\n        };\n      }\n    },\n    handleEx: function (cm, input) {\n      exCommandDispatcher.processCommand(cm, input);\n    },\n\n    defineMotion: defineMotion,\n    defineAction: defineAction,\n    defineOperator: defineOperator,\n    mapCommand: mapCommand,\n    _mapCommand: _mapCommand,\n\n    defineRegister: defineRegister,\n\n    exitVisualMode: exitVisualMode,\n    exitInsertMode: exitInsertMode,\n  };\n\n  // Represents the current input state.\n  function InputState() {\n    this.prefixRepeat = [];\n    this.motionRepeat = [];\n\n    this.operator = null;\n    this.operatorArgs = null;\n    this.motion = null;\n    this.motionArgs = null;\n    this.keyBuffer = []; // For matching multi-key commands.\n    this.registerName = null; // Defaults to the unnamed register.\n  }\n  InputState.prototype.pushRepeatDigit = function (n) {\n    if (!this.operator) {\n      this.prefixRepeat = this.prefixRepeat.concat(n);\n    } else {\n      this.motionRepeat = this.motionRepeat.concat(n);\n    }\n  };\n  InputState.prototype.getRepeat = function () {\n    var repeat = 0;\n    if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {\n      repeat = 1;\n      if (this.prefixRepeat.length > 0) {\n        repeat *= parseInt(this.prefixRepeat.join(\"\"), 10);\n      }\n      if (this.motionRepeat.length > 0) {\n        repeat *= parseInt(this.motionRepeat.join(\"\"), 10);\n      }\n    }\n    return repeat;\n  };\n\n  function clearInputState(cm, reason) {\n    cm.state.vim.inputState = new InputState();\n    CodeMirror.signal(cm, \"vim-command-done\", reason);\n  }\n\n  /*\n   * Register stores information about copy and paste registers.  Besides\n   * text, a register must store whether it is linewise (i.e., when it is\n   * pasted, should it insert itself into a new line, or should the text be\n   * inserted at the cursor position.)\n   */\n  function Register(text, linewise, blockwise) {\n    this.clear();\n    this.keyBuffer = [text || \"\"];\n    this.insertModeChanges = [];\n    this.searchQueries = [];\n    this.linewise = !!linewise;\n    this.blockwise = !!blockwise;\n  }\n  Register.prototype = {\n    setText: function (text, linewise, blockwise) {\n      this.keyBuffer = [text || \"\"];\n      this.linewise = !!linewise;\n      this.blockwise = !!blockwise;\n    },\n    pushText: function (text, linewise) {\n      // if this register has ever been set to linewise, use linewise.\n      if (linewise) {\n        if (!this.linewise) {\n          this.keyBuffer.push(\"\\n\");\n        }\n        this.linewise = true;\n      }\n      this.keyBuffer.push(text);\n    },\n    pushInsertModeChanges: function (changes) {\n      this.insertModeChanges.push(createInsertModeChanges(changes));\n    },\n    pushSearchQuery: function (query) {\n      this.searchQueries.push(query);\n    },\n    clear: function () {\n      this.keyBuffer = [];\n      this.insertModeChanges = [];\n      this.searchQueries = [];\n      this.linewise = false;\n    },\n    toString: function () {\n      return this.keyBuffer.join(\"\");\n    },\n  };\n\n  /**\n   * Defines an external register.\n   *\n   * The name should be a single character that will be used to reference the register.\n   * The register should support setText, pushText, clear, and toString(). See Register\n   * for a reference implementation.\n   */\n  function defineRegister(name, register) {\n    var registers = vimGlobalState.registerController.registers;\n    if (!name || name.length != 1) {\n      throw Error(\"Register name must be 1 character\");\n    }\n    if (registers[name]) {\n      throw Error(\"Register already defined \" + name);\n    }\n    registers[name] = register;\n    validRegisters.push(name);\n  }\n\n  /*\n   * vim registers allow you to keep many independent copy and paste buffers.\n   * See http://usevim.com/2012/04/13/registers/ for an introduction.\n   *\n   * RegisterController keeps the state of all the registers.  An initial\n   * state may be passed in.  The unnamed register '\"' will always be\n   * overridden.\n   */\n  function RegisterController(registers) {\n    this.registers = registers;\n    this.unnamedRegister = registers['\"'] = new Register();\n    registers[\".\"] = new Register();\n    registers[\":\"] = new Register();\n    registers[\"/\"] = new Register();\n  }\n  RegisterController.prototype = {\n    pushText: function (registerName, operator, text, linewise, blockwise) {\n      // The black hole register, \"_, means delete/yank to nowhere.\n      if (registerName === \"_\") return;\n      if (linewise && text.charAt(text.length - 1) !== \"\\n\") {\n        text += \"\\n\";\n      }\n      // Lowercase and uppercase registers refer to the same register.\n      // Uppercase just means append.\n      var register = this.isValidRegister(registerName)\n        ? this.getRegister(registerName)\n        : null;\n      // if no register/an invalid register was specified, things go to the\n      // default registers\n      if (!register) {\n        switch (operator) {\n          case \"yank\":\n            // The 0 register contains the text from the most recent yank.\n            this.registers[\"0\"] = new Register(text, linewise, blockwise);\n            break;\n          case \"delete\":\n          case \"change\":\n            if (text.indexOf(\"\\n\") == -1) {\n              // Delete less than 1 line. Update the small delete register.\n              this.registers[\"-\"] = new Register(text, linewise);\n            } else {\n              // Shift down the contents of the numbered registers and put the\n              // deleted text into register 1.\n              this.shiftNumericRegisters_();\n              this.registers[\"1\"] = new Register(text, linewise);\n            }\n            break;\n        }\n        // Make sure the unnamed register is set to what just happened\n        this.unnamedRegister.setText(text, linewise, blockwise);\n        return;\n      }\n\n      // If we've gotten to this point, we've actually specified a register\n      var append = isUpperCase(registerName);\n      if (append) {\n        register.pushText(text, linewise);\n      } else {\n        register.setText(text, linewise, blockwise);\n      }\n      // The unnamed register always has the same value as the last used\n      // register.\n      this.unnamedRegister.setText(register.toString(), linewise);\n    },\n    // Gets the register named @name.  If one of @name doesn't already exist,\n    // create it.  If @name is invalid, return the unnamedRegister.\n    getRegister: function (name) {\n      if (!this.isValidRegister(name)) {\n        return this.unnamedRegister;\n      }\n      name = name.toLowerCase();\n      if (!this.registers[name]) {\n        this.registers[name] = new Register();\n      }\n      return this.registers[name];\n    },\n    isValidRegister: function (name) {\n      return name && inArray(name, validRegisters);\n    },\n    shiftNumericRegisters_: function () {\n      for (var i = 9; i >= 2; i--) {\n        this.registers[i] = this.getRegister(\"\" + (i - 1));\n      }\n    },\n  };\n  function HistoryController() {\n    this.historyBuffer = [];\n    this.iterator = 0;\n    this.initialPrefix = null;\n  }\n  HistoryController.prototype = {\n    // the input argument here acts a user entered prefix for a small time\n    // until we start autocompletion in which case it is the autocompleted.\n    nextMatch: function (input, up) {\n      var historyBuffer = this.historyBuffer;\n      var dir = up ? -1 : 1;\n      if (this.initialPrefix === null) this.initialPrefix = input;\n      for (\n        var i = this.iterator + dir;\n        up ? i >= 0 : i < historyBuffer.length;\n        i += dir\n      ) {\n        var element = historyBuffer[i];\n        for (var j = 0; j <= element.length; j++) {\n          if (this.initialPrefix == element.substring(0, j)) {\n            this.iterator = i;\n            return element;\n          }\n        }\n      }\n      // should return the user input in case we reach the end of buffer.\n      if (i >= historyBuffer.length) {\n        this.iterator = historyBuffer.length;\n        return this.initialPrefix;\n      }\n      // return the last autocompleted query or exCommand as it is.\n      if (i < 0) return input;\n    },\n    pushInput: function (input) {\n      var index = this.historyBuffer.indexOf(input);\n      if (index > -1) this.historyBuffer.splice(index, 1);\n      if (input.length) this.historyBuffer.push(input);\n    },\n    reset: function () {\n      this.initialPrefix = null;\n      this.iterator = this.historyBuffer.length;\n    },\n  };\n  var commandDispatcher = {\n    matchCommand: function (keys, keyMap, inputState, context) {\n      var matches = commandMatches(keys, keyMap, context, inputState);\n      if (!matches.full && !matches.partial) {\n        return { type: \"none\" };\n      } else if (!matches.full && matches.partial) {\n        return { type: \"partial\" };\n      }\n\n      var bestMatch;\n      for (var i = 0; i < matches.full.length; i++) {\n        var match = matches.full[i];\n        if (!bestMatch) {\n          bestMatch = match;\n        }\n      }\n      if (bestMatch.keys.slice(-11) == \"<character>\") {\n        var character = lastChar(keys);\n        if (!character) return { type: \"none\" };\n        inputState.selectedCharacter = character;\n      }\n      return { type: \"full\", command: bestMatch };\n    },\n    processCommand: function (cm, vim, command) {\n      vim.inputState.repeatOverride = command.repeatOverride;\n      switch (command.type) {\n        case \"motion\":\n          this.processMotion(cm, vim, command);\n          break;\n        case \"operator\":\n          this.processOperator(cm, vim, command);\n          break;\n        case \"operatorMotion\":\n          this.processOperatorMotion(cm, vim, command);\n          break;\n        case \"action\":\n          this.processAction(cm, vim, command);\n          break;\n        case \"search\":\n          this.processSearch(cm, vim, command);\n          break;\n        case \"ex\":\n        case \"keyToEx\":\n          this.processEx(cm, vim, command);\n          break;\n        default:\n          break;\n      }\n    },\n    processMotion: function (cm, vim, command) {\n      vim.inputState.motion = command.motion;\n      vim.inputState.motionArgs = copyArgs(command.motionArgs);\n      this.evalInput(cm, vim);\n    },\n    processOperator: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      if (inputState.operator) {\n        if (inputState.operator == command.operator) {\n          // Typing an operator twice like 'dd' makes the operator operate\n          // linewise\n          inputState.motion = \"expandToLine\";\n          inputState.motionArgs = { linewise: true };\n          this.evalInput(cm, vim);\n          return;\n        } else {\n          // 2 different operators in a row doesn't make sense.\n          clearInputState(cm);\n        }\n      }\n      inputState.operator = command.operator;\n      inputState.operatorArgs = copyArgs(command.operatorArgs);\n      if (command.keys.length > 1) {\n        inputState.operatorShortcut = command.keys;\n      }\n      if (command.exitVisualBlock) {\n        vim.visualBlock = false;\n        updateCmSelection(cm);\n      }\n      if (vim.visualMode) {\n        // Operating on a selection in visual mode. We don't need a motion.\n        this.evalInput(cm, vim);\n      }\n    },\n    processOperatorMotion: function (cm, vim, command) {\n      var visualMode = vim.visualMode;\n      var operatorMotionArgs = copyArgs(command.operatorMotionArgs);\n      if (operatorMotionArgs) {\n        // Operator motions may have special behavior in visual mode.\n        if (visualMode && operatorMotionArgs.visualLine) {\n          vim.visualLine = true;\n        }\n      }\n      this.processOperator(cm, vim, command);\n      if (!visualMode) {\n        this.processMotion(cm, vim, command);\n      }\n    },\n    processAction: function (cm, vim, command) {\n      var inputState = vim.inputState;\n      var repeat = inputState.getRepeat();\n      var repeatIsExplicit = !!repeat;\n      var actionArgs = copyArgs(command.actionArgs) || {};\n      if (inputState.selectedCharacter) {\n        actionArgs.selectedCharacter = inputState.selectedCharacter;\n      }\n      // Actions may or may not have motions and operators. Do these first.\n      if (command.operator) {\n        this.processOperator(cm, vim, command);\n      }\n      if (command.motion) {\n        this.processMotion(cm, vim, command);\n      }\n      if (command.motion || command.operator) {\n        this.evalInput(cm, vim);\n      }\n      actionArgs.repeat = repeat || 1;\n      actionArgs.repeatIsExplicit = repeatIsExplicit;\n      actionArgs.registerName = inputState.registerName;\n      clearInputState(cm);\n      vim.lastMotion = null;\n      if (command.isEdit) {\n        this.recordLastEdit(vim, inputState, command);\n      }\n      actions[command.action](cm, actionArgs, vim);\n    },\n    processSearch: function (cm, vim, command) {\n      if (!cm.getSearchCursor) {\n        // Search depends on SearchCursor.\n        return;\n      }\n      var forward = command.searchArgs.forward;\n      var wholeWordOnly = command.searchArgs.wholeWordOnly;\n      getSearchState(cm).setReversed(!forward);\n      var promptPrefix = forward ? \"/\" : \"?\";\n      var originalQuery = getSearchState(cm).getQuery();\n      var originalScrollPos = cm.getScrollInfo();\n      function handleQuery(query, ignoreCase, smartCase) {\n        vimGlobalState.searchHistoryController.pushInput(query);\n        vimGlobalState.searchHistoryController.reset();\n        try {\n          updateSearchQuery(cm, query, ignoreCase, smartCase);\n        } catch (e) {\n          showConfirm(cm, \"Invalid regex: \" + query);\n          clearInputState(cm);\n          return;\n        }\n        commandDispatcher.processMotion(cm, vim, {\n          type: \"motion\",\n          motion: \"findNext\",\n          motionArgs: {\n            forward: true,\n            toJumplist: command.searchArgs.toJumplist,\n          },\n        });\n      }\n      function onPromptClose(query) {\n        cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        handleQuery(query, true /** ignoreCase */, true /** smartCase */);\n        var macroModeState = vimGlobalState.macroModeState;\n        if (macroModeState.isRecording) {\n          logSearchQuery(macroModeState, query);\n        }\n      }\n      function onPromptKeyUp(e, query, close) {\n        var keyName = CodeMirror.keyName(e),\n          up,\n          offset;\n        if (keyName == \"Up\" || keyName == \"Down\") {\n          up = keyName == \"Up\" ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          query =\n            vimGlobalState.searchHistoryController.nextMatch(query, up) || \"\";\n          close(query);\n          if (offset && e.target)\n            e.target.selectionEnd = e.target.selectionStart = Math.min(\n              offset,\n              e.target.value.length\n            );\n        } else {\n          if (\n            keyName != \"Left\" &&\n            keyName != \"Right\" &&\n            keyName != \"Ctrl\" &&\n            keyName != \"Alt\" &&\n            keyName != \"Shift\"\n          )\n            vimGlobalState.searchHistoryController.reset();\n        }\n        var parsedQuery;\n        try {\n          parsedQuery = updateSearchQuery(\n            cm,\n            query,\n            true /** ignoreCase */,\n            true /** smartCase */\n          );\n        } catch (e) {\n          // Swallow bad regexes for incremental search.\n        }\n        if (parsedQuery) {\n          cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);\n        } else {\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n        }\n      }\n      function onPromptKeyDown(e, query, close) {\n        var keyName = CodeMirror.keyName(e);\n        if (\n          keyName == \"Esc\" ||\n          keyName == \"Ctrl-C\" ||\n          keyName == \"Ctrl-[\" ||\n          (keyName == \"Backspace\" && query == \"\")\n        ) {\n          vimGlobalState.searchHistoryController.pushInput(query);\n          vimGlobalState.searchHistoryController.reset();\n          updateSearchQuery(cm, originalQuery);\n          clearSearchHighlight(cm);\n          cm.scrollTo(originalScrollPos.left, originalScrollPos.top);\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        } else if (keyName == \"Up\" || keyName == \"Down\") {\n          CodeMirror.e_stop(e);\n        } else if (keyName == \"Ctrl-U\") {\n          // Ctrl-U clears input.\n          CodeMirror.e_stop(e);\n          close(\"\");\n        }\n      }\n      switch (command.searchArgs.querySrc) {\n        case \"prompt\":\n          var macroModeState = vimGlobalState.macroModeState;\n          if (macroModeState.isPlaying) {\n            var query = macroModeState.replaySearchQueries.shift();\n            handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          } else {\n            showPrompt(cm, {\n              onClose: onPromptClose,\n              prefix: promptPrefix,\n              desc: \"(JavaScript regexp)\",\n              onKeyUp: onPromptKeyUp,\n              onKeyDown: onPromptKeyDown,\n            });\n          }\n          break;\n        case \"wordUnderCursor\":\n          var word = expandWordUnderCursor(\n            cm,\n            false /** inclusive */,\n            true /** forward */,\n            false /** bigWord */,\n            true /** noSymbol */\n          );\n          var isKeyword = true;\n          if (!word) {\n            word = expandWordUnderCursor(\n              cm,\n              false /** inclusive */,\n              true /** forward */,\n              false /** bigWord */,\n              false /** noSymbol */\n            );\n            isKeyword = false;\n          }\n          if (!word) {\n            return;\n          }\n          var query = cm\n            .getLine(word.start.line)\n            .substring(word.start.ch, word.end.ch);\n          if (isKeyword && wholeWordOnly) {\n            query = \"\\\\b\" + query + \"\\\\b\";\n          } else {\n            query = escapeRegex(query);\n          }\n\n          // cachedCursor is used to save the old position of the cursor\n          // when * or # causes vim to seek for the nearest word and shift\n          // the cursor before entering the motion.\n          vimGlobalState.jumpList.cachedCursor = cm.getCursor();\n          cm.setCursor(word.start);\n\n          handleQuery(query, true /** ignoreCase */, false /** smartCase */);\n          break;\n      }\n    },\n    processEx: function (cm, vim, command) {\n      function onPromptClose(input) {\n        // Give the prompt some time to close so that if processCommand shows\n        // an error, the elements don't overlap.\n        vimGlobalState.exCommandHistoryController.pushInput(input);\n        vimGlobalState.exCommandHistoryController.reset();\n        exCommandDispatcher.processCommand(cm, input);\n      }\n      function onPromptKeyDown(e, input, close) {\n        var keyName = CodeMirror.keyName(e),\n          up,\n          offset;\n        if (\n          keyName == \"Esc\" ||\n          keyName == \"Ctrl-C\" ||\n          keyName == \"Ctrl-[\" ||\n          (keyName == \"Backspace\" && input == \"\")\n        ) {\n          vimGlobalState.exCommandHistoryController.pushInput(input);\n          vimGlobalState.exCommandHistoryController.reset();\n          CodeMirror.e_stop(e);\n          clearInputState(cm);\n          close();\n          cm.focus();\n        }\n        if (keyName == \"Up\" || keyName == \"Down\") {\n          CodeMirror.e_stop(e);\n          up = keyName == \"Up\" ? true : false;\n          offset = e.target ? e.target.selectionEnd : 0;\n          input =\n            vimGlobalState.exCommandHistoryController.nextMatch(input, up) ||\n            \"\";\n          close(input);\n          if (offset && e.target)\n            e.target.selectionEnd = e.target.selectionStart = Math.min(\n              offset,\n              e.target.value.length\n            );\n        } else if (keyName == \"Ctrl-U\") {\n          // Ctrl-U clears input.\n          CodeMirror.e_stop(e);\n          close(\"\");\n        } else {\n          if (\n            keyName != \"Left\" &&\n            keyName != \"Right\" &&\n            keyName != \"Ctrl\" &&\n            keyName != \"Alt\" &&\n            keyName != \"Shift\"\n          )\n            vimGlobalState.exCommandHistoryController.reset();\n        }\n      }\n      if (command.type == \"keyToEx\") {\n        // Handle user defined Ex to Ex mappings\n        exCommandDispatcher.processCommand(cm, command.exArgs.input);\n      } else {\n        if (vim.visualMode) {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: \":\",\n            value: \"'<,'>\",\n            onKeyDown: onPromptKeyDown,\n            selectValueOnOpen: false,\n          });\n        } else {\n          showPrompt(cm, {\n            onClose: onPromptClose,\n            prefix: \":\",\n            onKeyDown: onPromptKeyDown,\n          });\n        }\n      }\n    },\n    evalInput: function (cm, vim) {\n      // If the motion command is set, execute both the operator and motion.\n      // Otherwise return.\n      var inputState = vim.inputState;\n      var motion = inputState.motion;\n      var motionArgs = inputState.motionArgs || {};\n      var operator = inputState.operator;\n      var operatorArgs = inputState.operatorArgs || {};\n      var registerName = inputState.registerName;\n      var sel = vim.sel;\n      // TODO: Make sure cm and vim selections are identical outside visual mode.\n      var origHead = copyCursor(\n        vim.visualMode\n          ? clipCursorToContent(cm, sel.head)\n          : cm.getCursor(\"head\")\n      );\n      var origAnchor = copyCursor(\n        vim.visualMode\n          ? clipCursorToContent(cm, sel.anchor)\n          : cm.getCursor(\"anchor\")\n      );\n      var oldHead = copyCursor(origHead);\n      var oldAnchor = copyCursor(origAnchor);\n      var newHead, newAnchor;\n      var repeat;\n      if (operator) {\n        this.recordLastEdit(vim, inputState);\n      }\n      if (inputState.repeatOverride !== undefined) {\n        // If repeatOverride is specified, that takes precedence over the\n        // input state's repeat. Used by Ex mode and can be user defined.\n        repeat = inputState.repeatOverride;\n      } else {\n        repeat = inputState.getRepeat();\n      }\n      if (repeat > 0 && motionArgs.explicitRepeat) {\n        motionArgs.repeatIsExplicit = true;\n      } else if (\n        motionArgs.noRepeat ||\n        (!motionArgs.explicitRepeat && repeat === 0)\n      ) {\n        repeat = 1;\n        motionArgs.repeatIsExplicit = false;\n      }\n      if (inputState.selectedCharacter) {\n        // If there is a character input, stick it in all of the arg arrays.\n        motionArgs.selectedCharacter = operatorArgs.selectedCharacter =\n          inputState.selectedCharacter;\n      }\n      motionArgs.repeat = repeat;\n      clearInputState(cm);\n      if (motion) {\n        var motionResult = motions[motion](\n          cm,\n          origHead,\n          motionArgs,\n          vim,\n          inputState\n        );\n        vim.lastMotion = motions[motion];\n        if (!motionResult) {\n          return;\n        }\n        if (motionArgs.toJumplist) {\n          var jumpList = vimGlobalState.jumpList;\n          // if the current motion is # or *, use cachedCursor\n          var cachedCursor = jumpList.cachedCursor;\n          if (cachedCursor) {\n            recordJumpPosition(cm, cachedCursor, motionResult);\n            delete jumpList.cachedCursor;\n          } else {\n            recordJumpPosition(cm, origHead, motionResult);\n          }\n        }\n        if (motionResult instanceof Array) {\n          newAnchor = motionResult[0];\n          newHead = motionResult[1];\n        } else {\n          newHead = motionResult;\n        }\n        // TODO: Handle null returns from motion commands better.\n        if (!newHead) {\n          newHead = copyCursor(origHead);\n        }\n        if (vim.visualMode) {\n          if (!(vim.visualBlock && newHead.ch === Infinity)) {\n            newHead = clipCursorToContent(cm, newHead);\n          }\n          if (newAnchor) {\n            newAnchor = clipCursorToContent(cm, newAnchor);\n          }\n          newAnchor = newAnchor || oldAnchor;\n          sel.anchor = newAnchor;\n          sel.head = newHead;\n          updateCmSelection(cm);\n          updateMark(\n            cm,\n            vim,\n            \"<\",\n            cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead\n          );\n          updateMark(\n            cm,\n            vim,\n            \">\",\n            cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor\n          );\n        } else if (!operator) {\n          newHead = clipCursorToContent(cm, newHead);\n          cm.setCursor(newHead.line, newHead.ch);\n        }\n      }\n      if (operator) {\n        if (operatorArgs.lastSel) {\n          // Replaying a visual mode operation\n          newAnchor = oldAnchor;\n          var lastSel = operatorArgs.lastSel;\n          var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);\n          var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);\n          if (lastSel.visualLine) {\n            // Linewise Visual mode: The same number of lines.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          } else if (lastSel.visualBlock) {\n            // Blockwise Visual mode: The same number of lines and columns.\n            newHead = new Pos(\n              oldAnchor.line + lineOffset,\n              oldAnchor.ch + chOffset\n            );\n          } else if (lastSel.head.line == lastSel.anchor.line) {\n            // Normal Visual mode within one line: The same number of characters.\n            newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);\n          } else {\n            // Normal Visual mode with several lines: The same number of lines, in the\n            // last line the same number of characters as in the last line the last time.\n            newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);\n          }\n          vim.visualMode = true;\n          vim.visualLine = lastSel.visualLine;\n          vim.visualBlock = lastSel.visualBlock;\n          sel = vim.sel = {\n            anchor: newAnchor,\n            head: newHead,\n          };\n          updateCmSelection(cm);\n        } else if (vim.visualMode) {\n          operatorArgs.lastSel = {\n            anchor: copyCursor(sel.anchor),\n            head: copyCursor(sel.head),\n            visualBlock: vim.visualBlock,\n            visualLine: vim.visualLine,\n          };\n        }\n        var curStart, curEnd, linewise, mode;\n        var cmSel;\n        if (vim.visualMode) {\n          // Init visual op\n          curStart = cursorMin(sel.head, sel.anchor);\n          curEnd = cursorMax(sel.head, sel.anchor);\n          linewise = vim.visualLine || operatorArgs.linewise;\n          mode = vim.visualBlock ? \"block\" : linewise ? \"line\" : \"char\";\n          cmSel = makeCmSelection(\n            cm,\n            {\n              anchor: curStart,\n              head: curEnd,\n            },\n            mode\n          );\n          if (linewise) {\n            var ranges = cmSel.ranges;\n            if (mode == \"block\") {\n              // Linewise operators in visual block mode extend to end of line\n              for (var i = 0; i < ranges.length; i++) {\n                ranges[i].head.ch = lineLength(cm, ranges[i].head.line);\n              }\n            } else if (mode == \"line\") {\n              ranges[0].head = new Pos(ranges[0].head.line + 1, 0);\n            }\n          }\n        } else {\n          // Init motion op\n          curStart = copyCursor(newAnchor || oldAnchor);\n          curEnd = copyCursor(newHead || oldHead);\n          if (cursorIsBefore(curEnd, curStart)) {\n            var tmp = curStart;\n            curStart = curEnd;\n            curEnd = tmp;\n          }\n          linewise = motionArgs.linewise || operatorArgs.linewise;\n          if (linewise) {\n            // Expand selection to entire line.\n            expandSelectionToLine(cm, curStart, curEnd);\n          } else if (motionArgs.forward) {\n            // Clip to trailing newlines only if the motion goes forward.\n            clipToLine(cm, curStart, curEnd);\n          }\n          mode = \"char\";\n          var exclusive = !motionArgs.inclusive || linewise;\n          cmSel = makeCmSelection(\n            cm,\n            {\n              anchor: curStart,\n              head: curEnd,\n            },\n            mode,\n            exclusive\n          );\n        }\n        cm.setSelections(cmSel.ranges, cmSel.primary);\n        vim.lastMotion = null;\n        operatorArgs.repeat = repeat; // For indent in visual mode.\n        operatorArgs.registerName = registerName;\n        // Keep track of linewise as it affects how paste and change behave.\n        operatorArgs.linewise = linewise;\n        var operatorMoveTo = operators[operator](\n          cm,\n          operatorArgs,\n          cmSel.ranges,\n          oldAnchor,\n          newHead\n        );\n        if (vim.visualMode) {\n          exitVisualMode(cm, operatorMoveTo != null);\n        }\n        if (operatorMoveTo) {\n          cm.setCursor(operatorMoveTo);\n        }\n      }\n    },\n    recordLastEdit: function (vim, inputState, actionCommand) {\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      vim.lastEditInputState = inputState;\n      vim.lastEditActionCommand = actionCommand;\n      macroModeState.lastInsertModeChanges.changes = [];\n      macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;\n      macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock\n        ? vim.sel.head.line - vim.sel.anchor.line\n        : 0;\n    },\n  };\n\n  /**\n   * typedef {Object{line:number,ch:number}} Cursor An object containing the\n   *     position of the cursor.\n   */\n  // All of the functions below return Cursor objects.\n  var motions = {\n    moveToTopLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToMiddleLine: function (cm) {\n      var range = getUserVisibleLines(cm);\n      var line = Math.floor((range.top + range.bottom) * 0.5);\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    moveToBottomLine: function (cm, _head, motionArgs) {\n      var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;\n      return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));\n    },\n    expandToLine: function (_cm, head, motionArgs) {\n      // Expands forward to end of line, and then to next line if repeat is\n      // >1. Does not handle backward motion!\n      var cur = head;\n      return new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    },\n    findNext: function (cm, _head, motionArgs) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      if (!query) {\n        return;\n      }\n      var prev = !motionArgs.forward;\n      // If search is initiated with ? instead of /, negate direction.\n      prev = state.isReversed() ? !prev : prev;\n      highlightSearchMatches(cm, query);\n      return findNext(cm, prev /** prev */, query, motionArgs.repeat);\n    },\n    /**\n     * Find and select the next occurrence of the search query. If the cursor is currently\n     * within a match, then find and select the current match. Otherwise, find the next occurrence in the\n     * appropriate direction.\n     *\n     * This differs from `findNext` in the following ways:\n     *\n     * 1. Instead of only returning the \"from\", this returns a \"from\", \"to\" range.\n     * 2. If the cursor is currently inside a search match, this selects the current match\n     *    instead of the next match.\n     * 3. If there is no associated operator, this will turn on visual mode.\n     */\n    findAndSelectNextInclusive: function (\n      cm,\n      _head,\n      motionArgs,\n      vim,\n      prevInputState\n    ) {\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n\n      if (!query) {\n        return;\n      }\n\n      var prev = !motionArgs.forward;\n      prev = state.isReversed() ? !prev : prev;\n\n      // next: [from, to] | null\n      var next = findNextFromAndToInclusive(\n        cm,\n        prev,\n        query,\n        motionArgs.repeat,\n        vim\n      );\n\n      // No matches.\n      if (!next) {\n        return;\n      }\n\n      // If there's an operator that will be executed, return the selection.\n      if (prevInputState.operator) {\n        return next;\n      }\n\n      // At this point, we know that there is no accompanying operator -- let's\n      // deal with visual mode in order to select an appropriate match.\n\n      var from = next[0];\n      // For whatever reason, when we use the \"to\" as returned by searchcursor.js directly,\n      // the resulting selection is extended by 1 char. Let's shrink it so that only the\n      // match is selected.\n      var to = new Pos(next[1].line, next[1].ch - 1);\n\n      if (vim.visualMode) {\n        // If we were in visualLine or visualBlock mode, get out of it.\n        if (vim.visualLine || vim.visualBlock) {\n          vim.visualLine = false;\n          vim.visualBlock = false;\n          CodeMirror.signal(cm, \"vim-mode-change\", {\n            mode: \"visual\",\n            subMode: \"\",\n          });\n        }\n\n        // If we're currently in visual mode, we should extend the selection to include\n        // the search result.\n        var anchor = vim.sel.anchor;\n        if (anchor) {\n          if (state.isReversed()) {\n            if (motionArgs.forward) {\n              return [anchor, from];\n            }\n\n            return [anchor, to];\n          } else {\n            if (motionArgs.forward) {\n              return [anchor, to];\n            }\n\n            return [anchor, from];\n          }\n        }\n      } else {\n        // Let's turn visual mode on.\n        vim.visualMode = true;\n        vim.visualLine = false;\n        vim.visualBlock = false;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: \"\",\n        });\n      }\n\n      return prev ? [to, from] : [from, to];\n    },\n    goToMark: function (cm, _head, motionArgs, vim) {\n      var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);\n      if (pos) {\n        return motionArgs.linewise\n          ? {\n              line: pos.line,\n              ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line)),\n            }\n          : pos;\n      }\n      return null;\n    },\n    moveToOtherHighlightedEnd: function (cm, _head, motionArgs, vim) {\n      if (vim.visualBlock && motionArgs.sameLine) {\n        var sel = vim.sel;\n        return [\n          clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)),\n          clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch)),\n        ];\n      } else {\n        return [vim.sel.head, vim.sel.anchor];\n      }\n    },\n    jumpToMark: function (cm, head, motionArgs, vim) {\n      var best = head;\n      for (var i = 0; i < motionArgs.repeat; i++) {\n        var cursor = best;\n        for (var key in vim.marks) {\n          if (!isLowerCase(key)) {\n            continue;\n          }\n          var mark = vim.marks[key].find();\n          var isWrongDirection = motionArgs.forward\n            ? cursorIsBefore(mark, cursor)\n            : cursorIsBefore(cursor, mark);\n\n          if (isWrongDirection) {\n            continue;\n          }\n          if (motionArgs.linewise && mark.line == cursor.line) {\n            continue;\n          }\n\n          var equal = cursorEqual(cursor, best);\n          var between = motionArgs.forward\n            ? cursorIsBetween(cursor, mark, best)\n            : cursorIsBetween(best, mark, cursor);\n\n          if (equal || between) {\n            best = mark;\n          }\n        }\n      }\n\n      if (motionArgs.linewise) {\n        // Vim places the cursor on the first non-whitespace character of\n        // the line if there is one, else it places the cursor at the end\n        // of the line, regardless of whether a mark was found.\n        best = new Pos(\n          best.line,\n          findFirstNonWhiteSpaceCharacter(cm.getLine(best.line))\n        );\n      }\n      return best;\n    },\n    moveByCharacters: function (_cm, head, motionArgs) {\n      var cur = head;\n      var repeat = motionArgs.repeat;\n      var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;\n      return new Pos(cur.line, ch);\n    },\n    moveByLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      var endCh = cur.ch;\n      // Depending what our last motion was, we may want to do different\n      // things. If our last motion was moving vertically, we want to\n      // preserve the HPos from our last horizontal move.  If our last motion\n      // was going to the end of a line, moving vertically we should go to\n      // the end of the line, etc.\n      switch (vim.lastMotion) {\n        case this.moveByLines:\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveToColumn:\n        case this.moveToEol:\n          endCh = vim.lastHPos;\n          break;\n        default:\n          vim.lastHPos = endCh;\n      }\n      var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);\n      var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;\n      var first = cm.firstLine();\n      var last = cm.lastLine();\n      var posV = cm.findPosV(\n        cur,\n        motionArgs.forward ? repeat : -repeat,\n        \"line\",\n        vim.lastHSPos\n      );\n      var hasMarkedText = motionArgs.forward\n        ? posV.line > line\n        : posV.line < line;\n      if (hasMarkedText) {\n        line = posV.line;\n        endCh = posV.ch;\n      }\n      // Vim go to line begin or line end when cursor at first/last line and\n      // move to previous/next line is triggered.\n      if (line < first && cur.line == first) {\n        return this.moveToStartOfLine(cm, head, motionArgs, vim);\n      } else if (line > last && cur.line == last) {\n        return moveToEol(cm, head, motionArgs, vim, true);\n      }\n      if (motionArgs.toFirstChar) {\n        endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));\n        vim.lastHPos = endCh;\n      }\n      vim.lastHSPos = cm.charCoords(new Pos(line, endCh), \"div\").left;\n      return new Pos(line, endCh);\n    },\n    moveByDisplayLines: function (cm, head, motionArgs, vim) {\n      var cur = head;\n      switch (vim.lastMotion) {\n        case this.moveByDisplayLines:\n        case this.moveByScroll:\n        case this.moveByLines:\n        case this.moveToColumn:\n        case this.moveToEol:\n          break;\n        default:\n          vim.lastHSPos = cm.charCoords(cur, \"div\").left;\n      }\n      var repeat = motionArgs.repeat;\n      var res = cm.findPosV(\n        cur,\n        motionArgs.forward ? repeat : -repeat,\n        \"line\",\n        vim.lastHSPos\n      );\n      if (res.hitSide) {\n        if (motionArgs.forward) {\n          var lastCharCoords = cm.charCoords(res, \"div\");\n          var goalCoords = { top: lastCharCoords.top + 8, left: vim.lastHSPos };\n          var res = cm.coordsChar(goalCoords, \"div\");\n        } else {\n          var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), \"div\");\n          resCoords.left = vim.lastHSPos;\n          res = cm.coordsChar(resCoords, \"div\");\n        }\n      }\n      vim.lastHPos = res.ch;\n      return res;\n    },\n    moveByPage: function (cm, head, motionArgs) {\n      // CodeMirror only exposes functions that move the cursor page down, so\n      // doing this bad hack to move the cursor and move it back. evalInput\n      // will move the cursor to where it should be in the end.\n      var curStart = head;\n      var repeat = motionArgs.repeat;\n      return cm.findPosV(\n        curStart,\n        motionArgs.forward ? repeat : -repeat,\n        \"page\"\n      );\n    },\n    moveByParagraph: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findParagraph(cm, head, motionArgs.repeat, dir);\n    },\n    moveBySentence: function (cm, head, motionArgs) {\n      var dir = motionArgs.forward ? 1 : -1;\n      return findSentence(cm, head, motionArgs.repeat, dir);\n    },\n    moveByScroll: function (cm, head, motionArgs, vim) {\n      var scrollbox = cm.getScrollInfo();\n      var curEnd = null;\n      var repeat = motionArgs.repeat;\n      if (!repeat) {\n        repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());\n      }\n      var orig = cm.charCoords(head, \"local\");\n      motionArgs.repeat = repeat;\n      var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);\n      if (!curEnd) {\n        return null;\n      }\n      var dest = cm.charCoords(curEnd, \"local\");\n      cm.scrollTo(null, scrollbox.top + dest.top - orig.top);\n      return curEnd;\n    },\n    moveByWords: function (cm, head, motionArgs) {\n      return moveToWord(\n        cm,\n        head,\n        motionArgs.repeat,\n        !!motionArgs.forward,\n        !!motionArgs.wordEnd,\n        !!motionArgs.bigWord\n      );\n    },\n    moveTillCharacter: function (cm, _head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      var curEnd = moveToCharacter(\n        cm,\n        repeat,\n        motionArgs.forward,\n        motionArgs.selectedCharacter\n      );\n      var increment = motionArgs.forward ? -1 : 1;\n      recordLastCharacterSearch(increment, motionArgs);\n      if (!curEnd) return null;\n      curEnd.ch += increment;\n      return curEnd;\n    },\n    moveToCharacter: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      recordLastCharacterSearch(0, motionArgs);\n      return (\n        moveToCharacter(\n          cm,\n          repeat,\n          motionArgs.forward,\n          motionArgs.selectedCharacter\n        ) || head\n      );\n    },\n    moveToSymbol: function (cm, head, motionArgs) {\n      var repeat = motionArgs.repeat;\n      return (\n        findSymbol(\n          cm,\n          repeat,\n          motionArgs.forward,\n          motionArgs.selectedCharacter\n        ) || head\n      );\n    },\n    moveToColumn: function (cm, head, motionArgs, vim) {\n      var repeat = motionArgs.repeat;\n      // repeat is equivalent to which column we want to move to!\n      vim.lastHPos = repeat - 1;\n      vim.lastHSPos = cm.charCoords(head, \"div\").left;\n      return moveToColumn(cm, repeat);\n    },\n    moveToEol: function (cm, head, motionArgs, vim) {\n      return moveToEol(cm, head, motionArgs, vim, false);\n    },\n    moveToFirstNonWhiteSpaceCharacter: function (cm, head) {\n      // Go to the start of the line where the text begins, or the end for\n      // whitespace-only lines\n      var cursor = head;\n      return new Pos(\n        cursor.line,\n        findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line))\n      );\n    },\n    moveToMatchedSymbol: function (cm, head) {\n      var cursor = head;\n      var line = cursor.line;\n      var ch = cursor.ch;\n      var lineText = cm.getLine(line);\n      // var symbol;\n      // for (; ch < lineText.length; ch++) {\n      //   symbol = lineText.charAt(ch);\n      //   if (symbol && isMatchableSymbol(symbol)) {\n      //     var style = cm.getTokenTypeAt(new Pos(line, ch + 1));\n      //     if (style !== \"string\" && style !== \"comment\") {\n      //       break;\n      //     }\n      //   }\n      // }\n      if (ch < lineText.length) {\n        // Only include angle brackets in analysis if they are being matched.\n        var re = ch === \"<\" || ch === \">\" ? /[(){}[\\]<>]/ : /[(){}[\\]]/;\n        var matched = cm.findMatchingBracket(new Pos(line, ch), {\n          bracketRegex: re,\n        });\n        return matched.to;\n      } else {\n        return cursor;\n      }\n    },\n    moveToStartOfLine: function (_cm, head) {\n      return new Pos(head.line, 0);\n    },\n    moveToLineOrEdgeOfDocument: function (cm, _head, motionArgs) {\n      var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();\n      if (motionArgs.repeatIsExplicit) {\n        lineNum = motionArgs.repeat - cm.getOption(\"firstLineNumber\");\n      }\n      return new Pos(\n        lineNum,\n        findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum))\n      );\n    },\n    moveToStartOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineLeft\");\n      return cm.getCursor();\n    },\n    moveToEndOfDisplayLine: function (cm) {\n      cm.execCommand(\"goLineRight\");\n      var head = cm.getCursor();\n      if (head.sticky == \"before\") head.ch--;\n      return head;\n    },\n    textObjectManipulation: function (cm, head, motionArgs, vim) {\n      // TODO: lots of possible exceptions that can be thrown here. Try da(\n      //     outside of a () block.\n      var mirroredPairs = {\n        \"(\": \")\",\n        \")\": \"(\",\n        \"{\": \"}\",\n        \"}\": \"{\",\n        \"[\": \"]\",\n        \"]\": \"[\",\n        \"<\": \">\",\n        \">\": \"<\",\n      };\n      var selfPaired = { \"'\": true, '\"': true, \"`\": true };\n\n      var character = motionArgs.selectedCharacter;\n      // 'b' refers to  '()' block.\n      // 'B' refers to  '{}' block.\n      if (character == \"b\") {\n        character = \"(\";\n      } else if (character == \"B\") {\n        character = \"{\";\n      }\n\n      // Inclusive is the difference between a and i\n      // TODO: Instead of using the additional text object map to perform text\n      //     object operations, merge the map into the defaultKeyMap and use\n      //     motionArgs to define behavior. Define separate entries for 'aw',\n      //     'iw', 'a[', 'i[', etc.\n      var inclusive = !motionArgs.textObjectInner;\n\n      var tmp;\n      if (mirroredPairs[character]) {\n        tmp = selectCompanionObject(cm, head, character, inclusive);\n      } else if (selfPaired[character]) {\n        tmp = findBeginningAndEnd(cm, head, character, inclusive);\n      } else if (character === \"W\") {\n        tmp = expandWordUnderCursor(\n          cm,\n          inclusive,\n          true /** forward */,\n          true /** bigWord */\n        );\n      } else if (character === \"w\") {\n        tmp = expandWordUnderCursor(\n          cm,\n          inclusive,\n          true /** forward */,\n          false /** bigWord */\n        );\n      } else if (character === \"p\") {\n        tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);\n        motionArgs.linewise = true;\n        if (vim.visualMode) {\n          if (!vim.visualLine) {\n            vim.visualLine = true;\n          }\n        } else {\n          var operatorArgs = vim.inputState.operatorArgs;\n          if (operatorArgs) {\n            operatorArgs.linewise = true;\n          }\n          tmp.end.line--;\n        }\n      } else if (character === \"t\") {\n        tmp = expandTagUnderCursor(cm, head, inclusive);\n      } else {\n        // No text object defined for this, don't move.\n        return null;\n      }\n\n      if (!cm.state.vim.visualMode) {\n        return [tmp.start, tmp.end];\n      } else {\n        return expandSelection(cm, tmp.start, tmp.end);\n      }\n    },\n\n    repeatLastCharacterSearch: function (cm, head, motionArgs) {\n      var lastSearch = vimGlobalState.lastCharacterSearch;\n      var repeat = motionArgs.repeat;\n      var forward = motionArgs.forward === lastSearch.forward;\n      var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);\n      cm.moveH(-increment, \"char\");\n      motionArgs.inclusive = forward ? true : false;\n      var curEnd = moveToCharacter(\n        cm,\n        repeat,\n        forward,\n        lastSearch.selectedCharacter\n      );\n      if (!curEnd) {\n        cm.moveH(increment, \"char\");\n        return head;\n      }\n      curEnd.ch += increment;\n      return curEnd;\n    },\n  };\n\n  function defineMotion(name, fn) {\n    motions[name] = fn;\n  }\n\n  function fillArray(val, times) {\n    var arr = [];\n    for (var i = 0; i < times; i++) {\n      arr.push(val);\n    }\n    return arr;\n  }\n  /**\n   * An operator acts on a text selection. It receives the list of selections\n   * as input. The corresponding CodeMirror selection is guaranteed to\n   * match the input selection.\n   */\n  var operators = {\n    change: function (cm, args, ranges) {\n      var finalHead, text;\n      var vim = cm.state.vim;\n      var anchor = ranges[0].anchor,\n        head = ranges[0].head;\n      if (!vim.visualMode) {\n        text = cm.getRange(anchor, head);\n        var lastState = vim.lastEditInputState || {};\n        if (lastState.motion == \"moveByWords\" && !isWhiteSpaceString(text)) {\n          // Exclude trailing whitespace if the range is not all whitespace.\n          var match = /\\s+$/.exec(text);\n          if (match && lastState.motionArgs && lastState.motionArgs.forward) {\n            head = offsetCursor(head, 0, -match[0].length);\n            text = text.slice(0, -match[0].length);\n          }\n        }\n        var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);\n        var wasLastLine = cm.firstLine() == cm.lastLine();\n        if (head.line > cm.lastLine() && args.linewise && !wasLastLine) {\n          cm.replaceRange(\"\", prevLineEnd, head);\n        } else {\n          cm.replaceRange(\"\", anchor, head);\n        }\n        if (args.linewise) {\n          // Push the next line back down, if there is a next line.\n          if (!wasLastLine) {\n            cm.setCursor(prevLineEnd);\n            CodeMirror.commands.newlineAndIndent(cm);\n          }\n          // make sure cursor ends up at the end of the line.\n          anchor.ch = Number.MAX_VALUE;\n        }\n        finalHead = anchor;\n      } else if (args.fullLine) {\n        head.ch = Number.MAX_VALUE;\n        head.line--;\n        cm.setSelection(anchor, head);\n        text = cm.getSelection();\n        cm.replaceSelections(\"\");\n        finalHead = anchor;\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray(\"\", ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(\n        args.registerName,\n        \"change\",\n        text,\n        args.linewise,\n        ranges.length > 1\n      );\n      actions.enterInsertMode(cm, { head: finalHead }, cm.state.vim);\n    },\n    // delete is a javascript keyword.\n    delete: function (cm, args, ranges) {\n      // Add to the undo stack explicitly so that this delete is recorded as a\n      // specific action instead of being bundled with generic other edits.\n      cm.pushUndoStop();\n      var finalHead, text;\n      var vim = cm.state.vim;\n      if (!vim.visualBlock) {\n        var anchor = ranges[0].anchor,\n          head = ranges[0].head;\n        if (\n          args.linewise &&\n          head.line != cm.firstLine() &&\n          anchor.line == cm.lastLine() &&\n          anchor.line == head.line - 1\n        ) {\n          // Special case for dd on last line (and first line).\n          if (anchor.line == cm.firstLine()) {\n            anchor.ch = 0;\n          } else {\n            anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));\n          }\n        }\n        text = cm.getRange(anchor, head);\n        cm.replaceRange(\"\", anchor, head);\n        finalHead = anchor;\n        if (args.linewise) {\n          finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);\n        }\n      } else {\n        text = cm.getSelection();\n        var replacement = fillArray(\"\", ranges.length);\n        cm.replaceSelections(replacement);\n        finalHead = cursorMin(ranges[0].head, ranges[0].anchor);\n      }\n      vimGlobalState.registerController.pushText(\n        args.registerName,\n        \"delete\",\n        text,\n        args.linewise,\n        vim.visualBlock\n      );\n      return clipCursorToContent(cm, finalHead);\n    },\n    indent: function (cm, args, ranges) {\n      var vim = cm.state.vim;\n      var startLine = ranges[0].anchor.line;\n      var endLine = vim.visualBlock\n        ? ranges[ranges.length - 1].anchor.line\n        : ranges[0].head.line;\n      // In visual mode, n> shifts the selection right n times, instead of\n      // shifting n lines right once.\n      var repeat = vim.visualMode ? args.repeat : 1;\n      if (args.linewise) {\n        // The only way to delete a newline is to delete until the start of\n        // the next line, so in linewise mode evalInput will include the next\n        // line. We don't want this in indent, so we go back a line.\n        endLine--;\n      }\n      cm.pushUndoStop();\n      for (var i = startLine; i <= endLine; i++) {\n        for (var j = 0; j < repeat; j++) {\n          cm.indentLine(i, args.indentRight);\n        }\n      }\n      cm.pushUndoStop();\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    indentAuto: function (cm, _args, ranges) {\n      cm.execCommand(\"indentAuto\");\n      return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);\n    },\n    changeCase: function (cm, args, ranges, oldAnchor, newHead) {\n      var selections = cm.getSelections();\n      var swapped = [];\n      var toLower = args.toLower;\n      for (var j = 0; j < selections.length; j++) {\n        var toSwap = selections[j];\n        var text = \"\";\n        if (toLower === true) {\n          text = toSwap.toLowerCase();\n        } else if (toLower === false) {\n          text = toSwap.toUpperCase();\n        } else {\n          for (var i = 0; i < toSwap.length; i++) {\n            var character = toSwap.charAt(i);\n            text += isUpperCase(character)\n              ? character.toLowerCase()\n              : character.toUpperCase();\n          }\n        }\n        swapped.push(text);\n      }\n      cm.replaceSelections(swapped);\n      if (args.shouldMoveCursor) {\n        return newHead;\n      } else if (\n        !cm.state.vim.visualMode &&\n        args.linewise &&\n        ranges[0].anchor.line + 1 == ranges[0].head.line\n      ) {\n        return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);\n      } else if (args.linewise) {\n        return oldAnchor;\n      } else {\n        return cursorMin(ranges[0].anchor, ranges[0].head);\n      }\n    },\n    yank: function (cm, args, ranges, oldAnchor) {\n      var vim = cm.state.vim;\n      var text = cm.getSelection();\n      var endPos = vim.visualMode\n        ? cursorMin(\n            vim.sel.anchor,\n            vim.sel.head,\n            ranges[0].head,\n            ranges[0].anchor\n          )\n        : oldAnchor;\n      vimGlobalState.registerController.pushText(\n        args.registerName,\n        \"yank\",\n        text,\n        args.linewise,\n        vim.visualBlock\n      );\n      return endPos;\n    },\n  };\n\n  function defineOperator(name, fn) {\n    operators[name] = fn;\n  }\n\n  var actions = {\n    jumpListWalk: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      var forward = actionArgs.forward;\n      var jumpList = vimGlobalState.jumpList;\n\n      var mark = jumpList.move(cm, forward ? repeat : -repeat);\n      var markPos = mark ? mark.find() : undefined;\n      markPos = markPos ? markPos : cm.getCursor();\n      cm.setCursor(markPos);\n    },\n    scroll: function (cm, actionArgs, vim) {\n      if (vim.visualMode) {\n        return;\n      }\n      var repeat = actionArgs.repeat || 1;\n      var lineHeight = cm.defaultTextHeight();\n      var top = cm.getScrollInfo().top;\n      var delta = lineHeight * repeat;\n      var newPos = actionArgs.forward ? top + delta : top - delta;\n      var cursor = copyCursor(cm.getCursor());\n      var cursorCoords = cm.charCoords(cursor, \"local\");\n      if (actionArgs.forward) {\n        if (newPos > cursorCoords.top) {\n          cursor.line += (newPos - cursorCoords.top) / lineHeight;\n          cursor.line = Math.ceil(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, \"local\");\n          cm.scrollTo(null, cursorCoords.top);\n        } else {\n          // Cursor stays within bounds.  Just reposition the scroll window.\n          cm.scrollTo(null, newPos);\n        }\n      } else {\n        var newBottom = newPos + cm.getScrollInfo().clientHeight;\n        if (newBottom < cursorCoords.bottom) {\n          cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;\n          cursor.line = Math.floor(cursor.line);\n          cm.setCursor(cursor);\n          cursorCoords = cm.charCoords(cursor, \"local\");\n          cm.scrollTo(\n            null,\n            cursorCoords.bottom - cm.getScrollInfo().clientHeight\n          );\n        } else {\n          // Cursor stays within bounds.  Just reposition the scroll window.\n          cm.scrollTo(null, newPos);\n        }\n      }\n    },\n    scrollToCursor: function (cm, actionArgs) {\n      var lineNum = cm.getCursor().line;\n      var charCoords = cm.charCoords(new Pos(lineNum, 0), \"local\");\n      var height = cm.getScrollInfo().clientHeight;\n      var y = charCoords.top;\n      var lineHeight = charCoords.bottom - y;\n      switch (actionArgs.position) {\n        case \"center\":\n          y = y - height / 2 + lineHeight;\n          break;\n        case \"bottom\":\n          y = y - height + lineHeight;\n          break;\n      }\n      // cm.scrollTo(null, y);\n      cm.moveCurrentLineTo(y);\n    },\n    replayMacro: function (cm, actionArgs, vim) {\n      var registerName = actionArgs.selectedCharacter;\n      var repeat = actionArgs.repeat;\n      var macroModeState = vimGlobalState.macroModeState;\n      if (registerName == \"@\") {\n        registerName = macroModeState.latestRegister;\n      } else {\n        macroModeState.latestRegister = registerName;\n      }\n      while (repeat--) {\n        executeMacroRegister(cm, vim, macroModeState, registerName);\n      }\n    },\n    enterMacroRecordMode: function (cm, actionArgs) {\n      var macroModeState = vimGlobalState.macroModeState;\n      var registerName = actionArgs.selectedCharacter;\n      if (vimGlobalState.registerController.isValidRegister(registerName)) {\n        macroModeState.enterMacroRecordMode(cm, registerName);\n      }\n    },\n    toggleOverwrite: function (cm) {\n      if (!cm.state.overwrite) {\n        cm.toggleOverwrite(true);\n        cm.setOption(\"keyMap\", \"vim-replace\");\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"replace\" });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption(\"keyMap\", \"vim-insert\");\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"insert\" });\n      }\n    },\n    enterInsertMode: function (cm, actionArgs, vim) {\n      if (cm.getOption(\"readOnly\")) {\n        return;\n      }\n      vim.insertMode = true;\n      vim.insertModeRepeat = (actionArgs && actionArgs.repeat) || 1;\n      var insertAt = actionArgs ? actionArgs.insertAt : null;\n      var sel = vim.sel;\n      var head = actionArgs.head || cm.getCursor(\"head\");\n      var height = cm.listSelections().length;\n      if (insertAt == \"eol\") {\n        head = new Pos(head.line, lineLength(cm, head.line));\n      } else if (insertAt == \"bol\") {\n        head = new Pos(head.line, 0);\n      } else if (insertAt == \"charAfter\") {\n        head = offsetCursor(head, 0, 1);\n      } else if (insertAt == \"firstNonBlank\") {\n        head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);\n      } else if (insertAt == \"startOfSelectedArea\") {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line < sel.anchor.line) {\n            head = sel.head;\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(\n            Math.min(sel.head.line, sel.anchor.line),\n            Math.min(sel.head.ch, sel.anchor.ch)\n          );\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == \"endOfSelectedArea\") {\n        if (!vim.visualMode) return;\n        if (!vim.visualBlock) {\n          if (sel.head.line >= sel.anchor.line) {\n            head = offsetCursor(sel.head, 0, 1);\n          } else {\n            head = new Pos(sel.anchor.line, 0);\n          }\n        } else {\n          head = new Pos(\n            Math.min(sel.head.line, sel.anchor.line),\n            Math.max(sel.head.ch, sel.anchor.ch) + 1\n          );\n          height = Math.abs(sel.head.line - sel.anchor.line) + 1;\n        }\n      } else if (insertAt == \"inplace\") {\n        if (vim.visualMode) {\n          return;\n        }\n      } else if (insertAt == \"lastEdit\") {\n        head = getLastEditPos(cm) || head;\n      }\n      cm.setOption(\"disableInput\", false);\n      if (actionArgs && actionArgs.replace) {\n        // Handle Replace-mode as a special case of insert mode.\n        cm.toggleOverwrite(true);\n        cm.setOption(\"keyMap\", \"vim-replace\");\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"replace\" });\n      } else {\n        cm.toggleOverwrite(false);\n        cm.setOption(\"keyMap\", \"vim-insert\");\n        CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"insert\" });\n      }\n      if (!vimGlobalState.macroModeState.isPlaying) {\n        // Only record if not replaying.\n        cm.on(\"change\", onChange);\n        CodeMirror.on(cm.getInputField(), \"keydown\", onKeyEventTargetKeyDown);\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      selectForInsert(cm, head, height);\n    },\n    toggleVisualMode: function (cm, actionArgs, vim) {\n      var repeat = actionArgs.repeat;\n      var anchor = cm.getCursor();\n      var head;\n      // TODO: The repeat should actually select number of characters/lines\n      //     equal to the repeat times the size of the previous visual\n      //     operation.\n      if (!vim.visualMode) {\n        // Entering visual mode\n        vim.visualMode = true;\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        head = clipCursorToContent(\n          cm,\n          new Pos(anchor.line, anchor.ch + repeat - 1)\n        );\n        vim.sel = {\n          anchor: anchor,\n          head: head,\n        };\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine\n            ? \"linewise\"\n            : vim.visualBlock\n            ? \"blockwise\"\n            : \"\",\n        });\n        updateCmSelection(cm);\n        updateMark(cm, vim, \"<\", cursorMin(anchor, head));\n        updateMark(cm, vim, \">\", cursorMax(anchor, head));\n      } else if (\n        vim.visualLine ^ actionArgs.linewise ||\n        vim.visualBlock ^ actionArgs.blockwise\n      ) {\n        // Toggling between modes\n        vim.visualLine = !!actionArgs.linewise;\n        vim.visualBlock = !!actionArgs.blockwise;\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine\n            ? \"linewise\"\n            : vim.visualBlock\n            ? \"blockwise\"\n            : \"\",\n        });\n        updateCmSelection(cm);\n      } else {\n        exitVisualMode(cm);\n      }\n    },\n    reselectLastSelection: function (cm, _actionArgs, vim) {\n      var lastSelection = vim.lastSelection;\n      if (vim.visualMode) {\n        updateLastSelection(cm, vim);\n      }\n      if (lastSelection) {\n        var anchor = lastSelection.anchorMark.find();\n        var head = lastSelection.headMark.find();\n        if (!anchor || !head) {\n          // If the marks have been destroyed due to edits, do nothing.\n          return;\n        }\n        vim.sel = {\n          anchor: anchor,\n          head: head,\n        };\n        vim.visualMode = true;\n        vim.visualLine = lastSelection.visualLine;\n        vim.visualBlock = lastSelection.visualBlock;\n        updateCmSelection(cm);\n        updateMark(cm, vim, \"<\", cursorMin(anchor, head));\n        updateMark(cm, vim, \">\", cursorMax(anchor, head));\n        CodeMirror.signal(cm, \"vim-mode-change\", {\n          mode: \"visual\",\n          subMode: vim.visualLine\n            ? \"linewise\"\n            : vim.visualBlock\n            ? \"blockwise\"\n            : \"\",\n        });\n      }\n    },\n    joinLines: function (cm, actionArgs, vim) {\n      var curStart, curEnd;\n      if (vim.visualMode) {\n        curStart = cm.getCursor(\"anchor\");\n        curEnd = cm.getCursor(\"head\");\n        if (cursorIsBefore(curEnd, curStart)) {\n          var tmp = curEnd;\n          curEnd = curStart;\n          curStart = tmp;\n        }\n        curEnd.ch = lineLength(cm, curEnd.line) - 1;\n      } else {\n        // Repeat is the number of lines to join. Minimum 2 lines.\n        var repeat = Math.max(actionArgs.repeat, 2);\n        curStart = cm.getCursor();\n        curEnd = clipCursorToContent(\n          cm,\n          new Pos(curStart.line + repeat - 1, Infinity)\n        );\n      }\n      var finalCh = 0;\n      for (var i = curStart.line; i < curEnd.line; i++) {\n        finalCh = lineLength(cm, curStart.line);\n        var tmp = new Pos(curStart.line + 1, lineLength(cm, curStart.line + 1));\n        var text = cm.getRange(curStart, tmp);\n        text = actionArgs.keepSpaces\n          ? text.replace(/\\n\\r?/g, \"\")\n          : text.replace(/\\n\\s*/g, \" \");\n        cm.replaceRange(text, curStart, tmp);\n      }\n      var curFinalPos = new Pos(curStart.line, finalCh);\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curFinalPos);\n    },\n    newLineAndEnterInsertMode: function (cm, actionArgs, vim) {\n      if (cm.getOption(\"readOnly\")) {\n        return;\n      }\n      vim.insertMode = true;\n      var insertAt = copyCursor(cm.getCursor());\n      if (insertAt.line === cm.firstLine() && !actionArgs.after) {\n        // Special case for inserting newline before start of document.\n        cm.replaceRange(\"\\n\", new Pos(cm.firstLine(), 0));\n        cm.setCursor(cm.firstLine(), 0);\n      } else {\n        insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;\n        insertAt.ch = lineLength(cm, insertAt.line);\n        cm.setCursor(insertAt);\n        var newlineFn =\n          CodeMirror.commands.newlineAndIndentContinueComment ||\n          CodeMirror.commands.newlineAndIndent;\n        newlineFn(cm);\n      }\n      this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);\n    },\n    paste: function (cm, actionArgs, vim) {\n      var cur = copyCursor(cm.getCursor());\n      var register = vimGlobalState.registerController.getRegister(\n        actionArgs.registerName\n      );\n      var text = register.toString();\n      if (!text) {\n        return;\n      }\n      if (actionArgs.matchIndent) {\n        var tabSize = cm.getOption(\"tabSize\");\n        // length that considers tabs and tabSize\n        var whitespaceLength = function (str) {\n          var tabs = str.split(\"\\t\").length - 1;\n          var spaces = str.split(\" \").length - 1;\n          return tabs * tabSize + spaces * 1;\n        };\n        var currentLine = cm.getLine(cm.getCursor().line);\n        var indent = whitespaceLength(currentLine.match(/^\\s*/)[0]);\n        // chomp last newline b/c don't want it to match /^\\s*/gm\n        var chompedText = text.replace(/\\n$/, \"\");\n        var wasChomped = text !== chompedText;\n        var firstIndent = whitespaceLength(text.match(/^\\s*/)[0]);\n        var text = chompedText.replace(/^\\s*/gm, function (wspace) {\n          var newIndent = indent + (whitespaceLength(wspace) - firstIndent);\n          if (newIndent < 0) {\n            return \"\";\n          } else if (cm.getOption(\"indentWithTabs\")) {\n            var quotient = Math.floor(newIndent / tabSize);\n            return Array(quotient + 1).join(\"\\t\");\n          } else {\n            return Array(newIndent + 1).join(\" \");\n          }\n        });\n        text += wasChomped ? \"\\n\" : \"\";\n      }\n      if (actionArgs.repeat > 1) {\n        var text = Array(actionArgs.repeat + 1).join(text);\n      }\n      var linewise = register.linewise;\n      var blockwise = register.blockwise;\n      if (blockwise) {\n        text = text.split(\"\\n\");\n        if (linewise) {\n          text.pop();\n        }\n        for (var i = 0; i < text.length; i++) {\n          text[i] = text[i] == \"\" ? \" \" : text[i];\n        }\n        cur.ch += actionArgs.after ? 1 : 0;\n        cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);\n      } else if (linewise) {\n        if (vim.visualMode) {\n          text = vim.visualLine\n            ? text.slice(0, -1)\n            : \"\\n\" + text.slice(0, text.length - 1) + \"\\n\";\n        } else if (actionArgs.after) {\n          // Move the newline at the end to the start instead, and paste just\n          // before the newline character of the line we are on right now.\n          text = \"\\n\" + text.slice(0, text.length - 1);\n          cur.ch = lineLength(cm, cur.line);\n        } else {\n          cur.ch = 0;\n        }\n      } else {\n        cur.ch += actionArgs.after ? 1 : 0;\n      }\n      var curPosFinal;\n      var idx;\n      if (vim.visualMode) {\n        //  save the pasted text for reselection if the need arises\n        vim.lastPastedText = text;\n        var lastSelectionCurEnd;\n        var selectedArea = getSelectedAreaRange(cm, vim);\n        var selectionStart = selectedArea[0];\n        var selectionEnd = selectedArea[1];\n        var selectedText = cm.getSelection();\n        var selections = cm.listSelections();\n        var emptyStrings = new Array(selections.length).join(\"1\").split(\"1\");\n        // save the curEnd marker before it get cleared due to cm.replaceRange.\n        if (vim.lastSelection) {\n          lastSelectionCurEnd = vim.lastSelection.headMark.find();\n        }\n        // push the previously selected text to unnamed register\n        vimGlobalState.registerController.unnamedRegister.setText(selectedText);\n        if (blockwise) {\n          // first delete the selected text\n          cm.replaceSelections(emptyStrings);\n          // Set new selections as per the block length of the yanked text\n          selectionEnd = new Pos(\n            selectionStart.line + text.length - 1,\n            selectionStart.ch\n          );\n          cm.setCursor(selectionStart);\n          selectBlock(cm, selectionEnd);\n          cm.replaceSelections(text);\n          curPosFinal = selectionStart;\n        } else if (vim.visualBlock) {\n          cm.replaceSelections(emptyStrings);\n          cm.setCursor(selectionStart);\n          cm.replaceRange(text, selectionStart, selectionStart);\n          curPosFinal = selectionStart;\n        } else {\n          cm.replaceRange(text, selectionStart, selectionEnd);\n          curPosFinal = cm.posFromIndex(\n            cm.indexFromPos(selectionStart) + text.length - 1\n          );\n        }\n        // restore the the curEnd marker\n        if (lastSelectionCurEnd) {\n          vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);\n        }\n        if (linewise) {\n          curPosFinal.ch = 0;\n        }\n      } else {\n        if (blockwise) {\n          cm.setCursor(cur);\n          for (var i = 0; i < text.length; i++) {\n            var line = cur.line + i;\n            if (line > cm.lastLine()) {\n              cm.replaceRange(\"\\n\", new Pos(line, 0));\n            }\n            var lastCh = lineLength(cm, line);\n            if (lastCh < cur.ch) {\n              extendLineToColumn(cm, line, cur.ch);\n            }\n          }\n          cm.setCursor(cur);\n          selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));\n          cm.replaceSelections(text);\n          curPosFinal = cur;\n        } else {\n          cm.replaceRange(text, cur);\n          // Now fine tune the cursor to where we want it.\n          if (linewise && actionArgs.after) {\n            curPosFinal = new Pos(\n              cur.line + 1,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1))\n            );\n          } else if (linewise && !actionArgs.after) {\n            curPosFinal = new Pos(\n              cur.line,\n              findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line))\n            );\n          } else if (!linewise && actionArgs.after) {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length - 1);\n          } else {\n            idx = cm.indexFromPos(cur);\n            curPosFinal = cm.posFromIndex(idx + text.length);\n          }\n        }\n      }\n      if (vim.visualMode) {\n        exitVisualMode(cm, false);\n      }\n      cm.setCursor(curPosFinal);\n    },\n    undo: function (cm, actionArgs) {\n      cm.operation(function () {\n        repeatFn(cm, CodeMirror.commands.undo, actionArgs.repeat)();\n        cm.setCursor(cm.getCursor(\"anchor\"));\n      });\n    },\n    redo: function (cm, actionArgs) {\n      repeatFn(cm, CodeMirror.commands.redo, actionArgs.repeat)();\n    },\n    setRegister: function (_cm, actionArgs, vim) {\n      vim.inputState.registerName = actionArgs.selectedCharacter;\n    },\n    setMark: function (cm, actionArgs, vim) {\n      var markName = actionArgs.selectedCharacter;\n      updateMark(cm, vim, markName, cm.getCursor());\n    },\n    replace: function (cm, actionArgs, vim) {\n      var replaceWith = actionArgs.selectedCharacter;\n      var curStart = cm.getCursor();\n      var replaceTo;\n      var curEnd;\n      var selections = cm.listSelections();\n      if (vim.visualMode) {\n        curStart = cm.getCursor(\"start\");\n        curEnd = cm.getCursor(\"end\");\n      } else {\n        var line = cm.getLine(curStart.line);\n        replaceTo = curStart.ch + actionArgs.repeat;\n        if (replaceTo > line.length) {\n          replaceTo = line.length;\n        }\n        curEnd = new Pos(curStart.line, replaceTo);\n      }\n      if (replaceWith == \"\\n\") {\n        if (!vim.visualMode) cm.replaceRange(\"\", curStart, curEnd);\n        // special case, where vim help says to replace by just one line-break\n        (\n          CodeMirror.commands.newlineAndIndentContinueComment ||\n          CodeMirror.commands.newlineAndIndent\n        )(cm);\n      } else {\n        var replaceWithStr = cm.getRange(curStart, curEnd);\n        //replace all characters in range by selected, but keep linebreaks\n        replaceWithStr = replaceWithStr.replace(/[^\\n]/g, replaceWith);\n        if (vim.visualBlock) {\n          // Tabs are split in visua block before replacing\n          var spaces = new Array(cm.getOption(\"tabSize\") + 1).join(\" \");\n          replaceWithStr = cm.getSelection();\n          replaceWithStr = replaceWithStr\n            .replace(/\\t/g, spaces)\n            .replace(/[^\\n]/g, replaceWith)\n            .split(\"\\n\");\n          cm.replaceSelections(replaceWithStr);\n        } else {\n          cm.replaceRange(replaceWithStr, curStart, curEnd);\n        }\n        if (vim.visualMode) {\n          curStart = cursorIsBefore(selections[0].anchor, selections[0].head)\n            ? selections[0].anchor\n            : selections[0].head;\n          cm.setCursor(curStart);\n          exitVisualMode(cm, false);\n        } else {\n          cm.setCursor(offsetCursor(curEnd, 0, -1));\n        }\n      }\n    },\n    incrementNumberToken: function (cm, actionArgs) {\n      var cur = cm.getCursor();\n      var lineStr = cm.getLine(cur.line);\n      var re = /(-?)(?:(0x)([\\da-f]+)|(0b|0|)(\\d+))/gi;\n      var match;\n      var start;\n      var end;\n      var numberStr;\n      while ((match = re.exec(lineStr)) !== null) {\n        start = match.index;\n        end = start + match[0].length;\n        if (cur.ch < end) break;\n      }\n      if (!actionArgs.backtrack && end <= cur.ch) return;\n      if (match) {\n        var baseStr = match[2] || match[4];\n        var digits = match[3] || match[5];\n        var increment = actionArgs.increase ? 1 : -1;\n        var base = { \"0b\": 2, 0: 8, \"\": 10, \"0x\": 16 }[baseStr.toLowerCase()];\n        var number =\n          parseInt(match[1] + digits, base) + increment * actionArgs.repeat;\n        numberStr = number.toString(base);\n        var zeroPadding = baseStr\n          ? new Array(\n              digits.length - numberStr.length + 1 + match[1].length\n            ).join(\"0\")\n          : \"\";\n        if (numberStr.charAt(0) === \"-\") {\n          numberStr = \"-\" + baseStr + zeroPadding + numberStr.substr(1);\n        } else {\n          numberStr = baseStr + zeroPadding + numberStr;\n        }\n        var from = new Pos(cur.line, start);\n        var to = new Pos(cur.line, end);\n        cm.replaceRange(numberStr, from, to);\n      } else {\n        return;\n      }\n      cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));\n    },\n    repeatLastEdit: function (cm, actionArgs, vim) {\n      var lastEditInputState = vim.lastEditInputState;\n      if (!lastEditInputState) {\n        return;\n      }\n      var repeat = actionArgs.repeat;\n      if (repeat && actionArgs.repeatIsExplicit) {\n        vim.lastEditInputState.repeatOverride = repeat;\n      } else {\n        repeat = vim.lastEditInputState.repeatOverride || repeat;\n      }\n      repeatLastEdit(cm, vim, repeat, false /** repeatForInsert */);\n    },\n    indent: function (cm, actionArgs) {\n      cm.indentLine(cm.getCursor().line, actionArgs.indentRight);\n    },\n    exitInsertMode: exitInsertMode,\n  };\n\n  function defineAction(name, fn) {\n    actions[name] = fn;\n  }\n\n  /*\n   * Below are miscellaneous utility functions used by vim.js\n   */\n\n  /**\n   * Clips cursor to ensure that line is within the buffer's range\n   * If includeLineBreak is true, then allow cur.ch == lineLength.\n   */\n  function clipCursorToContent(cm, cur) {\n    var vim = cm.state.vim;\n    var includeLineBreak = vim.insertMode || vim.visualMode;\n    var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());\n    var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;\n    var ch = Math.min(Math.max(0, cur.ch), maxCh);\n    return new Pos(line, ch);\n  }\n  function copyArgs(args) {\n    var ret = {};\n    for (var prop in args) {\n      if (args.hasOwnProperty(prop)) {\n        ret[prop] = args[prop];\n      }\n    }\n    return ret;\n  }\n  function offsetCursor(cur, offsetLine, offsetCh) {\n    if (typeof offsetLine === \"object\") {\n      offsetCh = offsetLine.ch;\n      offsetLine = offsetLine.line;\n    }\n    return new Pos(cur.line + offsetLine, cur.ch + offsetCh);\n  }\n  function commandMatches(keys, keyMap, context, inputState) {\n    // Partial matches are not applied. They inform the key handler\n    // that the current key sequence is a subsequence of a valid key\n    // sequence, so that the key buffer is not cleared.\n    var match,\n      partial = [],\n      full = [];\n    for (var i = 0; i < keyMap.length; i++) {\n      var command = keyMap[i];\n      if (\n        (context == \"insert\" && command.context != \"insert\") ||\n        (command.context && command.context != context) ||\n        (inputState.operator && command.type == \"action\") ||\n        !(match = commandMatch(keys, command.keys))\n      ) {\n        continue;\n      }\n      if (match == \"partial\") {\n        partial.push(command);\n      }\n      if (match == \"full\") {\n        full.push(command);\n      }\n    }\n    return {\n      partial: partial.length && partial,\n      full: full.length && full,\n    };\n  }\n  function commandMatch(pressed, mapped) {\n    if (mapped.slice(-11) == \"<character>\") {\n      // Last character matches anything.\n      var prefixLen = mapped.length - 11;\n      var pressedPrefix = pressed.slice(0, prefixLen);\n      var mappedPrefix = mapped.slice(0, prefixLen);\n      return pressedPrefix == mappedPrefix && pressed.length > prefixLen\n        ? \"full\"\n        : mappedPrefix.indexOf(pressedPrefix) == 0\n        ? \"partial\"\n        : false;\n    } else {\n      return pressed == mapped\n        ? \"full\"\n        : mapped.indexOf(pressed) == 0\n        ? \"partial\"\n        : false;\n    }\n  }\n  function lastChar(keys) {\n    var match = /^.*(<[^>]+>)$/.exec(keys);\n    var selectedCharacter = match ? match[1] : keys.slice(-1);\n    if (selectedCharacter.length > 1) {\n      switch (selectedCharacter) {\n        case \"<CR>\":\n          selectedCharacter = \"\\n\";\n          break;\n        case \"<Space>\":\n          selectedCharacter = \" \";\n          break;\n        default:\n          selectedCharacter = \"\";\n          break;\n      }\n    }\n    return selectedCharacter;\n  }\n  function repeatFn(cm, fn, repeat) {\n    return function () {\n      for (var i = 0; i < repeat; i++) {\n        fn(cm);\n      }\n    };\n  }\n  function copyCursor(cur) {\n    return new Pos(cur.line, cur.ch);\n  }\n  function cursorEqual(cur1, cur2) {\n    return cur1.ch == cur2.ch && cur1.line == cur2.line;\n  }\n  function cursorIsBefore(cur1, cur2) {\n    if (cur1.line < cur2.line) {\n      return true;\n    }\n    if (cur1.line == cur2.line && cur1.ch < cur2.ch) {\n      return true;\n    }\n    return false;\n  }\n  function cursorMin(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMin.apply(\n        undefined,\n        Array.prototype.slice.call(arguments, 1)\n      );\n    }\n    return cursorIsBefore(cur1, cur2) ? cur1 : cur2;\n  }\n  function cursorMax(cur1, cur2) {\n    if (arguments.length > 2) {\n      cur2 = cursorMax.apply(\n        undefined,\n        Array.prototype.slice.call(arguments, 1)\n      );\n    }\n    return cursorIsBefore(cur1, cur2) ? cur2 : cur1;\n  }\n  function cursorIsBetween(cur1, cur2, cur3) {\n    // returns true if cur2 is between cur1 and cur3.\n    var cur1before2 = cursorIsBefore(cur1, cur2);\n    var cur2before3 = cursorIsBefore(cur2, cur3);\n    return cur1before2 && cur2before3;\n  }\n  function lineLength(cm, lineNum) {\n    return cm.getLine(lineNum).length;\n  }\n  function trim(s) {\n    if (s.trim) {\n      return s.trim();\n    }\n    return s.replace(/^\\s+|\\s+$/g, \"\");\n  }\n  function escapeRegex(s) {\n    return s.replace(/([.?*+$\\[\\]\\/\\\\(){}|\\-])/g, \"\\\\$1\");\n  }\n  function extendLineToColumn(cm, lineNum, column) {\n    var endCh = lineLength(cm, lineNum);\n    var spaces = new Array(column - endCh + 1).join(\" \");\n    cm.setCursor(new Pos(lineNum, endCh));\n    cm.replaceRange(spaces, cm.getCursor());\n  }\n  // This functions selects a rectangular block\n  // of text with selectionEnd as any of its corner\n  // Height of block:\n  // Difference in selectionEnd.line and first/last selection.line\n  // Width of the block:\n  // Distance between selectionEnd.ch and any(first considered here) selection.ch\n  function selectBlock(cm, selectionEnd) {\n    var selections = [],\n      ranges = cm.listSelections();\n    var head = copyCursor(cm.clipPos(selectionEnd));\n    var isClipped = !cursorEqual(selectionEnd, head);\n    var curHead = cm.getCursor(\"head\");\n    var primIndex = getIndex(ranges, curHead);\n    var wasClipped = cursorEqual(\n      ranges[primIndex].head,\n      ranges[primIndex].anchor\n    );\n    var max = ranges.length - 1;\n    var index = max - primIndex > primIndex ? max : 0;\n    var base = ranges[index].anchor;\n\n    var firstLine = Math.min(base.line, head.line);\n    var lastLine = Math.max(base.line, head.line);\n    var baseCh = base.ch,\n      headCh = head.ch;\n\n    var dir = ranges[index].head.ch - baseCh;\n    var newDir = headCh - baseCh;\n    if (dir > 0 && newDir <= 0) {\n      baseCh++;\n      if (!isClipped) {\n        headCh--;\n      }\n    } else if (dir < 0 && newDir >= 0) {\n      baseCh--;\n      if (!wasClipped) {\n        headCh++;\n      }\n    } else if (dir < 0 && newDir == -1) {\n      baseCh--;\n      headCh++;\n    }\n    for (var line = firstLine; line <= lastLine; line++) {\n      var range = {\n        anchor: new Pos(line, baseCh),\n        head: new Pos(line, headCh),\n      };\n      selections.push(range);\n    }\n    cm.setSelections(selections);\n    selectionEnd.ch = headCh;\n    base.ch = baseCh;\n    return base;\n  }\n  function selectForInsert(cm, head, height) {\n    var sel = [];\n    for (var i = 0; i < height; i++) {\n      var lineHead = offsetCursor(head, i, 0);\n      sel.push({ anchor: lineHead, head: lineHead });\n    }\n    cm.setSelections(sel, 0);\n  }\n  // getIndex returns the index of the cursor in the selections.\n  function getIndex(ranges, cursor, end) {\n    for (var i = 0; i < ranges.length; i++) {\n      var atAnchor = end != \"head\" && cursorEqual(ranges[i].anchor, cursor);\n      var atHead = end != \"anchor\" && cursorEqual(ranges[i].head, cursor);\n      if (atAnchor || atHead) {\n        return i;\n      }\n    }\n    return -1;\n  }\n  function getSelectedAreaRange(cm, vim) {\n    var lastSelection = vim.lastSelection;\n    var getCurrentSelectedAreaRange = function () {\n      var selections = cm.listSelections();\n      var start = selections[0];\n      var end = selections[selections.length - 1];\n      var selectionStart = cursorIsBefore(start.anchor, start.head)\n        ? start.anchor\n        : start.head;\n      var selectionEnd = cursorIsBefore(end.anchor, end.head)\n        ? end.head\n        : end.anchor;\n      return [selectionStart, selectionEnd];\n    };\n    var getLastSelectedAreaRange = function () {\n      var selectionStart = cm.getCursor();\n      var selectionEnd = cm.getCursor();\n      var block = lastSelection.visualBlock;\n      if (block) {\n        var width = block.width;\n        var height = block.height;\n        selectionEnd = new Pos(\n          selectionStart.line + height,\n          selectionStart.ch + width\n        );\n        var selections = [];\n        // selectBlock creates a 'proper' rectangular block.\n        // We do not want that in all cases, so we manually set selections.\n        for (var i = selectionStart.line; i < selectionEnd.line; i++) {\n          var anchor = new Pos(i, selectionStart.ch);\n          var head = new Pos(i, selectionEnd.ch);\n          var range = { anchor: anchor, head: head };\n          selections.push(range);\n        }\n        cm.setSelections(selections);\n      } else {\n        var start = lastSelection.anchorMark.find();\n        var end = lastSelection.headMark.find();\n        var line = end.line - start.line;\n        var ch = end.ch - start.ch;\n        selectionEnd = {\n          line: selectionEnd.line + line,\n          ch: line ? selectionEnd.ch : ch + selectionEnd.ch,\n        };\n        if (lastSelection.visualLine) {\n          selectionStart = new Pos(selectionStart.line, 0);\n          selectionEnd = new Pos(\n            selectionEnd.line,\n            lineLength(cm, selectionEnd.line)\n          );\n        }\n        cm.setSelection(selectionStart, selectionEnd);\n      }\n      return [selectionStart, selectionEnd];\n    };\n    if (!vim.visualMode) {\n      // In case of replaying the action.\n      return getLastSelectedAreaRange();\n    } else {\n      return getCurrentSelectedAreaRange();\n    }\n  }\n  // Updates the previous selection with the current selection's values. This\n  // should only be called in visual mode.\n  function updateLastSelection(cm, vim) {\n    var anchor = vim.sel.anchor;\n    var head = vim.sel.head;\n    // To accommodate the effect of lastPastedText in the last selection\n    if (vim.lastPastedText) {\n      head = cm.posFromIndex(\n        cm.indexFromPos(anchor) + vim.lastPastedText.length\n      );\n      vim.lastPastedText = null;\n    }\n    vim.lastSelection = {\n      anchorMark: cm.setBookmark(anchor),\n      headMark: cm.setBookmark(head),\n      anchor: copyCursor(anchor),\n      head: copyCursor(head),\n      visualMode: vim.visualMode,\n      visualLine: vim.visualLine,\n      visualBlock: vim.visualBlock,\n    };\n  }\n  function expandSelection(cm, start, end) {\n    var sel = cm.state.vim.sel;\n    var head = sel.head;\n    var anchor = sel.anchor;\n    var tmp;\n    if (cursorIsBefore(end, start)) {\n      tmp = end;\n      end = start;\n      start = tmp;\n    }\n    if (cursorIsBefore(head, anchor)) {\n      head = cursorMin(start, head);\n      anchor = cursorMax(anchor, end);\n    } else {\n      anchor = cursorMin(start, anchor);\n      head = cursorMax(head, end);\n      head = offsetCursor(head, 0, -1);\n      if (head.ch == -1 && head.line != cm.firstLine()) {\n        head = new Pos(head.line - 1, lineLength(cm, head.line - 1));\n      }\n    }\n    return [anchor, head];\n  }\n  /**\n   * Updates the CodeMirror selection to match the provided vim selection.\n   * If no arguments are given, it uses the current vim selection state.\n   */\n  function updateCmSelection(cm, sel, mode) {\n    var vim = cm.state.vim;\n    sel = sel || vim.sel;\n    var mode =\n      mode || vim.visualLine ? \"line\" : vim.visualBlock ? \"block\" : \"char\";\n    var cmSel = makeCmSelection(cm, sel, mode);\n    cm.setSelections(cmSel.ranges, cmSel.primary);\n  }\n  function makeCmSelection(cm, sel, mode, exclusive) {\n    var head = copyCursor(sel.head);\n    var anchor = copyCursor(sel.anchor);\n    if (mode == \"char\") {\n      var headOffset =\n        !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;\n      head = offsetCursor(sel.head, 0, headOffset);\n      anchor = offsetCursor(sel.anchor, 0, anchorOffset);\n      return {\n        ranges: [{ anchor: anchor, head: head }],\n        primary: 0,\n      };\n    } else if (mode == \"line\") {\n      if (!cursorIsBefore(sel.head, sel.anchor)) {\n        anchor.ch = 0;\n\n        var lastLine = cm.lastLine();\n        if (head.line > lastLine) {\n          head.line = lastLine;\n        }\n        head.ch = lineLength(cm, head.line);\n      } else {\n        head.ch = 0;\n        anchor.ch = lineLength(cm, anchor.line);\n      }\n      return {\n        ranges: [{ anchor: anchor, head: head }],\n        primary: 0,\n      };\n    } else if (mode == \"block\") {\n      var top = Math.min(anchor.line, head.line),\n        fromCh = anchor.ch,\n        bottom = Math.max(anchor.line, head.line),\n        toCh = head.ch;\n      if (fromCh < toCh) {\n        toCh += 1;\n      } else {\n        fromCh += 1;\n      }\n      var height = bottom - top + 1;\n      var primary = head.line == top ? 0 : height - 1;\n      var ranges = [];\n      for (var i = 0; i < height; i++) {\n        ranges.push({\n          anchor: new Pos(top + i, fromCh),\n          head: new Pos(top + i, toCh),\n        });\n      }\n      return {\n        ranges: ranges,\n        primary: primary,\n      };\n    }\n  }\n  function getHead(cm) {\n    var cur = cm.getCursor(\"head\");\n    if (cm.getSelection().length == 1) {\n      // Small corner case when only 1 character is selected. The \"real\"\n      // head is the left of head and anchor.\n      cur = cursorMin(cur, cm.getCursor(\"anchor\"));\n    }\n    return cur;\n  }\n\n  /**\n   * If moveHead is set to false, the CodeMirror selection will not be\n   * touched. The caller assumes the responsibility of putting the cursor\n   * in the right place.\n   */\n  function exitVisualMode(cm, moveHead) {\n    var vim = cm.state.vim;\n    if (moveHead !== false) {\n      cm.setCursor(clipCursorToContent(cm, vim.sel.head));\n    }\n    updateLastSelection(cm, vim);\n    vim.visualMode = false;\n    vim.visualLine = false;\n    vim.visualBlock = false;\n    if (!vim.insertMode)\n      CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n  }\n\n  // Remove any trailing newlines from the selection. For\n  // example, with the caret at the start of the last word on the line,\n  // 'dw' should word, but not the newline, while 'w' should advance the\n  // caret to the first character of the next line.\n  function clipToLine(cm, curStart, curEnd) {\n    var selection = cm.getRange(curStart, curEnd);\n    // Only clip if the selection ends with trailing newline + whitespace\n    if (/\\n\\s*$/.test(selection)) {\n      var lines = selection.split(\"\\n\");\n      // We know this is all whitespace.\n      lines.pop();\n\n      // Cases:\n      // 1. Last word is an empty line - do not clip the trailing '\\n'\n      // 2. Last word is not an empty line - clip the trailing '\\n'\n      var line;\n      // Find the line containing the last word, and clip all whitespace up\n      // to it.\n      for (\n        var line = lines.pop();\n        lines.length > 0 && line && isWhiteSpaceString(line);\n        line = lines.pop()\n      ) {\n        curEnd.line--;\n        curEnd.ch = 0;\n      }\n      // If the last word is not an empty line, clip an additional newline\n      if (line) {\n        curEnd.line--;\n        curEnd.ch = lineLength(cm, curEnd.line);\n      } else {\n        curEnd.ch = 0;\n      }\n    }\n  }\n\n  // Expand the selection to line ends.\n  function expandSelectionToLine(_cm, curStart, curEnd) {\n    curStart.ch = 0;\n    curEnd.ch = 0;\n    curEnd.line++;\n  }\n\n  function findFirstNonWhiteSpaceCharacter(text) {\n    if (!text) {\n      return 0;\n    }\n    var firstNonWS = text.search(/\\S/);\n    return firstNonWS == -1 ? text.length : firstNonWS;\n  }\n\n  function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {\n    var cur = getHead(cm);\n    var line = cm.getLine(cur.line);\n    var idx = cur.ch;\n\n    // Seek to first word or non-whitespace character, depending on if\n    // noSymbol is true.\n    var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];\n    while (!test(line.charAt(idx))) {\n      idx++;\n      if (idx >= line.length) {\n        return null;\n      }\n    }\n\n    if (bigWord) {\n      test = bigWordCharTest[0];\n    } else {\n      test = wordCharTest[0];\n      if (!test(line.charAt(idx))) {\n        test = wordCharTest[1];\n      }\n    }\n\n    var end = idx,\n      start = idx;\n    while (test(line.charAt(end)) && end < line.length) {\n      end++;\n    }\n    while (test(line.charAt(start)) && start >= 0) {\n      start--;\n    }\n    start++;\n\n    if (inclusive) {\n      // If present, include all whitespace after word.\n      // Otherwise, include all whitespace before word, except indentation.\n      var wordEnd = end;\n      while (/\\s/.test(line.charAt(end)) && end < line.length) {\n        end++;\n      }\n      if (wordEnd == end) {\n        var wordStart = start;\n        while (/\\s/.test(line.charAt(start - 1)) && start > 0) {\n          start--;\n        }\n        if (!start) {\n          start = wordStart;\n        }\n      }\n    }\n    return { start: new Pos(cur.line, start), end: new Pos(cur.line, end) };\n  }\n\n  /**\n   * Depends on the following:\n   *\n   * - editor mode should be htmlmixedmode / xml\n   * - mode/xml/xml.js should be loaded\n   * - addon/fold/xml-fold.js should be loaded\n   *\n   * If any of the above requirements are not true, this function noops.\n   *\n   * This is _NOT_ a 100% accurate implementation of vim tag text objects.\n   * The following caveats apply (based off cursory testing, I'm sure there\n   * are other discrepancies):\n   *\n   * - Does not work inside comments:\n   *   ```\n   *   <!-- <div>broken</div> -->\n   *   ```\n   * - Does not work when tags have different cases:\n   *   ```\n   *   <div>broken</DIV>\n   *   ```\n   * - Does not work when cursor is inside a broken tag:\n   *   ```\n   *   <div><brok><en></div>\n   *   ```\n   */\n  function expandTagUnderCursor(cm, head, inclusive) {\n    var cur = head;\n    if (!CodeMirror.findMatchingTag || !CodeMirror.findEnclosingTag) {\n      return { start: cur, end: cur };\n    }\n\n    var tags =\n      CodeMirror.findMatchingTag(cm, head) ||\n      CodeMirror.findEnclosingTag(cm, head);\n    if (!tags || !tags.open || !tags.close) {\n      return { start: cur, end: cur };\n    }\n\n    if (inclusive) {\n      return { start: tags.open.from, end: tags.close.to };\n    }\n    return { start: tags.open.to, end: tags.close.from };\n  }\n\n  function recordJumpPosition(cm, oldCur, newCur) {\n    if (!cursorEqual(oldCur, newCur)) {\n      vimGlobalState.jumpList.add(cm, oldCur, newCur);\n    }\n  }\n\n  function recordLastCharacterSearch(increment, args) {\n    vimGlobalState.lastCharacterSearch.increment = increment;\n    vimGlobalState.lastCharacterSearch.forward = args.forward;\n    vimGlobalState.lastCharacterSearch.selectedCharacter =\n      args.selectedCharacter;\n  }\n\n  var symbolToMode = {\n    \"(\": \"bracket\",\n    \")\": \"bracket\",\n    \"{\": \"bracket\",\n    \"}\": \"bracket\",\n    \"[\": \"section\",\n    \"]\": \"section\",\n    \"*\": \"comment\",\n    \"/\": \"comment\",\n    m: \"method\",\n    M: \"method\",\n    \"#\": \"preprocess\",\n  };\n  var findSymbolModes = {\n    bracket: {\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) {\n          state.depth++;\n          if (state.depth >= 1) return true;\n        } else if (state.nextCh === state.reverseSymb) {\n          state.depth--;\n        }\n        return false;\n      },\n    },\n    section: {\n      init: function (state) {\n        state.curMoveThrough = true;\n        state.symb = (state.forward ? \"]\" : \"[\") === state.symb ? \"{\" : \"}\";\n      },\n      isComplete: function (state) {\n        return state.index === 0 && state.nextCh === state.symb;\n      },\n    },\n    comment: {\n      isComplete: function (state) {\n        var found = state.lastCh === \"*\" && state.nextCh === \"/\";\n        state.lastCh = state.nextCh;\n        return found;\n      },\n    },\n    // TODO: The original Vim implementation only operates on level 1 and 2.\n    // The current implementation doesn't check for code block level and\n    // therefore it operates on any levels.\n    method: {\n      init: function (state) {\n        state.symb = state.symb === \"m\" ? \"{\" : \"}\";\n        state.reverseSymb = state.symb === \"{\" ? \"}\" : \"{\";\n      },\n      isComplete: function (state) {\n        if (state.nextCh === state.symb) return true;\n        return false;\n      },\n    },\n    preprocess: {\n      init: function (state) {\n        state.index = 0;\n      },\n      isComplete: function (state) {\n        if (state.nextCh === \"#\") {\n          var token = state.lineText.match(/^#(\\w+)/)[1];\n          if (token === \"endif\") {\n            if (state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth++;\n          } else if (token === \"if\") {\n            if (!state.forward && state.depth === 0) {\n              return true;\n            }\n            state.depth--;\n          }\n          if (token === \"else\" && state.depth === 0) return true;\n        }\n        return false;\n      },\n    },\n  };\n  function findSymbol(cm, repeat, forward, symb) {\n    var cur = copyCursor(cm.getCursor());\n    var increment = forward ? 1 : -1;\n    var endLine = forward ? cm.lineCount() : -1;\n    var curCh = cur.ch;\n    var line = cur.line;\n    var lineText = cm.getLine(line);\n    var state = {\n      lineText: lineText,\n      nextCh: lineText.charAt(curCh),\n      lastCh: null,\n      index: curCh,\n      symb: symb,\n      reverseSymb: (forward ? { \")\": \"(\", \"}\": \"{\" } : { \"(\": \")\", \"{\": \"}\" })[\n        symb\n      ],\n      forward: forward,\n      depth: 0,\n      curMoveThrough: false,\n    };\n    var mode = symbolToMode[symb];\n    if (!mode) return cur;\n    var init = findSymbolModes[mode].init;\n    var isComplete = findSymbolModes[mode].isComplete;\n    if (init) {\n      init(state);\n    }\n    while (line !== endLine && repeat) {\n      state.index += increment;\n      state.nextCh = state.lineText.charAt(state.index);\n      if (!state.nextCh) {\n        line += increment;\n        state.lineText = cm.getLine(line) || \"\";\n        if (increment > 0) {\n          state.index = 0;\n        } else {\n          var lineLen = state.lineText.length;\n          state.index = lineLen > 0 ? lineLen - 1 : 0;\n        }\n        state.nextCh = state.lineText.charAt(state.index);\n      }\n      if (isComplete(state)) {\n        cur.line = line;\n        cur.ch = state.index;\n        repeat--;\n      }\n    }\n    if (state.nextCh || state.curMoveThrough) {\n      return new Pos(line, state.index);\n    }\n    return cur;\n  }\n\n  /*\n   * Returns the boundaries of the next word. If the cursor in the middle of\n   * the word, then returns the boundaries of the current word, starting at\n   * the cursor. If the cursor is at the start/end of a word, and we are going\n   * forward/backward, respectively, find the boundaries of the next word.\n   *\n   * @param {CodeMirror} cm CodeMirror object.\n   * @param {Cursor} cur The cursor position.\n   * @param {boolean} forward True to search forward. False to search\n   *     backward.\n   * @param {boolean} bigWord True if punctuation count as part of the word.\n   *     False if only [a-zA-Z0-9] characters count as part of the word.\n   * @param {boolean} emptyLineIsWord True if empty lines should be treated\n   *     as words.\n   * @return {Object{from:number, to:number, line: number}} The boundaries of\n   *     the word, or null if there are no more words.\n   */\n  function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {\n    var lineNum = cur.line;\n    var pos = cur.ch;\n    var line = cm.getLine(lineNum);\n    var dir = forward ? 1 : -1;\n    var charTests = bigWord ? bigWordCharTest : wordCharTest;\n\n    if (emptyLineIsWord && line == \"\") {\n      lineNum += dir;\n      line = cm.getLine(lineNum);\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      pos = forward ? 0 : line.length;\n    }\n\n    while (true) {\n      if (emptyLineIsWord && line == \"\") {\n        return { from: 0, to: 0, line: lineNum };\n      }\n      var stop = dir > 0 ? line.length : -1;\n      var wordStart = stop,\n        wordEnd = stop;\n      // Find bounds of next word.\n      while (pos != stop) {\n        var foundWord = false;\n        for (var i = 0; i < charTests.length && !foundWord; ++i) {\n          if (charTests[i](line.charAt(pos))) {\n            wordStart = pos;\n            // Advance to end of word.\n            while (pos != stop && charTests[i](line.charAt(pos))) {\n              pos += dir;\n            }\n            wordEnd = pos;\n            foundWord = wordStart != wordEnd;\n            if (\n              wordStart == cur.ch &&\n              lineNum == cur.line &&\n              wordEnd == wordStart + dir\n            ) {\n              // We started at the end of a word. Find the next one.\n              continue;\n            } else {\n              return {\n                from: Math.min(wordStart, wordEnd + 1),\n                to: Math.max(wordStart, wordEnd),\n                line: lineNum,\n              };\n            }\n          }\n        }\n        if (!foundWord) {\n          pos += dir;\n        }\n      }\n      // Advance to next/prev line.\n      lineNum += dir;\n      if (!isLine(cm, lineNum)) {\n        return null;\n      }\n      line = cm.getLine(lineNum);\n      pos = dir > 0 ? 0 : line.length;\n    }\n  }\n\n  /**\n   * @param {CodeMirror} cm CodeMirror object.\n   * @param {Pos} cur The position to start from.\n   * @param {int} repeat Number of words to move past.\n   * @param {boolean} forward True to search forward. False to search\n   *     backward.\n   * @param {boolean} wordEnd True to move to end of word. False to move to\n   *     beginning of word.\n   * @param {boolean} bigWord True if punctuation count as part of the word.\n   *     False if only alphabet characters count as part of the word.\n   * @return {Cursor} The position the cursor should move to.\n   */\n  function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {\n    var curStart = copyCursor(cur);\n    var words = [];\n    if ((forward && !wordEnd) || (!forward && wordEnd)) {\n      repeat++;\n    }\n    // For 'e', empty lines are not considered words, go figure.\n    var emptyLineIsWord = !(forward && wordEnd);\n    for (var i = 0; i < repeat; i++) {\n      var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);\n      if (!word) {\n        var eodCh = lineLength(cm, cm.lastLine());\n        words.push(\n          forward\n            ? { line: cm.lastLine(), from: eodCh, to: eodCh }\n            : { line: 0, from: 0, to: 0 }\n        );\n        break;\n      }\n      words.push(word);\n      cur = new Pos(word.line, forward ? word.to - 1 : word.from);\n    }\n    var shortCircuit = words.length != repeat;\n    var firstWord = words[0];\n    var lastWord = words.pop();\n    if (forward && !wordEnd) {\n      // w\n      if (\n        !shortCircuit &&\n        (firstWord.from != curStart.ch || firstWord.line != curStart.line)\n      ) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n      return new Pos(lastWord.line, lastWord.from);\n    } else if (forward && wordEnd) {\n      return new Pos(lastWord.line, lastWord.to - 1);\n    } else if (!forward && wordEnd) {\n      // ge\n      if (\n        !shortCircuit &&\n        (firstWord.to != curStart.ch || firstWord.line != curStart.line)\n      ) {\n        // We did not start in the middle of a word. Discard the extra word at the end.\n        lastWord = words.pop();\n      }\n      return new Pos(lastWord.line, lastWord.to);\n    } else {\n      // b\n      return new Pos(lastWord.line, lastWord.from);\n    }\n  }\n\n  function moveToEol(cm, head, motionArgs, vim, keepHPos) {\n    var cur = head;\n    var retval = new Pos(cur.line + motionArgs.repeat - 1, Infinity);\n    var end = cm.clipPos(retval);\n    end.ch--;\n    if (!keepHPos) {\n      vim.lastHPos = Infinity;\n      vim.lastHSPos = cm.charCoords(end, \"div\").left;\n    }\n    return retval;\n  }\n\n  function moveToCharacter(cm, repeat, forward, character) {\n    var cur = cm.getCursor();\n    var start = cur.ch;\n    var idx;\n    for (var i = 0; i < repeat; i++) {\n      var line = cm.getLine(cur.line);\n      idx = charIdxInLine(start, line, character, forward, true);\n      if (idx == -1) {\n        return null;\n      }\n      start = idx;\n    }\n    return new Pos(cm.getCursor().line, idx);\n  }\n\n  function moveToColumn(cm, repeat) {\n    // repeat is always >= 1, so repeat - 1 always corresponds\n    // to the column we want to go to.\n    var line = cm.getCursor().line;\n    return clipCursorToContent(cm, new Pos(line, repeat - 1));\n  }\n\n  function updateMark(cm, vim, markName, pos) {\n    if (!inArray(markName, validMarks)) {\n      return;\n    }\n    if (vim.marks[markName]) {\n      vim.marks[markName].clear();\n    }\n    vim.marks[markName] = cm.setBookmark(pos);\n  }\n\n  function charIdxInLine(start, line, character, forward, includeChar) {\n    // Search for char in line.\n    // motion_options: {forward, includeChar}\n    // If includeChar = true, include it too.\n    // If forward = true, search forward, else search backwards.\n    // If char is not found on this line, do nothing\n    var idx;\n    if (forward) {\n      idx = line.indexOf(character, start + 1);\n      if (idx != -1 && !includeChar) {\n        idx -= 1;\n      }\n    } else {\n      idx = line.lastIndexOf(character, start - 1);\n      if (idx != -1 && !includeChar) {\n        idx += 1;\n      }\n    }\n    return idx;\n  }\n\n  function findParagraph(cm, head, repeat, dir, inclusive) {\n    var line = head.line;\n    var min = cm.firstLine();\n    var max = cm.lastLine();\n    var start,\n      end,\n      i = line;\n    function isEmpty(i) {\n      return !cm.getLine(i);\n    }\n    function isBoundary(i, dir, any) {\n      if (any) {\n        return isEmpty(i) != isEmpty(i + dir);\n      }\n      return !isEmpty(i) && isEmpty(i + dir);\n    }\n    if (dir) {\n      while (min <= i && i <= max && repeat > 0) {\n        if (isBoundary(i, dir)) {\n          repeat--;\n        }\n        i += dir;\n      }\n      return new Pos(i, 0);\n    }\n\n    var vim = cm.state.vim;\n    if (vim.visualLine && isBoundary(line, 1, true)) {\n      var anchor = vim.sel.anchor;\n      if (isBoundary(anchor.line, -1, true)) {\n        if (!inclusive || anchor.line != line) {\n          line += 1;\n        }\n      }\n    }\n    var startState = isEmpty(line);\n    for (i = line; i <= max && repeat; i++) {\n      if (isBoundary(i, 1, true)) {\n        if (!inclusive || isEmpty(i) != startState) {\n          repeat--;\n        }\n      }\n    }\n    end = new Pos(i, 0);\n    // select boundary before paragraph for the last one\n    if (i > max && !startState) {\n      startState = true;\n    } else {\n      inclusive = false;\n    }\n    for (i = line; i > min; i--) {\n      if (!inclusive || isEmpty(i) == startState || i == line) {\n        if (isBoundary(i, -1, true)) {\n          break;\n        }\n      }\n    }\n    start = new Pos(i, 0);\n    return { start: start, end: end };\n  }\n\n  function findSentence(cm, cur, repeat, dir) {\n    /*\n        Takes an index object\n        {\n          line: the line string,\n          ln: line number,\n          pos: index in line,\n          dir: direction of traversal (-1 or 1)\n        }\n        and modifies the line, ln, and pos members to represent the\n        next valid position or sets them to null if there are\n        no more valid positions.\n       */\n    function nextChar(cm, idx) {\n      if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {\n        idx.ln += idx.dir;\n        if (!isLine(cm, idx.ln)) {\n          idx.line = null;\n          idx.ln = null;\n          idx.pos = null;\n          return;\n        }\n        idx.line = cm.getLine(idx.ln);\n        idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;\n      } else {\n        idx.pos += idx.dir;\n      }\n    }\n\n    /*\n        Performs one iteration of traversal in forward direction\n        Returns an index object of the new location\n       */\n    function forward(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n      var stop = line === \"\";\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      var last_valid = {\n        ln: curr.ln,\n        pos: curr.pos,\n      };\n\n      var skip_empty_lines = curr.line === \"\";\n\n      // Move one step to skip character we start on\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n        last_valid.ln = curr.ln;\n        last_valid.pos = curr.pos;\n\n        if (curr.line === \"\" && !skip_empty_lines) {\n          return { ln: curr.ln, pos: curr.pos };\n        } else if (\n          stop &&\n          curr.line !== \"\" &&\n          !isWhiteSpaceString(curr.line[curr.pos])\n        ) {\n          return { ln: curr.ln, pos: curr.pos };\n        } else if (\n          isEndOfSentenceSymbol(curr.line[curr.pos]) &&\n          !stop &&\n          (curr.pos === curr.line.length - 1 ||\n            isWhiteSpaceString(curr.line[curr.pos + 1]))\n        ) {\n          stop = true;\n        }\n\n        nextChar(cm, curr);\n      }\n\n      /*\n          Set the position to the last non whitespace character on the last\n          valid line in the case that we reach the end of the document.\n        */\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = line.length - 1; i >= 0; --i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n\n      return last_valid;\n    }\n\n    /*\n        Performs one iteration of traversal in reverse direction\n        Returns an index object of the new location\n       */\n    function reverse(cm, ln, pos, dir) {\n      var line = cm.getLine(ln);\n\n      var curr = {\n        line: line,\n        ln: ln,\n        pos: pos,\n        dir: dir,\n      };\n\n      var last_valid = {\n        ln: curr.ln,\n        pos: null,\n      };\n\n      var skip_empty_lines = curr.line === \"\";\n\n      // Move one step to skip character we start on\n      nextChar(cm, curr);\n\n      while (curr.line !== null) {\n        if (curr.line === \"\" && !skip_empty_lines) {\n          if (last_valid.pos !== null) {\n            return last_valid;\n          } else {\n            return { ln: curr.ln, pos: curr.pos };\n          }\n        } else if (\n          isEndOfSentenceSymbol(curr.line[curr.pos]) &&\n          last_valid.pos !== null &&\n          !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)\n        ) {\n          return last_valid;\n        } else if (\n          curr.line !== \"\" &&\n          !isWhiteSpaceString(curr.line[curr.pos])\n        ) {\n          skip_empty_lines = false;\n          last_valid = { ln: curr.ln, pos: curr.pos };\n        }\n\n        nextChar(cm, curr);\n      }\n\n      /*\n          Set the position to the first non whitespace character on the last\n          valid line in the case that we reach the beginning of the document.\n        */\n      var line = cm.getLine(last_valid.ln);\n      last_valid.pos = 0;\n      for (var i = 0; i < line.length; ++i) {\n        if (!isWhiteSpaceString(line[i])) {\n          last_valid.pos = i;\n          break;\n        }\n      }\n      return last_valid;\n    }\n\n    var curr_index = {\n      ln: cur.line,\n      pos: cur.ch,\n    };\n\n    while (repeat > 0) {\n      if (dir < 0) {\n        curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);\n      } else {\n        curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);\n      }\n      repeat--;\n    }\n\n    return new Pos(curr_index.ln, curr_index.pos);\n  }\n\n  // TODO: perhaps this finagling of start and end positions belongs\n  // in codemirror/replaceRange?\n  function selectCompanionObject(cm, head, symb, inclusive) {\n    var cur = head,\n      start,\n      end;\n\n    var bracketRegexp = {\n      \"(\": /[()]/,\n      \")\": /[()]/,\n      \"[\": /[[\\]]/,\n      \"]\": /[[\\]]/,\n      \"{\": /[{}]/,\n      \"}\": /[{}]/,\n      \"<\": /[<>]/,\n      \">\": /[<>]/,\n    }[symb];\n    var openSym = {\n      \"(\": \"(\",\n      \")\": \"(\",\n      \"[\": \"[\",\n      \"]\": \"[\",\n      \"{\": \"{\",\n      \"}\": \"{\",\n      \"<\": \"<\",\n      \">\": \"<\",\n    }[symb];\n    var curChar = cm.getLine(cur.line).charAt(cur.ch);\n    // Due to the behavior of scanForBracket, we need to add an offset if the\n    // cursor is on a matching open bracket.\n    var offset = curChar === openSym ? 1 : 0;\n\n    start = cm.scanForBracket(\n      new Pos(cur.line, cur.ch + offset),\n      -1,\n      undefined,\n      { bracketRegex: bracketRegexp }\n    );\n    end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, undefined, {\n      bracketRegex: bracketRegexp,\n    });\n\n    if (!start || !end) {\n      return { start: cur, end: cur };\n    }\n\n    start = start.pos;\n    end = end.pos;\n\n    if (\n      (start.line == end.line && start.ch > end.ch) ||\n      start.line > end.line\n    ) {\n      var tmp = start;\n      start = end;\n      end = tmp;\n    }\n\n    if (inclusive) {\n      end.ch += 1;\n    } else {\n      start.ch += 1;\n    }\n\n    return { start: start, end: end };\n  }\n\n  // Takes in a symbol and a cursor and tries to simulate text objects that\n  // have identical opening and closing symbols\n  // TODO support across multiple lines\n  function findBeginningAndEnd(cm, head, symb, inclusive) {\n    var cur = copyCursor(head);\n    var line = cm.getLine(cur.line);\n    var chars = line.split(\"\");\n    var start, end, i, len;\n    var firstIndex = chars.indexOf(symb);\n\n    // the decision tree is to always look backwards for the beginning first,\n    // but if the cursor is in front of the first instance of the symb,\n    // then move the cursor forward\n    if (cur.ch < firstIndex) {\n      cur.ch = firstIndex;\n      // Why is this line even here???\n      // cm.setCursor(cur.line, firstIndex+1);\n    }\n    // otherwise if the cursor is currently on the closing symbol\n    else if (firstIndex < cur.ch && chars[cur.ch] == symb) {\n      end = cur.ch; // assign end to the current cursor\n      --cur.ch; // make sure to look backwards\n    }\n\n    // if we're currently on the symbol, we've got a start\n    if (chars[cur.ch] == symb && !end) {\n      start = cur.ch + 1; // assign start to ahead of the cursor\n    } else {\n      // go backwards to find the start\n      for (i = cur.ch; i > -1 && !start; i--) {\n        if (chars[i] == symb) {\n          start = i + 1;\n        }\n      }\n    }\n\n    // look forwards for the end symbol\n    if (start && !end) {\n      for (i = start, len = chars.length; i < len && !end; i++) {\n        if (chars[i] == symb) {\n          end = i;\n        }\n      }\n    }\n\n    // nothing found\n    if (!start || !end) {\n      return { start: cur, end: cur };\n    }\n\n    // include the symbols\n    if (inclusive) {\n      --start;\n      ++end;\n    }\n\n    return {\n      start: new Pos(cur.line, start),\n      end: new Pos(cur.line, end),\n    };\n  }\n\n  // Search functions\n  defineOption(\"pcre\", true, \"boolean\");\n  function SearchState() {}\n  SearchState.prototype = {\n    getQuery: function () {\n      return vimGlobalState.query;\n    },\n    setQuery: function (query) {\n      vimGlobalState.query = query;\n    },\n    getOverlay: function () {\n      return this.searchOverlay;\n    },\n    setOverlay: function (overlay) {\n      this.searchOverlay = overlay;\n    },\n    isReversed: function () {\n      return vimGlobalState.isReversed;\n    },\n    setReversed: function (reversed) {\n      vimGlobalState.isReversed = reversed;\n    },\n    getScrollbarAnnotate: function () {\n      return this.annotate;\n    },\n    setScrollbarAnnotate: function (annotate) {\n      this.annotate = annotate;\n    },\n  };\n  function getSearchState(cm) {\n    var vim = cm.state.vim;\n    return vim.searchState_ || (vim.searchState_ = new SearchState());\n  }\n  function splitBySlash(argString) {\n    return splitBySeparator(argString, \"/\");\n  }\n\n  function findUnescapedSlashes(argString) {\n    return findUnescapedSeparators(argString, \"/\");\n  }\n\n  function splitBySeparator(argString, separator) {\n    var slashes = findUnescapedSeparators(argString, separator) || [];\n    if (!slashes.length) return [];\n    var tokens = [];\n    // in case of strings like foo/bar\n    if (slashes[0] !== 0) return;\n    for (var i = 0; i < slashes.length; i++) {\n      if (typeof slashes[i] == \"number\")\n        tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));\n    }\n    return tokens;\n  }\n\n  function findUnescapedSeparators(str, separator) {\n    if (!separator) separator = \"/\";\n\n    var escapeNextChar = false;\n    var slashes = [];\n    for (var i = 0; i < str.length; i++) {\n      var c = str.charAt(i);\n      if (!escapeNextChar && c == separator) {\n        slashes.push(i);\n      }\n      escapeNextChar = !escapeNextChar && c == \"\\\\\";\n    }\n    return slashes;\n  }\n\n  // Translates a search string from ex (vim) syntax into javascript form.\n  function translateRegex(str) {\n    // When these match, add a '\\' if unescaped or remove one if escaped.\n    var specials = \"|(){\";\n    // Remove, but never add, a '\\' for these.\n    var unescape = \"}\";\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || \"\";\n      var n = str.charAt(i + 1) || \"\";\n      var specialComesNext = n && specials.indexOf(n) != -1;\n      if (escapeNextChar) {\n        if (c !== \"\\\\\" || !specialComesNext) {\n          out.push(c);\n        }\n        escapeNextChar = false;\n      } else {\n        if (c === \"\\\\\") {\n          escapeNextChar = true;\n          // Treat the unescape list as special for removing, but not adding '\\'.\n          if (n && unescape.indexOf(n) != -1) {\n            specialComesNext = true;\n          }\n          // Not passing this test means removing a '\\'.\n          if (!specialComesNext || n === \"\\\\\") {\n            out.push(c);\n          }\n        } else {\n          out.push(c);\n          if (specialComesNext && n !== \"\\\\\") {\n            out.push(\"\\\\\");\n          }\n        }\n      }\n    }\n    return out.join(\"\");\n  }\n\n  // Translates the replace part of a search and replace from ex (vim) syntax into\n  // javascript form.  Similar to translateRegex, but additionally fixes back references\n  // (translates '\\[0..9]' to '$[0..9]') and follows different rules for escaping '$'.\n  var charUnescapes = { \"\\\\n\": \"\\n\", \"\\\\r\": \"\\r\", \"\\\\t\": \"\\t\" };\n  function translateRegexReplace(str) {\n    var escapeNextChar = false;\n    var out = [];\n    for (var i = -1; i < str.length; i++) {\n      var c = str.charAt(i) || \"\";\n      var n = str.charAt(i + 1) || \"\";\n      if (charUnescapes[c + n]) {\n        out.push(charUnescapes[c + n]);\n        i++;\n      } else if (escapeNextChar) {\n        // At any point in the loop, escapeNextChar is true if the previous\n        // character was a '\\' and was not escaped.\n        out.push(c);\n        escapeNextChar = false;\n      } else {\n        if (c === \"\\\\\") {\n          escapeNextChar = true;\n          if (isNumber(n) || n === \"$\") {\n            out.push(\"$\");\n          } else if (n !== \"/\" && n !== \"\\\\\") {\n            out.push(\"\\\\\");\n          }\n        } else {\n          if (c === \"$\") {\n            out.push(\"$\");\n          }\n          out.push(c);\n          if (n === \"/\") {\n            out.push(\"\\\\\");\n          }\n        }\n      }\n    }\n    return out.join(\"\");\n  }\n\n  // Unescape \\ and / in the replace part, for PCRE mode.\n  var unescapes = {\n    \"\\\\/\": \"/\",\n    \"\\\\\\\\\": \"\\\\\",\n    \"\\\\n\": \"\\n\",\n    \"\\\\r\": \"\\r\",\n    \"\\\\t\": \"\\t\",\n    \"\\\\&\": \"&\",\n  };\n  function unescapeRegexReplace(str) {\n    var stream = new CodeMirror.StringStream(str);\n    var output = [];\n    while (!stream.eol()) {\n      // Search for \\.\n      while (stream.peek() && stream.peek() != \"\\\\\") {\n        output.push(stream.next());\n      }\n      var matched = false;\n      for (var matcher in unescapes) {\n        if (stream.match(matcher, true)) {\n          matched = true;\n          output.push(unescapes[matcher]);\n          break;\n        }\n      }\n      if (!matched) {\n        // Don't change anything\n        output.push(stream.next());\n      }\n    }\n    return output.join(\"\");\n  }\n\n  /**\n   * Extract the regular expression from the query and return a Regexp object.\n   * Returns null if the query is blank.\n   * If ignoreCase is passed in, the Regexp object will have the 'i' flag set.\n   * If smartCase is passed in, and the query contains upper case letters,\n   *   then ignoreCase is overridden, and the 'i' flag will not be set.\n   * If the query contains the /i in the flag part of the regular expression,\n   *   then both ignoreCase and smartCase are ignored, and 'i' will be passed\n   *   through to the Regex object.\n   */\n  function parseQuery(query, ignoreCase, smartCase) {\n    // First update the last search register\n    var lastSearchRegister = vimGlobalState.registerController.getRegister(\"/\");\n    lastSearchRegister.setText(query);\n    // Check if the query is already a regex.\n    if (query instanceof RegExp) {\n      return query;\n    }\n    // First try to extract regex + flags from the input. If no flags found,\n    // extract just the regex. IE does not accept flags directly defined in\n    // the regex string in the form /regex/flags\n    var slashes = findUnescapedSlashes(query);\n    var regexPart;\n    var forceIgnoreCase;\n    if (!slashes.length) {\n      // Query looks like 'regexp'\n      regexPart = query;\n    } else {\n      // Query looks like 'regexp/...'\n      regexPart = query.substring(0, slashes[0]);\n      var flagsPart = query.substring(slashes[0]);\n      forceIgnoreCase = flagsPart.indexOf(\"i\") != -1;\n    }\n    if (!regexPart) {\n      return null;\n    }\n    if (!getOption(\"pcre\")) {\n      regexPart = translateRegex(regexPart);\n    }\n    if (smartCase) {\n      ignoreCase = /^[^A-Z]*$/.test(regexPart);\n    }\n    var regexp = new RegExp(\n      regexPart,\n      ignoreCase || forceIgnoreCase ? \"im\" : \"m\"\n    );\n    return regexp;\n  }\n\n  /**\n   * dom - Document Object Manipulator\n   * Usage:\n   *   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])\n   * Examples:\n   *   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))\n   *   dom(document.head, dom('script', 'alert(\"hello!\")'))\n   * Not supported:\n   *   dom('p', ['arrays are objects'], Error('objects specify attributes'))\n   */\n  function dom(n) {\n    if (typeof n === \"string\") n = document.createElement(n);\n    for (var a, i = 1; i < arguments.length; i++) {\n      if (!(a = arguments[i])) continue;\n      if (typeof a !== \"object\") a = document.createTextNode(a);\n      if (a.nodeType) n.appendChild(a);\n      else\n        for (var key in a) {\n          if (!Object.prototype.hasOwnProperty.call(a, key)) continue;\n          if (key[0] === \"$\") n.style[key.slice(1)] = a[key];\n          else n.setAttribute(key, a[key]);\n        }\n    }\n    return n;\n  }\n\n  function showConfirm(cm, template) {\n    var pre = dom(\"pre\", { $color: \"red\", class: \"cm-vim-message\" }, template);\n    if (cm.openNotification) {\n      cm.openNotification(pre, { bottom: true, duration: 5000 });\n    } else {\n      alert(pre.innerText);\n    }\n  }\n\n  function makePrompt(prefix, desc) {\n    return dom(\n      document.createDocumentFragment(),\n      dom(\n        \"span\",\n        { $fontFamily: \"monospace\", $whiteSpace: \"pre\" },\n        prefix,\n        dom(\"input\", {\n          type: \"text\",\n          autocorrect: \"off\",\n          autocapitalize: \"off\",\n          spellcheck: \"false\",\n        })\n      ),\n      desc && dom(\"span\", { $color: \"#888\" }, desc)\n    );\n  }\n\n  function showPrompt(cm, options) {\n    var template = makePrompt(options.prefix, options.desc);\n    if (cm.openDialog) {\n      cm.openDialog(template, options.onClose, {\n        onKeyDown: options.onKeyDown,\n        onKeyUp: options.onKeyUp,\n        bottom: true,\n        selectValueOnOpen: false,\n        value: options.value,\n      });\n    } else {\n      var shortText = \"\";\n      if (typeof options.prefix != \"string\" && options.prefix)\n        shortText += options.prefix.textContent;\n      if (options.desc) shortText += \" \" + options.desc;\n      options.onClose(prompt(shortText, \"\"));\n    }\n  }\n\n  function regexEqual(r1, r2) {\n    if (r1 instanceof RegExp && r2 instanceof RegExp) {\n      var props = [\"global\", \"multiline\", \"ignoreCase\", \"source\"];\n      for (var i = 0; i < props.length; i++) {\n        var prop = props[i];\n        if (r1[prop] !== r2[prop]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  // Returns true if the query is valid.\n  function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {\n    if (!rawQuery) {\n      return;\n    }\n    var state = getSearchState(cm);\n    var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);\n    if (!query) {\n      return;\n    }\n    highlightSearchMatches(cm, query);\n    if (regexEqual(query, state.getQuery())) {\n      return query;\n    }\n    state.setQuery(query);\n    return query;\n  }\n  function searchOverlay(query) {\n    if (query.source.charAt(0) == \"^\") {\n      var matchSol = true;\n    }\n    return {\n      token: function (stream) {\n        if (matchSol && !stream.sol()) {\n          stream.skipToEnd();\n          return;\n        }\n        var match = stream.match(query, false);\n        if (match) {\n          if (match[0].length == 0) {\n            // Matched empty string, skip to next.\n            stream.next();\n            return \"searching\";\n          }\n          if (!stream.sol()) {\n            // Backtrack 1 to match \\b\n            stream.backUp(1);\n            if (!query.exec(stream.next() + match[0])) {\n              stream.next();\n              return null;\n            }\n          }\n          stream.match(query);\n          return \"searching\";\n        }\n        while (!stream.eol()) {\n          stream.next();\n          if (stream.match(query, false)) break;\n        }\n      },\n      query: query,\n    };\n  }\n  var highlightTimeout = 0;\n  function highlightSearchMatches(cm, query) {\n    clearTimeout(highlightTimeout);\n    highlightTimeout = setTimeout(function () {\n      if (!cm.state.vim) return;\n      var searchState = getSearchState(cm);\n      var overlay = searchState.getOverlay();\n      if (!overlay || query != overlay.query) {\n        if (overlay) {\n          cm.removeOverlay(overlay);\n        }\n        overlay = searchOverlay(query);\n        cm.addOverlay(overlay);\n        if (cm.showMatchesOnScrollbar) {\n          if (searchState.getScrollbarAnnotate()) {\n            searchState.getScrollbarAnnotate().clear();\n          }\n          searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));\n        }\n        searchState.setOverlay(overlay);\n      }\n    }, 50);\n  }\n  function findNext(cm, prev, query, repeat) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n      for (var i = 0; i < repeat; i++) {\n        var found = cursor.find(prev);\n        if (i == 0 && found && cursorEqual(cursor.from(), pos)) {\n          var lastEndPos = prev ? cursor.from() : cursor.to();\n          found = cursor.find(prev);\n          if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {\n            if (cm.getLine(lastEndPos.line).length == lastEndPos.ch)\n              found = cursor.find(prev);\n          }\n        }\n        if (!found) {\n          // SearchCursor may have returned null because it hit EOF, wrap\n          // around and try again.\n          cursor = cm.getSearchCursor(\n            query,\n            prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0)\n          );\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return cursor.from();\n    });\n  }\n  /**\n   * Pretty much the same as `findNext`, except for the following differences:\n   *\n   * 1. Before starting the search, move to the previous search. This way if our cursor is\n   * already inside a match, we should return the current match.\n   * 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.\n   */\n  function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {\n    if (repeat === undefined) {\n      repeat = 1;\n    }\n    return cm.operation(function () {\n      var pos = cm.getCursor();\n      var cursor = cm.getSearchCursor(query, pos);\n\n      // Go back one result to ensure that if the cursor is currently a match, we keep it.\n      var found = cursor.find(!prev);\n\n      // If we haven't moved, go back one more (similar to if i==0 logic in findNext).\n      if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) {\n        cursor.find(!prev);\n      }\n\n      for (var i = 0; i < repeat; i++) {\n        found = cursor.find(prev);\n        if (!found) {\n          // SearchCursor may have returned null because it hit EOF, wrap\n          // around and try again.\n          cursor = cm.getSearchCursor(\n            query,\n            prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0)\n          );\n          if (!cursor.find(prev)) {\n            return;\n          }\n        }\n      }\n      return [cursor.from(), cursor.to()];\n    });\n  }\n  function clearSearchHighlight(cm) {\n    var state = getSearchState(cm);\n    cm.removeOverlay(getSearchState(cm).getOverlay());\n    state.setOverlay(null);\n    if (state.getScrollbarAnnotate()) {\n      state.getScrollbarAnnotate().clear();\n      state.setScrollbarAnnotate(null);\n    }\n  }\n  /**\n   * Check if pos is in the specified range, INCLUSIVE.\n   * Range can be specified with 1 or 2 arguments.\n   * If the first range argument is an array, treat it as an array of line\n   * numbers. Match pos against any of the lines.\n   * If the first range argument is a number,\n   *   if there is only 1 range argument, check if pos has the same line\n   *       number\n   *   if there are 2 range arguments, then check if pos is in between the two\n   *       range arguments.\n   */\n  function isInRange(pos, start, end) {\n    if (typeof pos != \"number\") {\n      // Assume it is a cursor position. Get the line number.\n      pos = pos.line;\n    }\n    if (start instanceof Array) {\n      return inArray(pos, start);\n    } else {\n      if (typeof end == \"number\") {\n        return pos >= start && pos <= end;\n      } else {\n        return pos == start;\n      }\n    }\n  }\n  function getUserVisibleLines(cm) {\n    var scrollInfo = cm.getScrollInfo();\n    var occludeToleranceTop = 6;\n    var occludeToleranceBottom = 10;\n    var from = cm.coordsChar(\n      { left: 0, top: occludeToleranceTop + scrollInfo.top },\n      \"local\"\n    );\n    var bottomY =\n      scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;\n    var to = cm.coordsChar({ left: 0, top: bottomY }, \"local\");\n    return { top: from.line, bottom: to.line };\n  }\n\n  function getMarkPos(cm, vim, markName) {\n    if (markName == \"'\" || markName == \"`\") {\n      return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);\n    } else if (markName == \".\") {\n      return getLastEditPos(cm);\n    }\n\n    var mark = vim.marks[markName];\n    return mark && mark.find();\n  }\n\n  function getLastEditPos(cm) {\n    var done = cm.doc.history.done;\n    for (var i = done.length; i--; ) {\n      if (done[i].changes) {\n        return copyCursor(done[i].changes[0].to);\n      }\n    }\n  }\n\n  var ExCommandDispatcher = function () {\n    this.buildCommandMap_();\n  };\n  ExCommandDispatcher.prototype = {\n    processCommand: function (cm, input, opt_params) {\n      var that = this;\n      cm.operation(function () {\n        cm.curOp.isVimOp = true;\n        that._processCommand(cm, input, opt_params);\n      });\n    },\n    _processCommand: function (cm, input, opt_params) {\n      var vim = cm.state.vim;\n      var commandHistoryRegister =\n        vimGlobalState.registerController.getRegister(\":\");\n      var previousCommand = commandHistoryRegister.toString();\n      if (vim.visualMode) {\n        exitVisualMode(cm);\n      }\n      var inputStream = new CodeMirror.StringStream(input);\n      // update \": with the latest command whether valid or invalid\n      commandHistoryRegister.setText(input);\n      var params = opt_params || {};\n      params.input = input;\n      try {\n        this.parseInput_(cm, inputStream, params);\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n      var command;\n      var commandName;\n      if (!params.commandName) {\n        // If only a line range is defined, move to the line.\n        if (params.line !== undefined) {\n          commandName = \"move\";\n        }\n      } else {\n        command = this.matchCommand_(params.commandName);\n        if (command) {\n          commandName = command.name;\n          if (command.excludeFromCommandHistory) {\n            commandHistoryRegister.setText(previousCommand);\n          }\n          this.parseCommandArgs_(inputStream, params, command);\n          if (command.type == \"exToKey\") {\n            // Handle Ex to Key mapping.\n            for (var i = 0; i < command.toKeys.length; i++) {\n              vimApi.handleKey(cm, command.toKeys[i], \"mapping\");\n            }\n            return;\n          } else if (command.type == \"exToEx\") {\n            // Handle Ex to Ex mapping.\n            this.processCommand(cm, command.toInput);\n            return;\n          }\n        }\n      }\n      if (!commandName) {\n        showConfirm(cm, 'Not an editor command \":' + input + '\"');\n        return;\n      }\n      try {\n        exCommands[commandName](cm, params);\n        // Possibly asynchronous commands (e.g. substitute, which might have a\n        // user confirmation), are responsible for calling the callback when\n        // done. All others have it taken care of for them here.\n        if ((!command || !command.possiblyAsync) && params.callback) {\n          params.callback();\n        }\n      } catch (e) {\n        showConfirm(cm, e.toString());\n        throw e;\n      }\n    },\n    parseInput_: function (cm, inputStream, result) {\n      inputStream.eatWhile(\":\");\n      // Parse range.\n      if (inputStream.eat(\"%\")) {\n        result.line = cm.firstLine();\n        result.lineEnd = cm.lastLine();\n      } else {\n        result.line = this.parseLineSpec_(cm, inputStream);\n        if (result.line !== undefined && inputStream.eat(\",\")) {\n          result.lineEnd = this.parseLineSpec_(cm, inputStream);\n        }\n      }\n\n      // Parse command name.\n      var commandMatch = inputStream.match(/^(\\w+|!!|@@|[!#&*<=>@~])/);\n      if (commandMatch) {\n        result.commandName = commandMatch[1];\n      } else {\n        result.commandName = inputStream.match(/.*/)[0];\n      }\n\n      return result;\n    },\n    parseLineSpec_: function (cm, inputStream) {\n      var numberMatch = inputStream.match(/^(\\d+)/);\n      if (numberMatch) {\n        // Absolute line number plus offset (N+M or N-M) is probably a typo,\n        // not something the user actually wanted. (NB: vim does allow this.)\n        return parseInt(numberMatch[1], 10) - 1;\n      }\n      switch (inputStream.next()) {\n        case \".\":\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        case \"$\":\n          return this.parseLineSpecOffset_(inputStream, cm.lastLine());\n        case \"'\":\n          var markName = inputStream.next();\n          var markPos = getMarkPos(cm, cm.state.vim, markName);\n          if (!markPos) throw new Error(\"Mark not set\");\n          return this.parseLineSpecOffset_(inputStream, markPos.line);\n        case \"-\":\n        case \"+\":\n          inputStream.backUp(1);\n          // Offset is relative to current line if not otherwise specified.\n          return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);\n        default:\n          inputStream.backUp(1);\n          return undefined;\n      }\n    },\n    parseLineSpecOffset_: function (inputStream, line) {\n      var offsetMatch = inputStream.match(/^([+-])?(\\d+)/);\n      if (offsetMatch) {\n        var offset = parseInt(offsetMatch[2], 10);\n        if (offsetMatch[1] == \"-\") {\n          line -= offset;\n        } else {\n          line += offset;\n        }\n      }\n      return line;\n    },\n    parseCommandArgs_: function (inputStream, params, command) {\n      if (inputStream.eol()) {\n        return;\n      }\n      params.argString = inputStream.match(/.*/)[0];\n      // Parse command-line arguments\n      var delim = command.argDelimiter || /\\s+/;\n      var args = trim(params.argString).split(delim);\n      if (args.length && args[0]) {\n        params.args = args;\n      }\n    },\n    matchCommand_: function (commandName) {\n      // Return the command in the command map that matches the shortest\n      // prefix of the passed in command name. The match is guaranteed to be\n      // unambiguous if the defaultExCommandMap's shortNames are set up\n      // correctly. (see @code{defaultExCommandMap}).\n      for (var i = commandName.length; i > 0; i--) {\n        var prefix = commandName.substring(0, i);\n        if (this.commandMap_[prefix]) {\n          var command = this.commandMap_[prefix];\n          if (command.name.indexOf(commandName) === 0) {\n            return command;\n          }\n        }\n      }\n      return null;\n    },\n    buildCommandMap_: function () {\n      this.commandMap_ = {};\n      for (var i = 0; i < defaultExCommandMap.length; i++) {\n        var command = defaultExCommandMap[i];\n        var key = command.shortName || command.name;\n        this.commandMap_[key] = command;\n      }\n    },\n    map: function (lhs, rhs, ctx) {\n      if (lhs != \":\" && lhs.charAt(0) == \":\") {\n        if (ctx) {\n          throw Error(\"Mode not supported for ex mappings\");\n        }\n        var commandName = lhs.substring(1);\n        if (rhs != \":\" && rhs.charAt(0) == \":\") {\n          // Ex to Ex mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: \"exToEx\",\n            toInput: rhs.substring(1),\n            user: true,\n          };\n        } else {\n          // Ex to key mapping\n          this.commandMap_[commandName] = {\n            name: commandName,\n            type: \"exToKey\",\n            toKeys: rhs,\n            user: true,\n          };\n        }\n      } else {\n        if (rhs != \":\" && rhs.charAt(0) == \":\") {\n          // Key to Ex mapping.\n          var mapping = {\n            keys: lhs,\n            type: \"keyToEx\",\n            exArgs: { input: rhs.substring(1) },\n          };\n          if (ctx) {\n            mapping.context = ctx;\n          }\n          defaultKeymap.unshift(mapping);\n        } else {\n          // Key to key mapping\n          var mapping = {\n            keys: lhs,\n            type: \"keyToKey\",\n            toKeys: rhs,\n          };\n          if (ctx) {\n            mapping.context = ctx;\n          }\n          defaultKeymap.unshift(mapping);\n        }\n      }\n    },\n    unmap: function (lhs, ctx) {\n      if (lhs != \":\" && lhs.charAt(0) == \":\") {\n        // Ex to Ex or Ex to key mapping\n        if (ctx) {\n          throw Error(\"Mode not supported for ex mappings\");\n        }\n        var commandName = lhs.substring(1);\n        if (\n          this.commandMap_[commandName] &&\n          this.commandMap_[commandName].user\n        ) {\n          delete this.commandMap_[commandName];\n          return true;\n        }\n      } else {\n        // Key to Ex or key to key mapping\n        var keys = lhs;\n        for (var i = 0; i < defaultKeymap.length; i++) {\n          if (\n            keys == defaultKeymap[i].keys &&\n            defaultKeymap[i].context === ctx\n          ) {\n            defaultKeymap.splice(i, 1);\n            return true;\n          }\n        }\n      }\n    },\n  };\n\n  var exCommands = {\n    colorscheme: function (cm, params) {\n      if (!params.args || params.args.length < 1) {\n        showConfirm(cm, cm.getOption(\"theme\"));\n        return;\n      }\n      cm.setOption(\"theme\", params.args[0]);\n    },\n    map: function (cm, params, ctx) {\n      var mapArgs = params.args;\n      if (!mapArgs || mapArgs.length < 2) {\n        if (cm) {\n          showConfirm(cm, \"Invalid mapping: \" + params.input);\n        }\n        return;\n      }\n      exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);\n    },\n    imap: function (cm, params) {\n      this.map(cm, params, \"insert\");\n    },\n    nmap: function (cm, params) {\n      this.map(cm, params, \"normal\");\n    },\n    vmap: function (cm, params) {\n      this.map(cm, params, \"visual\");\n    },\n    unmap: function (cm, params, ctx) {\n      var mapArgs = params.args;\n      if (\n        !mapArgs ||\n        mapArgs.length < 1 ||\n        !exCommandDispatcher.unmap(mapArgs[0], ctx)\n      ) {\n        if (cm) {\n          showConfirm(cm, \"No such mapping: \" + params.input);\n        }\n      }\n    },\n    move: function (cm, params) {\n      commandDispatcher.processCommand(cm, cm.state.vim, {\n        type: \"motion\",\n        motion: \"moveToLineOrEdgeOfDocument\",\n        motionArgs: { forward: false, explicitRepeat: true, linewise: true },\n        repeatOverride: params.line + 1,\n      });\n    },\n    set: function (cm, params) {\n      var setArgs = params.args;\n      // Options passed through to the setOption/getOption calls. May be passed in by the\n      // local/global versions of the set command\n      var setCfg = params.setCfg || {};\n      if (!setArgs || setArgs.length < 1) {\n        if (cm) {\n          showConfirm(cm, \"Invalid mapping: \" + params.input);\n        }\n        return;\n      }\n      var expr = setArgs[0].split(\"=\");\n      var optionName = expr[0];\n      var value = expr[1];\n      var forceGet = false;\n\n      if (optionName.charAt(optionName.length - 1) == \"?\") {\n        // If post-fixed with ?, then the set is actually a get.\n        if (value) {\n          throw Error(\"Trailing characters: \" + params.argString);\n        }\n        optionName = optionName.substring(0, optionName.length - 1);\n        forceGet = true;\n      }\n      if (value === undefined && optionName.substring(0, 2) == \"no\") {\n        // To set boolean options to false, the option name is prefixed with\n        // 'no'.\n        optionName = optionName.substring(2);\n        value = false;\n      }\n\n      var optionIsBoolean =\n        options[optionName] && options[optionName].type == \"boolean\";\n      if (optionIsBoolean && value == undefined) {\n        // Calling set with a boolean option sets it to true.\n        value = true;\n      }\n      // If no value is provided, then we assume this is a get.\n      if ((!optionIsBoolean && value === undefined) || forceGet) {\n        var oldValue = getOption(optionName, cm, setCfg);\n        if (oldValue instanceof Error) {\n          showConfirm(cm, oldValue.message);\n        } else if (oldValue === true || oldValue === false) {\n          showConfirm(cm, \" \" + (oldValue ? \"\" : \"no\") + optionName);\n        } else {\n          showConfirm(cm, \"  \" + optionName + \"=\" + oldValue);\n        }\n      } else {\n        var setOptionReturn = setOption(optionName, value, cm, setCfg);\n        if (setOptionReturn instanceof Error) {\n          showConfirm(cm, setOptionReturn.message);\n        }\n      }\n    },\n    setlocal: function (cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = { scope: \"local\" };\n      this.set(cm, params);\n    },\n    setglobal: function (cm, params) {\n      // setCfg is passed through to setOption\n      params.setCfg = { scope: \"global\" };\n      this.set(cm, params);\n    },\n    registers: function (cm, params) {\n      var regArgs = params.args;\n      var registers = vimGlobalState.registerController.registers;\n      var regInfo = \"----------Registers----------\\n\\n\";\n      if (!regArgs) {\n        for (var registerName in registers) {\n          var text = registers[registerName].toString();\n          if (text.length) {\n            regInfo += '\"' + registerName + \"    \" + text + \"\\n\";\n          }\n        }\n      } else {\n        var registerName;\n        regArgs = regArgs.join(\"\");\n        for (var i = 0; i < regArgs.length; i++) {\n          registerName = regArgs.charAt(i);\n          if (\n            !vimGlobalState.registerController.isValidRegister(registerName)\n          ) {\n            continue;\n          }\n          var register = registers[registerName] || new Register();\n          regInfo += '\"' + registerName + \"    \" + register.toString() + \"\\n\";\n        }\n      }\n      showConfirm(cm, regInfo);\n    },\n    sort: function (cm, params) {\n      var reverse, ignoreCase, unique, number, pattern;\n      function parseArgs() {\n        if (params.argString) {\n          var args = new CodeMirror.StringStream(params.argString);\n          if (args.eat(\"!\")) {\n            reverse = true;\n          }\n          if (args.eol()) {\n            return;\n          }\n          if (!args.eatSpace()) {\n            return \"Invalid arguments\";\n          }\n          var opts = args.match(/([dinuox]+)?\\s*(\\/.+\\/)?\\s*/);\n          if (!opts && !args.eol()) {\n            return \"Invalid arguments\";\n          }\n          if (opts[1]) {\n            ignoreCase = opts[1].indexOf(\"i\") != -1;\n            unique = opts[1].indexOf(\"u\") != -1;\n            var decimal =\n              opts[1].indexOf(\"d\") != -1 || (opts[1].indexOf(\"n\") != -1 && 1);\n            var hex = opts[1].indexOf(\"x\") != -1 && 1;\n            var octal = opts[1].indexOf(\"o\") != -1 && 1;\n            if (decimal + hex + octal > 1) {\n              return \"Invalid arguments\";\n            }\n            number =\n              (decimal && \"decimal\") || (hex && \"hex\") || (octal && \"octal\");\n          }\n          if (opts[2]) {\n            pattern = new RegExp(\n              opts[2].substr(1, opts[2].length - 2),\n              ignoreCase ? \"i\" : \"\"\n            );\n          }\n        }\n      }\n      var err = parseArgs();\n      if (err) {\n        showConfirm(cm, err + \": \" + params.argString);\n        return;\n      }\n      var lineStart = params.line || cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      if (lineStart == lineEnd) {\n        return;\n      }\n      var curStart = new Pos(lineStart, 0);\n      var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));\n      var text = cm.getRange(curStart, curEnd).split(\"\\n\");\n      var numberRegex = pattern\n        ? pattern\n        : number == \"decimal\"\n        ? /(-?)([\\d]+)/\n        : number == \"hex\"\n        ? /(-?)(?:0x)?([0-9a-f]+)/i\n        : number == \"octal\"\n        ? /([0-7]+)/\n        : null;\n      var radix =\n        number == \"decimal\"\n          ? 10\n          : number == \"hex\"\n          ? 16\n          : number == \"octal\"\n          ? 8\n          : null;\n      var numPart = [],\n        textPart = [];\n      if (number || pattern) {\n        for (var i = 0; i < text.length; i++) {\n          var matchPart = pattern ? text[i].match(pattern) : null;\n          if (matchPart && matchPart[0] != \"\") {\n            numPart.push(matchPart);\n          } else if (!pattern && numberRegex.exec(text[i])) {\n            numPart.push(text[i]);\n          } else {\n            textPart.push(text[i]);\n          }\n        }\n      } else {\n        textPart = text;\n      }\n      function compareFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a = a.toLowerCase();\n          b = b.toLowerCase();\n        }\n        var anum = number && numberRegex.exec(a);\n        var bnum = number && numberRegex.exec(b);\n        if (!anum) {\n          return a < b ? -1 : 1;\n        }\n        anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);\n        bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);\n        return anum - bnum;\n      }\n      function comparePatternFn(a, b) {\n        if (reverse) {\n          var tmp;\n          tmp = a;\n          a = b;\n          b = tmp;\n        }\n        if (ignoreCase) {\n          a[0] = a[0].toLowerCase();\n          b[0] = b[0].toLowerCase();\n        }\n        return a[0] < b[0] ? -1 : 1;\n      }\n      numPart.sort(pattern ? comparePatternFn : compareFn);\n      if (pattern) {\n        for (var i = 0; i < numPart.length; i++) {\n          numPart[i] = numPart[i].input;\n        }\n      } else if (!number) {\n        textPart.sort(compareFn);\n      }\n      text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);\n      if (unique) {\n        // Remove duplicate lines\n        var textOld = text;\n        var lastLine;\n        text = [];\n        for (var i = 0; i < textOld.length; i++) {\n          if (textOld[i] != lastLine) {\n            text.push(textOld[i]);\n          }\n          lastLine = textOld[i];\n        }\n      }\n      cm.replaceRange(text.join(\"\\n\"), curStart, curEnd);\n    },\n    vglobal: function (cm, params) {\n      // global inspects params.commandName\n      this.global(cm, params);\n    },\n    global: function (cm, params) {\n      // a global command is of the form\n      // :[range]g/pattern/[cmd]\n      // argString holds the string /pattern/[cmd]\n      var argString = params.argString;\n      if (!argString) {\n        showConfirm(cm, \"Regular Expression missing from global\");\n        return;\n      }\n      var inverted = params.commandName[0] === \"v\";\n      // range is specified here\n      var lineStart = params.line !== undefined ? params.line : cm.firstLine();\n      var lineEnd = params.lineEnd || params.line || cm.lastLine();\n      // get the tokens from argString\n      var tokens = splitBySlash(argString);\n      var regexPart = argString,\n        cmd;\n      if (tokens.length) {\n        regexPart = tokens[0];\n        cmd = tokens.slice(1, tokens.length).join(\"/\");\n      }\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise\n        // use the regex part as the new query.\n        try {\n          updateSearchQuery(\n            cm,\n            regexPart,\n            true /** ignoreCase */,\n            true /** smartCase */\n          );\n        } catch (e) {\n          showConfirm(cm, \"Invalid regex: \" + regexPart);\n          return;\n        }\n      }\n      // now that we have the regexPart, search for regex matches in the\n      // specified range of lines\n      var query = getSearchState(cm).getQuery();\n      var matchedLines = [];\n      for (var i = lineStart; i <= lineEnd; i++) {\n        var line = cm.getLineHandle(i);\n        var matched = query.test(line.text);\n        if (matched !== inverted) {\n          matchedLines.push(cmd ? line : line.text);\n        }\n      }\n      // if there is no [cmd], just display the list of matched lines\n      if (!cmd) {\n        showConfirm(cm, matchedLines.join(\"\\n\"));\n        return;\n      }\n      var index = 0;\n      var nextCommand = function () {\n        if (index < matchedLines.length) {\n          var line = matchedLines[index++];\n          var lineNum = cm.getLineNumber(line);\n          if (lineNum == null) {\n            nextCommand();\n            return;\n          }\n          var command = lineNum + 1 + cmd;\n          exCommandDispatcher.processCommand(cm, command, {\n            callback: nextCommand,\n          });\n        }\n      };\n      nextCommand();\n    },\n    substitute: function (cm, params) {\n      if (!cm.getSearchCursor) {\n        throw new Error(\n          \"Search feature not available. Requires searchcursor.js or \" +\n            \"any other getSearchCursor implementation.\"\n        );\n      }\n      var argString = params.argString;\n      var tokens = argString ? splitBySeparator(argString, argString[0]) : [];\n      var regexPart,\n        replacePart = \"\",\n        trailing,\n        flagsPart,\n        count;\n      var confirm = false; // Whether to confirm each replace.\n      var global = false; // True to replace all instances on a line, false to replace only 1.\n      if (tokens.length) {\n        regexPart = tokens[0];\n        if (getOption(\"pcre\") && regexPart !== \"\") {\n          regexPart = new RegExp(regexPart).source; //normalize not escaped characters\n        }\n        replacePart = tokens[1];\n        if (replacePart !== undefined) {\n          if (getOption(\"pcre\")) {\n            replacePart = unescapeRegexReplace(\n              replacePart.replace(/([^\\\\])&/g, \"$1$$&\")\n            );\n          } else {\n            replacePart = translateRegexReplace(replacePart);\n          }\n          vimGlobalState.lastSubstituteReplacePart = replacePart;\n        }\n        trailing = tokens[2] ? tokens[2].split(\" \") : [];\n      } else {\n        // either the argString is empty or its of the form ' hello/world'\n        // actually splitBySlash returns a list of tokens\n        // only if the string starts with a '/'\n        if (argString && argString.length) {\n          showConfirm(\n            cm,\n            \"Substitutions should be of the form \" + \":s/pattern/replace/\"\n          );\n          return;\n        }\n      }\n      // After the 3rd slash, we can have flags followed by a space followed\n      // by count.\n      if (trailing) {\n        flagsPart = trailing[0];\n        count = parseInt(trailing[1]);\n        if (flagsPart) {\n          if (flagsPart.indexOf(\"c\") != -1) {\n            confirm = true;\n          }\n          if (flagsPart.indexOf(\"g\") != -1) {\n            global = true;\n          }\n          if (getOption(\"pcre\")) {\n            regexPart = regexPart + \"/\" + flagsPart;\n          } else {\n            regexPart = regexPart.replace(/\\//g, \"\\\\/\") + \"/\" + flagsPart;\n          }\n        }\n      }\n      if (regexPart) {\n        // If regex part is empty, then use the previous query. Otherwise use\n        // the regex part as the new query.\n        try {\n          updateSearchQuery(\n            cm,\n            regexPart,\n            true /** ignoreCase */,\n            true /** smartCase */\n          );\n        } catch (e) {\n          showConfirm(cm, \"Invalid regex: \" + regexPart);\n          return;\n        }\n      }\n      replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;\n      if (replacePart === undefined) {\n        showConfirm(cm, \"No previous substitute regular expression\");\n        return;\n      }\n      var state = getSearchState(cm);\n      var query = state.getQuery();\n      var lineStart =\n        params.line !== undefined ? params.line : cm.getCursor().line;\n      var lineEnd = params.lineEnd || lineStart;\n      if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) {\n        lineEnd = Infinity;\n      }\n      if (count) {\n        lineStart = lineEnd;\n        lineEnd = lineStart + count - 1;\n      }\n      var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));\n      var cursor = cm.getSearchCursor(query, startPos);\n      cm.pushUndoStop();\n      doReplace(\n        cm,\n        confirm,\n        global,\n        lineStart,\n        lineEnd,\n        cursor,\n        query,\n        replacePart,\n        params.callback\n      );\n    },\n    redo: CodeMirror.commands.redo,\n    undo: CodeMirror.commands.undo,\n    write: function (cm) {\n      if (CodeMirror.commands.save) {\n        // If a save command is defined, call it.\n        CodeMirror.commands.save(cm);\n      } else if (cm.save) {\n        // Saves to text area if no save command is defined and cm.save() is available.\n        cm.save();\n      }\n    },\n    nohlsearch: function (cm) {\n      clearSearchHighlight(cm);\n    },\n    yank: function (cm) {\n      var cur = copyCursor(cm.getCursor());\n      var line = cur.line;\n      var lineText = cm.getLine(line);\n      vimGlobalState.registerController.pushText(\n        \"0\",\n        \"yank\",\n        lineText,\n        true,\n        true\n      );\n    },\n    delmarks: function (cm, params) {\n      if (!params.argString || !trim(params.argString)) {\n        showConfirm(cm, \"Argument required\");\n        return;\n      }\n\n      var state = cm.state.vim;\n      var stream = new CodeMirror.StringStream(trim(params.argString));\n      while (!stream.eol()) {\n        stream.eatSpace();\n\n        // Record the streams position at the beginning of the loop for use\n        // in error messages.\n        var count = stream.pos;\n\n        if (!stream.match(/[a-zA-Z]/, false)) {\n          showConfirm(\n            cm,\n            \"Invalid argument: \" + params.argString.substring(count)\n          );\n          return;\n        }\n\n        var sym = stream.next();\n        // Check if this symbol is part of a range\n        if (stream.match(\"-\", true)) {\n          // This symbol is part of a range.\n\n          // The range must terminate at an alphabetic character.\n          if (!stream.match(/[a-zA-Z]/, false)) {\n            showConfirm(\n              cm,\n              \"Invalid argument: \" + params.argString.substring(count)\n            );\n            return;\n          }\n\n          var startMark = sym;\n          var finishMark = stream.next();\n          // The range must terminate at an alphabetic character which\n          // shares the same case as the start of the range.\n          if (\n            (isLowerCase(startMark) && isLowerCase(finishMark)) ||\n            (isUpperCase(startMark) && isUpperCase(finishMark))\n          ) {\n            var start = startMark.charCodeAt(0);\n            var finish = finishMark.charCodeAt(0);\n            if (start >= finish) {\n              showConfirm(\n                cm,\n                \"Invalid argument: \" + params.argString.substring(count)\n              );\n              return;\n            }\n\n            // Because marks are always ASCII values, and we have\n            // determined that they are the same case, we can use\n            // their char codes to iterate through the defined range.\n            for (var j = 0; j <= finish - start; j++) {\n              var mark = String.fromCharCode(start + j);\n              delete state.marks[mark];\n            }\n          } else {\n            showConfirm(cm, \"Invalid argument: \" + startMark + \"-\");\n            return;\n          }\n        } else {\n          // This symbol is a valid mark, and is not part of a range.\n          delete state.marks[sym];\n        }\n      }\n    },\n  };\n\n  var exCommandDispatcher = new ExCommandDispatcher();\n\n  /**\n   * @param {CodeMirror} cm CodeMirror instance we are in.\n   * @param {boolean} confirm Whether to confirm each replace.\n   * @param {Cursor} lineStart Line to start replacing from.\n   * @param {Cursor} lineEnd Line to stop replacing at.\n   * @param {RegExp} query Query for performing matches with.\n   * @param {string} replaceWith Text to replace matches with. May contain $1,\n   *     $2, etc for replacing captured groups using JavaScript replace.\n   * @param {function()} callback A callback for when the replace is done.\n   */\n  function doReplace(\n    cm,\n    confirm,\n    global,\n    lineStart,\n    lineEnd,\n    searchCursor,\n    query,\n    replaceWith,\n    callback\n  ) {\n    // Set up all the functions.\n    cm.state.vim.exMode = true;\n    var done = false;\n    var lastPos, modifiedLineNumber, joined;\n    function replaceAll() {\n      cm.operation(function () {\n        while (!done) {\n          replace();\n          next();\n        }\n        stop();\n      });\n    }\n    function replace() {\n      var text = cm.getRange(searchCursor.from(), searchCursor.to());\n      var newText = text.replace(query, replaceWith);\n      var unmodifiedLineNumber = searchCursor.to().line;\n      searchCursor.replace(newText);\n      modifiedLineNumber = searchCursor.to().line;\n      lineEnd += modifiedLineNumber - unmodifiedLineNumber;\n      joined = modifiedLineNumber < unmodifiedLineNumber;\n    }\n    function findNextValidMatch() {\n      var lastMatchTo = lastPos && copyCursor(searchCursor.to());\n      var match = searchCursor.findNext();\n      if (\n        match &&\n        !match[0] &&\n        lastMatchTo &&\n        cursorEqual(searchCursor.from(), lastMatchTo)\n      ) {\n        match = searchCursor.findNext();\n      }\n      return match;\n    }\n    function next() {\n      // The below only loops to skip over multiple occurrences on the same\n      // line when 'global' is not true.\n      while (\n        findNextValidMatch() &&\n        isInRange(searchCursor.from(), lineStart, lineEnd)\n      ) {\n        if (\n          !global &&\n          searchCursor.from().line == modifiedLineNumber &&\n          !joined\n        ) {\n          continue;\n        }\n        cm.scrollIntoView(searchCursor.from(), 30);\n        cm.setSelection(searchCursor.from(), searchCursor.to());\n        lastPos = searchCursor.from();\n        done = false;\n        return;\n      }\n      done = true;\n    }\n    function stop(close) {\n      if (close) {\n        close();\n      }\n      cm.focus();\n      if (lastPos) {\n        cm.setCursor(lastPos);\n        var vim = cm.state.vim;\n        vim.exMode = false;\n        vim.lastHPos = vim.lastHSPos = lastPos.ch;\n      }\n      if (callback) {\n        callback();\n      }\n    }\n    function onPromptKeyDown(e, _value, close) {\n      // Swallow all keys.\n      CodeMirror.e_stop(e);\n      var keyName = CodeMirror.keyName(e);\n      switch (keyName) {\n        case \"Y\":\n          replace();\n          next();\n          break;\n        case \"N\":\n          next();\n          break;\n        case \"A\":\n          // replaceAll contains a call to close of its own. We don't want it\n          // to fire too early or multiple times.\n          var savedCallback = callback;\n          callback = undefined;\n          cm.operation(replaceAll);\n          callback = savedCallback;\n          break;\n        case \"L\":\n          replace();\n        // fall through and exit.\n        case \"Q\":\n        case \"Esc\":\n        case \"Ctrl-C\":\n        case \"Ctrl-[\":\n          stop(close);\n          break;\n      }\n      if (done) {\n        stop(close);\n      }\n      return true;\n    }\n\n    // Actually do replace.\n    next();\n    if (done) {\n      showConfirm(cm, \"No matches for \" + query.source);\n      return;\n    }\n    if (!confirm) {\n      replaceAll();\n      if (callback) {\n        callback();\n      }\n      return;\n    }\n    showPrompt(cm, {\n      prefix: dom(\n        \"span\",\n        \"replace with \",\n        dom(\"strong\", replaceWith),\n        \" (y/n/a/q/l)\"\n      ),\n      onKeyDown: onPromptKeyDown,\n    });\n  }\n\n  CodeMirror.keyMap.vim = {\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey,\n  };\n\n  function exitInsertMode(cm) {\n    var vim = cm.state.vim;\n    var macroModeState = vimGlobalState.macroModeState;\n    var insertModeChangeRegister =\n      vimGlobalState.registerController.getRegister(\".\");\n    var isPlaying = macroModeState.isPlaying;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!isPlaying) {\n      cm.off(\"change\", onChange);\n      CodeMirror.off(cm.getInputField(), \"keydown\", onKeyEventTargetKeyDown);\n    }\n    if (!isPlaying && vim.insertModeRepeat > 1) {\n      // Perform insert mode repeat for commands like 3,a and 3,o.\n      repeatLastEdit(\n        cm,\n        vim,\n        vim.insertModeRepeat - 1,\n        true /** repeatForInsert */\n      );\n      vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;\n    }\n    delete vim.insertModeRepeat;\n    vim.insertMode = false;\n    cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);\n    cm.setOption(\"keyMap\", \"vim\");\n    cm.setOption(\"disableInput\", true);\n    cm.toggleOverwrite(false); // exit replace mode if we were in it.\n    // update the \". register before exiting insert mode\n    insertModeChangeRegister.setText(lastChange.changes.join(\"\"));\n    CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"normal\" });\n    if (macroModeState.isRecording) {\n      logInsertModeChange(macroModeState);\n    }\n    cm.enterVimMode();\n  }\n\n  function _mapCommand(command) {\n    defaultKeymap.unshift(command);\n  }\n\n  function mapCommand(keys, type, name, args, extra) {\n    var command = { keys: keys, type: type };\n    command[type] = name;\n    command[type + \"Args\"] = args;\n    for (var key in extra) command[key] = extra[key];\n    _mapCommand(command);\n  }\n\n  // The timeout in milliseconds for the two-character ESC keymap should be\n  // adjusted according to your typing speed to prevent false positives.\n  defineOption(\"insertModeEscKeysTimeout\", 200, \"number\");\n\n  CodeMirror.keyMap[\"vim-insert\"] = {\n    // TODO: override navigation keys so that Esc will cancel automatic\n    // indentation from o, O, i_<CR>\n    fallthrough: [\"default\"],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey,\n  };\n\n  CodeMirror.keyMap[\"vim-replace\"] = {\n    Backspace: \"goCharLeft\",\n    fallthrough: [\"vim-insert\"],\n    attach: attachVimMap,\n    detach: detachVimMap,\n    call: cmKey,\n  };\n\n  function executeMacroRegister(cm, vim, macroModeState, registerName) {\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (registerName == \":\") {\n      // Read-only register containing last Ex command.\n      if (register.keyBuffer[0]) {\n        exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);\n      }\n      macroModeState.isPlaying = false;\n      return;\n    }\n    var keyBuffer = register.keyBuffer;\n    var imc = 0;\n    macroModeState.isPlaying = true;\n    macroModeState.replaySearchQueries = register.searchQueries.slice(0);\n    for (var i = 0; i < keyBuffer.length; i++) {\n      var text = keyBuffer[i];\n      var match, key;\n      while (text) {\n        // Pull off one command key, which is either a single character\n        // or a special sequence wrapped in '<' and '>', e.g. '<Space>'.\n        match = /<\\w+-.+?>|<\\w+>|./.exec(text);\n        key = match[0];\n        text = text.substring(match.index + key.length);\n        vimApi.handleKey(cm, key, \"macro\");\n        if (vim.insertMode) {\n          var changes = register.insertModeChanges[imc++].changes;\n          vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;\n          repeatInsertModeChanges(cm, changes, 1);\n          exitInsertMode(cm);\n        }\n      }\n    }\n    macroModeState.isPlaying = false;\n  }\n\n  function logKey(macroModeState, key) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register) {\n      register.pushText(key);\n    }\n  }\n\n  function logInsertModeChange(macroModeState) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushInsertModeChanges) {\n      register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);\n    }\n  }\n\n  function logSearchQuery(macroModeState, query) {\n    if (macroModeState.isPlaying) {\n      return;\n    }\n    var registerName = macroModeState.latestRegister;\n    var register = vimGlobalState.registerController.getRegister(registerName);\n    if (register && register.pushSearchQuery) {\n      register.pushSearchQuery(query);\n    }\n  }\n\n  /**\n   * Listens for changes made in insert mode.\n   * Should only be active in insert mode.\n   */\n  function onChange(cm, changeObj) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    if (!macroModeState.isPlaying) {\n      while (changeObj) {\n        lastChange.expectCursorActivityForChange = true;\n        if (lastChange.ignoreCount > 1) {\n          lastChange.ignoreCount--;\n        } else if (\n          changeObj.origin == \"+input\" ||\n          changeObj.origin == \"paste\" ||\n          changeObj.origin === undefined /* only in testing */\n        ) {\n          var selectionCount = cm.listSelections().length;\n          if (selectionCount > 1) lastChange.ignoreCount = selectionCount;\n          var text = changeObj.text.join(\"\\n\");\n          if (lastChange.maybeReset) {\n            lastChange.changes = [];\n            lastChange.maybeReset = false;\n          }\n          if (text) {\n            if (cm.state.overwrite && !/\\n/.test(text)) {\n              lastChange.changes.push([text]);\n            } else {\n              lastChange.changes.push(text);\n            }\n          }\n        }\n        // Change objects may be chained with next.\n        changeObj = changeObj.next;\n      }\n    }\n  }\n\n  /**\n   * Listens for any kind of cursor activity on CodeMirror.\n   */\n  function onCursorActivity(cm) {\n    var vim = cm.state.vim;\n    if (vim.insertMode) {\n      // Tracking cursor activity in insert mode (for macro support).\n      var macroModeState = vimGlobalState.macroModeState;\n      if (macroModeState.isPlaying) {\n        return;\n      }\n      var lastChange = macroModeState.lastInsertModeChanges;\n      if (lastChange.expectCursorActivityForChange) {\n        lastChange.expectCursorActivityForChange = false;\n      } else {\n        // Cursor moved outside the context of an edit. Reset the change.\n        lastChange.maybeReset = true;\n      }\n    } else if (!cm.curOp.isVimOp) {\n      handleExternalSelection(cm, vim);\n    }\n  }\n  function handleExternalSelection(cm, vim) {\n    var anchor = cm.getCursor(\"anchor\");\n    var head = cm.getCursor(\"head\");\n    // Enter or exit visual mode to match mouse selection.\n    if (vim.visualMode && !cm.somethingSelected()) {\n      exitVisualMode(cm, false);\n    } else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {\n      vim.visualMode = true;\n      vim.visualLine = false;\n      CodeMirror.signal(cm, \"vim-mode-change\", { mode: \"visual\" });\n    }\n    if (vim.visualMode) {\n      // Bind CodeMirror selection model to vim selection model.\n      // Mouse selections are considered visual characterwise.\n      var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;\n      var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;\n      head = offsetCursor(head, 0, headOffset);\n      anchor = offsetCursor(anchor, 0, anchorOffset);\n      vim.sel = {\n        anchor: anchor,\n        head: head,\n      };\n      updateMark(cm, vim, \"<\", cursorMin(head, anchor));\n      updateMark(cm, vim, \">\", cursorMax(head, anchor));\n    } else if (!vim.insertMode) {\n      // Reset lastHPos if selection was modified by something outside of vim mode e.g. by mouse.\n      vim.lastHPos = cm.getCursor().ch;\n    }\n  }\n\n  /** Wrapper for special keys pressed in insert mode */\n  function InsertModeKey(keyName) {\n    this.keyName = keyName;\n  }\n\n  /**\n   * Handles raw key down events from the text area.\n   * - Should only be active in insert mode.\n   * - For recording deletes in insert mode.\n   */\n  function onKeyEventTargetKeyDown(e) {\n    var macroModeState = vimGlobalState.macroModeState;\n    var lastChange = macroModeState.lastInsertModeChanges;\n    var keyName = CodeMirror.keyName(e);\n    if (!keyName) {\n      return;\n    }\n    function onKeyFound() {\n      if (lastChange.maybeReset) {\n        lastChange.changes = [];\n        lastChange.maybeReset = false;\n      }\n      lastChange.changes.push(new InsertModeKey(keyName));\n      return true;\n    }\n    if (keyName.indexOf(\"Delete\") != -1 || keyName.indexOf(\"Backspace\") != -1) {\n      CodeMirror.lookupKey(keyName, \"vim-insert\", onKeyFound);\n    }\n  }\n\n  /**\n   * Repeats the last edit, which includes exactly 1 command and at most 1\n   * insert. Operator and motion commands are read from lastEditInputState,\n   * while action commands are read from lastEditActionCommand.\n   *\n   * If repeatForInsert is true, then the function was called by\n   * exitInsertMode to repeat the insert mode changes the user just made. The\n   * corresponding enterInsertMode call was made with a count.\n   */\n  function repeatLastEdit(cm, vim, repeat, repeatForInsert) {\n    var macroModeState = vimGlobalState.macroModeState;\n    macroModeState.isPlaying = true;\n    var isAction = !!vim.lastEditActionCommand;\n    var cachedInputState = vim.inputState;\n    function repeatCommand() {\n      if (isAction) {\n        commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);\n      } else {\n        commandDispatcher.evalInput(cm, vim);\n      }\n    }\n    function repeatInsert(repeat) {\n      if (macroModeState.lastInsertModeChanges.changes.length > 0) {\n        // For some reason, repeat cw in desktop VIM does not repeat\n        // insert mode changes. Will conform to that behavior.\n        repeat = !vim.lastEditActionCommand ? 1 : repeat;\n        var changeObject = macroModeState.lastInsertModeChanges;\n        repeatInsertModeChanges(cm, changeObject.changes, repeat);\n      }\n    }\n    vim.inputState = vim.lastEditInputState;\n    if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) {\n      // o and O repeat have to be interlaced with insert repeats so that the\n      // insertions appear on separate lines instead of the last line.\n      for (var i = 0; i < repeat; i++) {\n        repeatCommand();\n        repeatInsert(1);\n      }\n    } else {\n      if (!repeatForInsert) {\n        // Hack to get the cursor to end up at the right place. If I is\n        // repeated in insert mode repeat, cursor will be 1 insert\n        // change set left of where it should be.\n        repeatCommand();\n      }\n      repeatInsert(repeat);\n    }\n    vim.inputState = cachedInputState;\n    if (vim.insertMode && !repeatForInsert) {\n      // Don't exit insert mode twice. If repeatForInsert is set, then we\n      // were called by an exitInsertMode call lower on the stack.\n      exitInsertMode(cm);\n    }\n    macroModeState.isPlaying = false;\n  }\n\n  function repeatInsertModeChanges(cm, changes, repeat) {\n    function keyHandler(binding) {\n      if (typeof binding == \"string\") {\n        CodeMirror.commands[binding](cm);\n      } else {\n        binding(cm);\n      }\n      return true;\n    }\n    var head = cm.getCursor(\"head\");\n    var visualBlock =\n      vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;\n    if (visualBlock) {\n      // Set up block selection again for repeating the changes.\n      selectForInsert(cm, head, visualBlock + 1);\n      repeat = cm.listSelections().length;\n      cm.setCursor(head);\n    }\n    for (var i = 0; i < repeat; i++) {\n      if (visualBlock) {\n        cm.setCursor(offsetCursor(head, i, 0));\n      }\n      for (var j = 0; j < changes.length; j++) {\n        var change = changes[j];\n        if (change instanceof InsertModeKey) {\n          CodeMirror.lookupKey(change.keyName, \"vim-insert\", keyHandler);\n        } else if (typeof change == \"string\") {\n          window.cm = cm;\n          cm.replaceSelections(change);\n        } else {\n          var start = cm.getCursor();\n          var end = offsetCursor(start, 0, change[0].length);\n          cm.replaceRange(change[0], start, end);\n          cm.setCursor(end);\n        }\n      }\n    }\n    if (visualBlock) {\n      cm.setCursor(offsetCursor(head, 0, 1));\n    }\n  }\n\n  resetVimGlobalState();\n  return vimApi;\n};\n// Initialize Vim and make it available as an API.\nCodeMirror.Vim = Vim();\n\nexport { Vim };\nexport default CodeMirror;\n","import type * as MonacoEditor from \"monaco-editor\";\n\nexport interface VimModeChangeEvent {\n  mode: string;\n  subMode?: string;\n}\n\ntype Sanitizer = ((node: Node) => Node) | null;\n\ninterface StatusBarInputOptions {\n  selectValueOnOpen?: boolean;\n  value?: string;\n  onKeyUp?: (event: KeyboardEvent, value: string, close: () => void) => void;\n  onKeyDown?: (\n    event: KeyboardEvent,\n    value: string,\n    close: () => void,\n  ) => boolean | void;\n  onKeyInput?: (event: InputEvent, value: string, close: () => void) => void;\n  onBlur?: (event: FocusEvent, close: () => void) => void;\n  closeOnBlur?: boolean;\n  closeOnEnter?: boolean;\n}\n\ninterface StatusBarInput {\n  callback?: (value: string) => void;\n  options?: StatusBarInputOptions;\n  node: HTMLInputElement;\n}\n\nexport default class VimStatusBar {\n  private readonly node: HTMLElement;\n  private readonly modeInfoNode: HTMLSpanElement;\n  private readonly secInfoNode: HTMLSpanElement;\n  private readonly notifNode: HTMLSpanElement;\n  private readonly keyInfoNode: HTMLSpanElement;\n  private readonly editor: MonacoEditor.editor.IStandaloneCodeEditor | null;\n  private readonly sanitizer: Sanitizer;\n  private input: StatusBarInput | null = null;\n  private notifTimeout?: ReturnType<typeof setTimeout>;\n\n  constructor(\n    node: HTMLElement,\n    editor: MonacoEditor.editor.IStandaloneCodeEditor | null,\n    sanitizer: Sanitizer = null,\n  ) {\n    this.node = node;\n    this.modeInfoNode = document.createElement(\"span\");\n    this.secInfoNode = document.createElement(\"span\");\n    this.notifNode = document.createElement(\"span\");\n    this.notifNode.className = \"vim-notification\";\n    this.keyInfoNode = document.createElement(\"span\");\n    this.keyInfoNode.setAttribute(\"style\", \"float: right\");\n    this.node.appendChild(this.modeInfoNode);\n    this.node.appendChild(this.secInfoNode);\n    this.node.appendChild(this.notifNode);\n    this.node.appendChild(this.keyInfoNode);\n    this.toggleVisibility(false);\n    this.editor = editor;\n    this.sanitizer = sanitizer;\n  }\n\n  setMode(ev: VimModeChangeEvent) {\n    if (ev.mode === \"visual\") {\n      if (ev.subMode === \"linewise\") {\n        this.setText(\"--VISUAL LINE--\");\n      } else if (ev.subMode === \"blockwise\") {\n        this.setText(\"--VISUAL BLOCK--\");\n      } else {\n        this.setText(\"--VISUAL--\");\n      }\n      return;\n    }\n\n    this.setText(`--${ev.mode.toUpperCase()}--`);\n  }\n\n  setKeyBuffer(key: string) {\n    this.keyInfoNode.textContent = key;\n  }\n\n  setSec(\n    text: Node | string | null | undefined,\n    callback?: (value: string) => void,\n    options?: StatusBarInputOptions,\n  ) {\n    this.notifNode.textContent = \"\";\n    if (text === undefined) {\n      return this.closeInput;\n    }\n\n    this.setInnerHtml_(this.secInfoNode, text);\n    const input = this.secInfoNode.querySelector(\"input\");\n\n    if (input) {\n      input.focus();\n      this.input = {\n        callback,\n        options,\n        node: input,\n      };\n\n      if (options) {\n        if (options.selectValueOnOpen) {\n          input.select();\n        }\n\n        if (options.value) {\n          input.value = options.value;\n        }\n      }\n\n      this.addInputListeners();\n    }\n\n    return this.closeInput;\n  }\n\n  setText(text: string) {\n    this.modeInfoNode.textContent = text;\n  }\n\n  toggleVisibility(toggle: boolean) {\n    if (toggle) {\n      this.node.style.display = \"block\";\n    } else {\n      this.node.style.display = \"none\";\n    }\n\n    if (this.input) {\n      this.removeInputListeners();\n    }\n\n    if (this.notifTimeout) {\n      clearTimeout(this.notifTimeout);\n    }\n  }\n\n  closeInput = () => {\n    this.removeInputListeners();\n    this.input = null;\n    this.setSec(\"\");\n\n    if (this.editor) {\n      this.editor.focus();\n    }\n  };\n\n  clear = () => {\n    this.setInnerHtml_(this.node, \"\");\n  };\n\n  inputKeyUp = (e: KeyboardEvent) => {\n    if (!this.input) {\n      return;\n    }\n    const { options } = this.input;\n    if (options && options.onKeyUp) {\n      options.onKeyUp(\n        e,\n        (e.target as HTMLInputElement).value,\n        this.closeInput,\n      );\n    }\n  };\n\n  inputKeyInput = (e: InputEvent) => {\n    if (!this.input) {\n      return;\n    }\n    const { options } = this.input;\n    if (options && options.onKeyInput) {\n      options.onKeyInput(e, (e.target as HTMLInputElement).value, this.closeInput);\n    }\n  };\n\n  inputBlur = (event: FocusEvent) => {\n    if (!this.input) {\n      return;\n    }\n    const { options } = this.input;\n\n    if (options?.onBlur) {\n      options.onBlur(event, this.closeInput);\n    }\n\n    if (options?.closeOnBlur) {\n      this.closeInput();\n    }\n  };\n\n  inputKeyDown = (e: KeyboardEvent) => {\n    if (!this.input) {\n      return;\n    }\n    const { options, callback } = this.input;\n\n    if (\n      options &&\n      options.onKeyDown &&\n      options.onKeyDown(e, (e.target as HTMLInputElement).value, this.closeInput)\n    ) {\n      return;\n    }\n\n    if (\n      e.keyCode === 27 ||\n      (options && options.closeOnEnter !== false && e.keyCode == 13)\n    ) {\n      this.input.node.blur();\n      e.stopPropagation();\n      this.closeInput();\n    }\n\n    if (e.keyCode === 13 && callback) {\n      e.stopPropagation();\n      e.preventDefault();\n      callback((e.target as HTMLInputElement).value);\n    }\n  };\n\n  addInputListeners() {\n    if (!this.input) {\n      return;\n    }\n    const { node } = this.input;\n    node.addEventListener(\"keyup\", this.inputKeyUp);\n    node.addEventListener(\"keydown\", this.inputKeyDown);\n    node.addEventListener(\"input\", this.inputKeyInput);\n    node.addEventListener(\"blur\", this.inputBlur);\n  }\n\n  removeInputListeners() {\n    if (!this.input || !this.input.node) {\n      return;\n    }\n\n    const { node } = this.input;\n    node.removeEventListener(\"keyup\", this.inputKeyUp);\n    node.removeEventListener(\"keydown\", this.inputKeyDown);\n    node.removeEventListener(\"input\", this.inputKeyInput);\n    node.removeEventListener(\"blur\", this.inputBlur);\n  }\n\n  showNotification(text: string | Node) {\n    const sp = document.createElement(\"span\");\n    this.setInnerHtml_(sp, text);\n    this.notifNode.textContent = sp.textContent;\n    this.notifTimeout = setTimeout(() => {\n      this.notifNode.textContent = \"\";\n    }, 5000);\n  }\n\n  setInnerHtml_(element: HTMLElement, htmlContents?: Node | string | null) {\n    // Clear out previous contents first.\n    while (element.childNodes.length) {\n      element.removeChild(element.childNodes[0]);\n    }\n    if (!htmlContents) {\n      return;\n    }\n    if (typeof htmlContents === \"string\") {\n      element.appendChild(document.createTextNode(htmlContents));\n      return;\n    }\n    const node = this.sanitizer ? this.sanitizer(htmlContents) : htmlContents;\n    element.appendChild(node);\n  }\n}\n","import type * as MonacoEditor from \"monaco-editor\";\nimport VimMode from \"./cm/keymap_vim\";\nimport StatusBar from \"./statusbar\";\n\ntype Sanitizer = ((node: Node) => Node) | null;\ntype StatusBarCtor = new (\n  node: HTMLElement,\n  editor: MonacoEditor.editor.IStandaloneCodeEditor,\n  sanitizer?: Sanitizer,\n) => StatusBar;\n\nexport type VimAdapterInstance = InstanceType<typeof VimMode>;\n\nexport function initVimMode(\n  editor: MonacoEditor.editor.IStandaloneCodeEditor,\n  statusbarNode: HTMLElement | null = null,\n  StatusBarClass: StatusBarCtor = StatusBar,\n  sanitizer: Sanitizer = null,\n): VimAdapterInstance {\n  const vimAdapter = new VimMode(editor);\n\n  if (!statusbarNode) {\n    vimAdapter.attach();\n    return vimAdapter;\n  }\n\n  const statusBar = new StatusBarClass(statusbarNode, editor, sanitizer);\n  let keyBuffer = \"\";\n\n  vimAdapter.on(\"vim-mode-change\", (mode) => {\n    statusBar.setMode(mode);\n  });\n\n  vimAdapter.on(\"vim-keypress\", (key) => {\n    if (key === \":\") {\n      keyBuffer = \"\";\n    } else {\n      keyBuffer += key;\n    }\n    statusBar.setKeyBuffer(keyBuffer);\n  });\n\n  vimAdapter.on(\"vim-command-done\", () => {\n    keyBuffer = \"\";\n    statusBar.setKeyBuffer(keyBuffer);\n  });\n\n  vimAdapter.on(\"dispose\", function () {\n    statusBar.toggleVisibility(false);\n    statusBar.closeInput();\n    statusBar.clear();\n  });\n\n  statusBar.toggleVisibility(true);\n  vimAdapter.setStatusBar(statusBar);\n  vimAdapter.attach();\n\n  return vimAdapter;\n}\n\nexport { VimMode, StatusBar };\n"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],"mappings":";;;;;;;;;;;;AAKA,IAAa,oBAAb,MAA+B;CAC3B,YAAY,WAAW;AACnB,OAAK,YAAY;AACjB,OAAK,YAAY;AACjB,OAAK,aAAa;;CAEtB,IAAI,KAAK;EACL,MAAM,MAAM,KAAK,UAAU,IAAI;AAC/B,MAAI,KAAK,eAAe,KAAK;AACzB,QAAK,aAAa;AAClB,QAAK,YAAY,KAAK,UAAU,IAAI;;AAExC,SAAO,KAAK;;;;;;ACbpB,IAAa,OAAb,MAAkB;CACd,YAAY,UAAU;AAClB,OAAK,WAAW;AAChB,OAAK,UAAU;;;;;;;;CAQnB,WAAW;AACP,MAAI,CAAC,KAAK,QACN,KAAI;AACA,QAAK,SAAS,KAAK,UAAU;WAE1B,KAAK;AACR,QAAK,SAAS;YAEV;AACJ,QAAK,UAAU;;AAGvB,MAAI,KAAK,OACL,OAAM,KAAK;AAEf,SAAO,KAAK;;;;;CAKhB,IAAI,WAAW;AAAE,SAAO,KAAK;;;;;;AC/BjC,IAAIA;;;;AA4CJ,SAAgB,uBAAuB,OAAO;AAC1C,QAAO,MAAM,QAAQ,mCAAmC,OAAO;;AA8DnE,SAAgB,aAAa,cAAc,SAAS,UAAU,EAAE,EAAE;AAC9D,KAAI,CAAC,aACD,OAAM,IAAI,MAAM,wCAAwC;AAE5D,KAAI,CAAC,QACD,gBAAe,uBAAuB,aAAa;AAEvD,KAAI,QAAQ,WAAW;AACnB,MAAI,CAAC,KAAK,KAAK,aAAa,OAAO,EAAE,CAAC,CAClC,gBAAe,QAAQ;AAE3B,MAAI,CAAC,KAAK,KAAK,aAAa,OAAO,aAAa,SAAS,EAAE,CAAC,CACxD,gBAAe,eAAe;;CAGtC,IAAI,YAAY;AAChB,KAAI,QAAQ,OACR,cAAa;AAEjB,KAAI,CAAC,QAAQ,UACT,cAAa;AAEjB,KAAI,QAAQ,UACR,cAAa;AAEjB,KAAI,QAAQ,QACR,cAAa;AAEjB,QAAO,IAAI,OAAO,cAAc,UAAU;;;;;;AA0B9C,SAAgB,wBAAwB,KAAK;AACzC,MAAK,IAAI,IAAI,GAAG,MAAM,IAAI,QAAQ,IAAI,KAAK,KAAK;EAC5C,MAAM,SAAS,IAAI,WAAW,EAAE;AAChC,MAAI,WAAW,MAAkB,WAAW,EACxC,QAAO;;AAGf,QAAO;;;;;;AAMX,SAAgB,qBAAqB,KAAK,QAAQ,GAAG,MAAM,IAAI,QAAQ;AACnE,MAAK,IAAI,IAAI,OAAO,IAAI,KAAK,KAAK;EAC9B,MAAM,SAAS,IAAI,WAAW,EAAE;AAChC,MAAI,WAAW,MAAkB,WAAW,EACxC,QAAO,IAAI,UAAU,OAAO,EAAE;;AAGtC,QAAO,IAAI,UAAU,OAAO,IAAI;;;;;AAoIpC,SAAgB,gBAAgB,UAAU;AACtC,QAAQ,SAAU,YAAY,YAAY;;;;;AAK9C,SAAgB,eAAe,UAAU;AACrC,QAAQ,SAAU,YAAY,YAAY;;;;;AAK9C,SAAgB,iBAAiB,eAAe,cAAc;AAC1D,SAAS,gBAAgB,SAAW,OAAO,eAAe,SAAU;;;;;AAKxE,SAAgB,iBAAiB,KAAK,KAAK,QAAQ;CAC/C,MAAM,WAAW,IAAI,WAAW,OAAO;AACvC,KAAI,gBAAgB,SAAS,IAAI,SAAS,IAAI,KAAK;EAC/C,MAAM,eAAe,IAAI,WAAW,SAAS,EAAE;AAC/C,MAAI,eAAe,aAAa,CAC5B,QAAO,iBAAiB,UAAU,aAAa;;AAGvD,QAAO;;;;;AAKX,SAAS,iBAAiB,KAAK,QAAQ;CACnC,MAAM,WAAW,IAAI,WAAW,SAAS,EAAE;AAC3C,KAAI,eAAe,SAAS,IAAI,SAAS,GAAG;EACxC,MAAM,eAAe,IAAI,WAAW,SAAS,EAAE;AAC/C,MAAI,gBAAgB,aAAa,CAC7B,QAAO,iBAAiB,cAAc,SAAS;;AAGvD,QAAO;;AAEX,IAAa,oBAAb,MAA+B;CAC3B,YAAY,KAAK,SAAS,GAAG;AACzB,OAAK,OAAO;AACZ,OAAK,OAAO,IAAI;AAChB,OAAK,UAAU;;CAEnB,IAAI,SAAS;AACT,SAAO,KAAK;;CAEhB,UAAU,QAAQ;AACd,OAAK,UAAU;;CAEnB,gBAAgB;EACZ,MAAM,YAAY,iBAAiB,KAAK,MAAM,KAAK,QAAQ;AAC3D,OAAK,WAAY,aAAa,QAAgD,IAAI;AAClF,SAAO;;CAEX,gBAAgB;EACZ,MAAM,YAAY,iBAAiB,KAAK,MAAM,KAAK,MAAM,KAAK,QAAQ;AACtE,OAAK,WAAY,aAAa,QAAgD,IAAI;AAClF,SAAO;;CAEX,MAAM;AACF,SAAQ,KAAK,WAAW,KAAK;;;AAGrC,IAAa,mBAAb,MAA8B;CAC1B,YAAY,KAAK,SAAS,GAAG;AACzB,OAAK,YAAY,IAAI,kBAAkB,KAAK,OAAO;;CAEvD,IAAI,SAAS;AACT,SAAO,KAAK,UAAU;;CAE1B,qBAAqB;EACjB,MAAM,oBAAoB,kBAAkB,aAAa;EACzD,MAAM,WAAW,KAAK;EACtB,MAAM,gBAAgB,SAAS;EAC/B,IAAI,oBAAoB,kBAAkB,qBAAqB,SAAS,eAAe,CAAC;AACxF,SAAO,CAAC,SAAS,KAAK,EAAE;GACpB,MAAM,SAAS,SAAS;GACxB,MAAM,wBAAwB,kBAAkB,qBAAqB,SAAS,eAAe,CAAC;AAC9F,OAAI,8BAA8B,mBAAmB,sBAAsB,EAAE;AAEzE,aAAS,UAAU,OAAO;AAC1B;;AAEJ,uBAAoB;;AAExB,SAAQ,SAAS,SAAS;;CAE9B,qBAAqB;EACjB,MAAM,oBAAoB,kBAAkB,aAAa;EACzD,MAAM,WAAW,KAAK;EACtB,MAAM,gBAAgB,SAAS;EAC/B,IAAI,oBAAoB,kBAAkB,qBAAqB,SAAS,eAAe,CAAC;AACxF,SAAO,SAAS,SAAS,GAAG;GACxB,MAAM,SAAS,SAAS;GACxB,MAAM,wBAAwB,kBAAkB,qBAAqB,SAAS,eAAe,CAAC;AAC9F,OAAI,8BAA8B,uBAAuB,kBAAkB,EAAE;AAEzE,aAAS,UAAU,OAAO;AAC1B;;AAEJ,uBAAoB;;AAExB,SAAQ,gBAAgB,SAAS;;CAErC,MAAM;AACF,SAAO,KAAK,UAAU,KAAK;;;AA2CnC,SAAgB,qBAAqB,UAAU;AAuC3C,QAAS,YAAY,SAAU,YAAY,SACnC,YAAY,SAAU,YAAY,SAClC,YAAY,SAAU,YAAY;;;;;;AAM9C,SAAgB,iBAAiB,GAAG;AAChC,QAAS,KAAK,UAAW,KAAK,UAAa,MAAM,QAAU,MAAM,QAAU,MAAM,QACzE,MAAM,QAAU,KAAK,QAAQ,KAAK,SAAW,MAAM,SAAW,MAAM,SACpE,KAAK,UAAU,KAAK,UAAY,KAAK,UAAU,KAAK,UACpD,KAAK,UAAU,KAAK,UAAY,KAAK,UAAU,KAAK,UACpD,KAAK,UAAU,KAAK;;AAGhC,MAAa,qBAAqB,OAAO,aAAa,MAAqB;AAwB3E,SAAS,8BAA8B,YAAY,YAAY;AAG3D,KAAI,eAAe,EAEf,QAAQ,eAAe,KAAkB,eAAe;AAM5D,KAAI,eAAe,GACf;MAAI,eAAe,EACf,QAAO;;AAGf,KAAI,eAAe,KAAmB,eAAe,KAAc,eAAe,EAC9E,QAAO;AAEX,KAAI,eAAe,KAAmB,eAAe,KAAc,eAAe,EAC9E,QAAO;AAMX,KAAI,eAAe,GACf;MAAI,eAAe,KAAa,eAAe,KAAa,eAAe,MAAe,eAAe,GACrG,QAAO;;AAGf,KAAI,eAAe,MAAe,eAAe,GAC7C;MAAI,eAAe,KAAa,eAAe,GAC3C,QAAO;;AAGf,KAAI,eAAe,MAAgB,eAAe,IAC9C;MAAI,eAAe,GACf,QAAO;;AAKf,KAAI,eAAe,KAAkB,eAAe,GAChD,QAAO;AAMX,KAAI,eAAe,EACf,QAAO;AAEX,KAAI,eAAe,EACf,QAAO;AAIX,KAAI,eAAe,MAAgB,eAAe,GAE9C,QAAO;AAIX,KAAI,eAAe,KAA8B,eAAe,EAE5D,QAAO;AAGX,QAAO;;AAEX,IAAM,oBAAN,MAAM,kBAAkB;CACpB,cAAc;AACV,OAAK,QAAQ,yBAAyB;;CAE1C,OAAO,cAAc;AACjB,MAAI,CAAC,kBAAkB,UACnB,mBAAkB,YAAY,IAAI,mBAAmB;AAEzD,SAAO,kBAAkB;;CAE7B,qBAAqB,WAAW;AAE5B,MAAI,YAAY,IAAI;AAChB,OAAI,cAAc,GACd,QAAO;AAEX,OAAI,cAAc,GACd,QAAO;AAEX,UAAO;;AAGX,MAAI,YAAY,IACZ,QAAO;EAEX,MAAM,OAAO,KAAK;EAClB,MAAM,YAAY,KAAK,SAAS;EAChC,IAAI,YAAY;AAChB,SAAO,aAAa,UAChB,KAAI,YAAY,KAAK,IAAI,WAErB,aAAY,IAAI;WAEX,YAAY,KAAK,IAAI,YAAY,GAEtC,aAAY,IAAI,YAAY;MAI5B,QAAO,KAAK,IAAI,YAAY;AAGpC,SAAO;;;AAGf,kBAAkB,YAAY;AAC9B,SAAS,0BAA0B;AAE/B,QAAO,KAAK,MAAM,031BAA031B;;AAuDh51B,IAAa,sBAAb,MAAa,oBAAoB;CAC7B,YAAY,sBAAsB;AAC9B,OAAK,uBAAuB;;CAEhC,OAAO,YAAY,SAAS;AACxB,SAAO,oBAAoB,MAAM,IAAI,MAAM,KAAK,QAAQ,CAAC;;CAE7D,OAAO,aAAa;AAChB,SAAO,oBAAoB,SAAS,UAAU;;CAElD,YAAY,WAAW;AACnB,SAAO,KAAK,qBAAqB,IAAI,UAAU;;;;;;CAMnD,qBAAqB,WAAW;AAC5B,SAAO,KAAK,qBAAqB,IAAI,UAAU;;CAEnD,0BAA0B;AACtB,SAAO,IAAI,IAAI,KAAK,qBAAqB,MAAM,CAAC;;;AAGxD,OAAK;AACL,oBAAoB,yBAAyB,IAAI,WAAW;AAGxD,QAAO,KAAK,MAAM,8wmBAA8wmB;EAClymB;AACF,oBAAoB,QAAQ,IAAI,mBAAmB,YAAY;CAC3D,SAAS,WAAW,KAAK;EACrB,MAAM,yBAAS,IAAI,KAAK;AACxB,OAAK,IAAI,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK,EACjC,QAAO,IAAI,IAAI,IAAI,IAAI,IAAI,GAAG;AAElC,SAAO;;CAEX,SAAS,UAAU,MAAM,MAAM;EAC3B,MAAM,SAAS,IAAI,IAAI,KAAK;AAC5B,OAAK,MAAM,CAAC,KAAK,UAAU,KACvB,QAAO,IAAI,KAAK,MAAM;AAE1B,SAAO;;CAEX,SAAS,cAAc,MAAM,MAAM;AAC/B,MAAI,CAAC,KACD,QAAO;EAEX,MAAM,yBAAS,IAAI,KAAK;AACxB,OAAK,MAAM,CAAC,KAAK,UAAU,KACvB,KAAI,KAAK,IAAI,IAAI,CACb,QAAO,IAAI,KAAK,MAAM;AAG9B,SAAO;;CAEX,MAAM,OAAOA,KAAG,uBAAuB,UAAU;CACjD,IAAI,kBAAkB,QAAQ,QAAQ,MAAM,CAAC,EAAE,WAAW,IAAI,IAAI,KAAK,KAAK;AAC5E,KAAI,gBAAgB,WAAW,EAC3B,mBAAkB,CAAC,WAAW;CAElC,IAAI,sBAAsB;AAC1B,MAAK,MAAM,UAAU,iBAAiB;EAClC,MAAM,MAAM,WAAW,KAAK,QAAQ;AACpC,wBAAsB,cAAc,qBAAqB,IAAI;;AAIjE,QAAO,IAAI,oBADC,UADM,WAAW,KAAK,WAAW,EACZ,oBAAoB,CAClB;EACrC;AACF,oBAAoB,WAAW,IAAI,WAAW,OAAO,KAAK,oBAAoB,uBAAuB,UAAU,CAAC,CAAC,QAAQ,MAAM,CAAC,EAAE,WAAW,IAAI,CAAC,CAAC;AACnJ,IAAa,sBAAb,MAAa,oBAAoB;CAC7B,OAAO,aAAa;AAEhB,SAAO,KAAK,MAAM,uiGAAuiG;;CAE7jG,OAAO,UAAU;AACb,MAAI,CAAC,KAAK,MACN,MAAK,QAAQ,IAAI,IAAI,oBAAoB,YAAY,CAAC;AAE1D,SAAO,KAAK;;CAEhB,OAAO,qBAAqB,WAAW;AACnC,SAAO,oBAAoB,SAAS,CAAC,IAAI,UAAU;;CAEvD,WAAW,aAAa;AACpB,SAAO,oBAAoB,SAAS;;;AAG5C,oBAAoB,QAAQ;;;;;;;;;;;;;;;;;;;;ACvxB5B,IAAa,gBAAb,MAAa,cAAc;CACvB,OAAO,mBAAmB,WAAW,eAAe,SAAS;AACzD,MAAI,cAAc,EACd,QAAO,cAAc,kBAAkB,eAAe,QAAQ;AAElE,MAAIC,qBAA6B,UAAU,IAAIC,iBAAyB,UAAU,CAC9E,QAAO,gBAAgB;AAE3B,SAAO,gBAAgB;;;;;;CAM3B,OAAO,wBAAwB,aAAa,QAAQ,SAAS;EACzD,MAAM,UAAU,KAAK,IAAI,SAAS,GAAG,YAAY,OAAO;EACxD,MAAM,OAAO,YAAY,UAAU,GAAG,QAAQ;EAC9C,MAAM,WAAW,IAAIC,iBAAyB,KAAK;EACnD,IAAI,SAAS;AACb,SAAO,CAAC,SAAS,KAAK,EAAE;GACpB,MAAM,YAAYC,iBAAyB,MAAM,SAAS,SAAS,OAAO;AAC1E,YAAS,oBAAoB;AAC7B,YAAS,KAAK,mBAAmB,WAAW,QAAQ,QAAQ;;AAEhE,SAAO;;;;;;CAMX,OAAO,wBAAwB,aAAa,eAAe,SAAS;AAChE,MAAI,iBAAiB,EACjB,QAAO;EAEX,MAAM,oBAAoB,YAAY;EACtC,MAAM,WAAW,IAAID,iBAAyB,YAAY;EAC1D,IAAI,sBAAsB;EAC1B,IAAI,eAAe;AACnB,SAAO,CAAC,SAAS,KAAK,EAAE;GACpB,MAAM,YAAYC,iBAAyB,aAAa,mBAAmB,SAAS,OAAO;AAC3F,YAAS,oBAAoB;GAC7B,MAAM,qBAAqB,KAAK,mBAAmB,WAAW,qBAAqB,QAAQ;GAC3F,MAAM,cAAc,SAAS,SAAS;AACtC,OAAI,sBAAsB,eAAe;IACrC,MAAM,cAAc,gBAAgB;AAEpC,QADmB,qBAAqB,gBACvB,YACb,QAAO;QAGP,QAAO;;AAGf,yBAAsB;AACtB,kBAAe;;AAGnB,SAAO,oBAAoB;;;;;;CAM/B,OAAO,kBAAkB,eAAe,SAAS;AAC7C,SAAO,gBAAgB,UAAU,gBAAgB;;;;;;CAMrD,OAAO,kBAAkB,eAAe,YAAY;AAChD,SAAO,gBAAgB,aAAa,gBAAgB;;;;;;CAMxD,OAAO,kBAAkB,QAAQ,SAAS;AACtC,SAAO,KAAK,IAAI,GAAG,SAAS,KAAK,SAAS,KAAK,QAAQ;;;;;;CAM3D,OAAO,kBAAkB,QAAQ,YAAY;AACzC,SAAO,KAAK,IAAI,GAAG,SAAS,KAAK,SAAS,KAAK,WAAW;;;;;;;;;ACnGlE,IAAaC,aAAb,MAAaA,WAAS;CAClB,YAAY,YAAY,QAAQ;AAC5B,OAAK,aAAa;AAClB,OAAK,SAAS;;;;;;;;CAQlB,KAAK,gBAAgB,KAAK,YAAY,YAAY,KAAK,QAAQ;AAC3D,MAAI,kBAAkB,KAAK,cAAc,cAAc,KAAK,OACxD,QAAO;MAGP,QAAO,IAAIA,WAAS,eAAe,UAAU;;;;;;;;CASrD,MAAM,kBAAkB,GAAG,cAAc,GAAG;AACxC,SAAO,KAAK,KAAK,KAAK,aAAa,iBAAiB,KAAK,SAAS,YAAY;;;;;CAKlF,OAAO,OAAO;AACV,SAAOA,WAAS,OAAO,MAAM,MAAM;;;;;CAKvC,OAAO,OAAO,GAAG,GAAG;AAChB,MAAI,CAAC,KAAK,CAAC,EACP,QAAO;AAEX,SAAQ,CAAC,CAAC,KACN,CAAC,CAAC,KACF,EAAE,eAAe,EAAE,cACnB,EAAE,WAAW,EAAE;;;;;;CAMvB,SAAS,OAAO;AACZ,SAAOA,WAAS,SAAS,MAAM,MAAM;;;;;;CAMzC,OAAO,SAAS,GAAG,GAAG;AAClB,MAAI,EAAE,aAAa,EAAE,WACjB,QAAO;AAEX,MAAI,EAAE,aAAa,EAAE,WACjB,QAAO;AAEX,SAAO,EAAE,SAAS,EAAE;;;;;;CAMxB,gBAAgB,OAAO;AACnB,SAAOA,WAAS,gBAAgB,MAAM,MAAM;;;;;;CAMhD,OAAO,gBAAgB,GAAG,GAAG;AACzB,MAAI,EAAE,aAAa,EAAE,WACjB,QAAO;AAEX,MAAI,EAAE,aAAa,EAAE,WACjB,QAAO;AAEX,SAAO,EAAE,UAAU,EAAE;;;;;CAKzB,OAAO,QAAQ,GAAG,GAAG;EACjB,MAAM,cAAc,EAAE,aAAa;EACnC,MAAM,cAAc,EAAE,aAAa;AACnC,MAAI,gBAAgB,YAGhB,SAFgB,EAAE,SAAS,MACX,EAAE,SAAS;AAG/B,SAAO,cAAc;;;;;CAKzB,QAAQ;AACJ,SAAO,IAAIA,WAAS,KAAK,YAAY,KAAK,OAAO;;;;;CAKrD,WAAW;AACP,SAAO,MAAM,KAAK,aAAa,MAAM,KAAK,SAAS;;;;;CAMvD,OAAO,KAAK,KAAK;AACb,SAAO,IAAIA,WAAS,IAAI,YAAY,IAAI,OAAO;;;;;CAKnD,OAAO,YAAY,KAAK;AACpB,SAAQ,OACA,OAAO,IAAI,eAAe,YAC1B,OAAO,IAAI,WAAW;;;;;;;;;AC3HtC,IAAaC,UAAb,MAAaA,QAAM;CACf,YAAY,iBAAiB,aAAa,eAAe,WAAW;AAChE,MAAK,kBAAkB,iBAAmB,oBAAoB,iBAAiB,cAAc,WAAY;AACrG,QAAK,kBAAkB;AACvB,QAAK,cAAc;AACnB,QAAK,gBAAgB;AACrB,QAAK,YAAY;SAEhB;AACD,QAAK,kBAAkB;AACvB,QAAK,cAAc;AACnB,QAAK,gBAAgB;AACrB,QAAK,YAAY;;;;;;CAMzB,UAAU;AACN,SAAOA,QAAM,QAAQ,KAAK;;;;;CAK9B,OAAO,QAAQ,OAAO;AAClB,SAAQ,MAAM,oBAAoB,MAAM,iBAAiB,MAAM,gBAAgB,MAAM;;;;;CAKzF,iBAAiB,UAAU;AACvB,SAAOA,QAAM,iBAAiB,MAAM,SAAS;;;;;CAKjD,OAAO,iBAAiB,OAAO,UAAU;AACrC,MAAI,SAAS,aAAa,MAAM,mBAAmB,SAAS,aAAa,MAAM,cAC3E,QAAO;AAEX,MAAI,SAAS,eAAe,MAAM,mBAAmB,SAAS,SAAS,MAAM,YACzE,QAAO;AAEX,MAAI,SAAS,eAAe,MAAM,iBAAiB,SAAS,SAAS,MAAM,UACvE,QAAO;AAEX,SAAO;;;;;;CAMX,OAAO,uBAAuB,OAAO,UAAU;AAC3C,MAAI,SAAS,aAAa,MAAM,mBAAmB,SAAS,aAAa,MAAM,cAC3E,QAAO;AAEX,MAAI,SAAS,eAAe,MAAM,mBAAmB,SAAS,UAAU,MAAM,YAC1E,QAAO;AAEX,MAAI,SAAS,eAAe,MAAM,iBAAiB,SAAS,UAAU,MAAM,UACxE,QAAO;AAEX,SAAO;;;;;CAKX,cAAc,OAAO;AACjB,SAAOA,QAAM,cAAc,MAAM,MAAM;;;;;CAK3C,OAAO,cAAc,OAAO,YAAY;AACpC,MAAI,WAAW,kBAAkB,MAAM,mBAAmB,WAAW,gBAAgB,MAAM,gBACvF,QAAO;AAEX,MAAI,WAAW,kBAAkB,MAAM,iBAAiB,WAAW,gBAAgB,MAAM,cACrF,QAAO;AAEX,MAAI,WAAW,oBAAoB,MAAM,mBAAmB,WAAW,cAAc,MAAM,YACvF,QAAO;AAEX,MAAI,WAAW,kBAAkB,MAAM,iBAAiB,WAAW,YAAY,MAAM,UACjF,QAAO;AAEX,SAAO;;;;;CAKX,oBAAoB,OAAO;AACvB,SAAOA,QAAM,oBAAoB,MAAM,MAAM;;;;;CAKjD,OAAO,oBAAoB,OAAO,YAAY;AAC1C,MAAI,WAAW,kBAAkB,MAAM,mBAAmB,WAAW,gBAAgB,MAAM,gBACvF,QAAO;AAEX,MAAI,WAAW,kBAAkB,MAAM,iBAAiB,WAAW,gBAAgB,MAAM,cACrF,QAAO;AAEX,MAAI,WAAW,oBAAoB,MAAM,mBAAmB,WAAW,eAAe,MAAM,YACxF,QAAO;AAEX,MAAI,WAAW,kBAAkB,MAAM,iBAAiB,WAAW,aAAa,MAAM,UAClF,QAAO;AAEX,SAAO;;;;;;CAMX,UAAU,OAAO;AACb,SAAOA,QAAM,UAAU,MAAM,MAAM;;;;;;CAMvC,OAAO,UAAU,GAAG,GAAG;EACnB,IAAI;EACJ,IAAI;EACJ,IAAI;EACJ,IAAI;AACJ,MAAI,EAAE,kBAAkB,EAAE,iBAAiB;AACvC,qBAAkB,EAAE;AACpB,iBAAc,EAAE;aAEX,EAAE,oBAAoB,EAAE,iBAAiB;AAC9C,qBAAkB,EAAE;AACpB,iBAAc,KAAK,IAAI,EAAE,aAAa,EAAE,YAAY;SAEnD;AACD,qBAAkB,EAAE;AACpB,iBAAc,EAAE;;AAEpB,MAAI,EAAE,gBAAgB,EAAE,eAAe;AACnC,mBAAgB,EAAE;AAClB,eAAY,EAAE;aAET,EAAE,kBAAkB,EAAE,eAAe;AAC1C,mBAAgB,EAAE;AAClB,eAAY,KAAK,IAAI,EAAE,WAAW,EAAE,UAAU;SAE7C;AACD,mBAAgB,EAAE;AAClB,eAAY,EAAE;;AAElB,SAAO,IAAIA,QAAM,iBAAiB,aAAa,eAAe,UAAU;;;;;CAK5E,gBAAgB,OAAO;AACnB,SAAOA,QAAM,gBAAgB,MAAM,MAAM;;;;;CAK7C,OAAO,gBAAgB,GAAG,GAAG;EACzB,IAAI,wBAAwB,EAAE;EAC9B,IAAI,oBAAoB,EAAE;EAC1B,IAAI,sBAAsB,EAAE;EAC5B,IAAI,kBAAkB,EAAE;EACxB,IAAI,uBAAuB,EAAE;EAC7B,IAAI,mBAAmB,EAAE;EACzB,IAAI,qBAAqB,EAAE;EAC3B,IAAI,iBAAiB,EAAE;AACvB,MAAI,wBAAwB,sBAAsB;AAC9C,2BAAwB;AACxB,uBAAoB;aAEf,0BAA0B,qBAC/B,qBAAoB,KAAK,IAAI,mBAAmB,iBAAiB;AAErE,MAAI,sBAAsB,oBAAoB;AAC1C,yBAAsB;AACtB,qBAAkB;aAEb,wBAAwB,mBAC7B,mBAAkB,KAAK,IAAI,iBAAiB,eAAe;AAG/D,MAAI,wBAAwB,oBACxB,QAAO;AAEX,MAAI,0BAA0B,uBAAuB,oBAAoB,gBACrE,QAAO;AAEX,SAAO,IAAIA,QAAM,uBAAuB,mBAAmB,qBAAqB,gBAAgB;;;;;CAKpG,YAAY,OAAO;AACf,SAAOA,QAAM,YAAY,MAAM,MAAM;;;;;CAKzC,OAAO,YAAY,GAAG,GAAG;AACrB,SAAQ,CAAC,CAAC,KACN,CAAC,CAAC,KACF,EAAE,oBAAoB,EAAE,mBACxB,EAAE,gBAAgB,EAAE,eACpB,EAAE,kBAAkB,EAAE,iBACtB,EAAE,cAAc,EAAE;;;;;CAK1B,iBAAiB;AACb,SAAOA,QAAM,eAAe,KAAK;;;;;CAKrC,OAAO,eAAe,OAAO;AACzB,SAAO,IAAIC,WAAS,MAAM,eAAe,MAAM,UAAU;;;;;CAK7D,mBAAmB;AACf,SAAOD,QAAM,iBAAiB,KAAK;;;;;CAKvC,OAAO,iBAAiB,OAAO;AAC3B,SAAO,IAAIC,WAAS,MAAM,iBAAiB,MAAM,YAAY;;;;;CAKjE,WAAW;AACP,SAAO,MAAM,KAAK,kBAAkB,MAAM,KAAK,cAAc,SAAS,KAAK,gBAAgB,MAAM,KAAK,YAAY;;;;;CAKtH,eAAe,eAAe,WAAW;AACrC,SAAO,IAAID,QAAM,KAAK,iBAAiB,KAAK,aAAa,eAAe,UAAU;;;;;CAKtF,iBAAiB,iBAAiB,aAAa;AAC3C,SAAO,IAAIA,QAAM,iBAAiB,aAAa,KAAK,eAAe,KAAK,UAAU;;;;;CAKtF,kBAAkB;AACd,SAAOA,QAAM,gBAAgB,KAAK;;;;;CAKtC,OAAO,gBAAgB,OAAO;AAC1B,SAAO,IAAIA,QAAM,MAAM,iBAAiB,MAAM,aAAa,MAAM,iBAAiB,MAAM,YAAY;;CAGxG,OAAO,cAAc,OAAO,MAAM,OAAO;AACrC,SAAO,IAAIA,QAAM,MAAM,YAAY,MAAM,QAAQ,IAAI,YAAY,IAAI,OAAO;;CAEhF,OAAO,KAAK,OAAO;AACf,MAAI,CAAC,MACD,QAAO;AAEX,SAAO,IAAIA,QAAM,MAAM,iBAAiB,MAAM,aAAa,MAAM,eAAe,MAAM,UAAU;;;;;CAKpG,OAAO,SAAS,KAAK;AACjB,SAAQ,OACA,OAAO,IAAI,oBAAoB,YAC/B,OAAO,IAAI,gBAAgB,YAC3B,OAAO,IAAI,kBAAkB,YAC7B,OAAO,IAAI,cAAc;;;;;CAKrC,OAAO,0BAA0B,GAAG,GAAG;AAEnC,MAAI,EAAE,gBAAgB,EAAE,mBAAoB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,YAAY,EAAE,YACjG,QAAO;AAGX,MAAI,EAAE,gBAAgB,EAAE,mBAAoB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,YAAY,EAAE,YACjG,QAAO;AAGX,SAAO;;;;;CAKX,OAAO,gBAAgB,GAAG,GAAG;AAEzB,MAAI,EAAE,gBAAgB,EAAE,mBAAoB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,aAAa,EAAE,YAClG,QAAO;AAGX,MAAI,EAAE,gBAAgB,EAAE,mBAAoB,EAAE,kBAAkB,EAAE,mBAAmB,EAAE,aAAa,EAAE,YAClG,QAAO;AAGX,SAAO;;;;;;CAMX,OAAO,yBAAyB,GAAG,GAAG;AAClC,MAAI,KAAK,GAAG;GACR,MAAM,mBAAmB,EAAE,kBAAkB;GAC7C,MAAM,mBAAmB,EAAE,kBAAkB;AAC7C,OAAI,qBAAqB,kBAAkB;IACvC,MAAM,eAAe,EAAE,cAAc;IACrC,MAAM,eAAe,EAAE,cAAc;AACrC,QAAI,iBAAiB,cAAc;KAC/B,MAAM,iBAAiB,EAAE,gBAAgB;KACzC,MAAM,iBAAiB,EAAE,gBAAgB;AACzC,SAAI,mBAAmB,eAGnB,SAFmB,EAAE,YAAY,MACd,EAAE,YAAY;AAGrC,YAAO,iBAAiB;;AAE5B,WAAO,eAAe;;AAE1B,UAAO,mBAAmB;;AAI9B,UAFiB,IAAI,IAAI,MACR,IAAI,IAAI;;;;;;CAO7B,OAAO,uBAAuB,GAAG,GAAG;AAChC,MAAI,EAAE,kBAAkB,EAAE,eAAe;AACrC,OAAI,EAAE,cAAc,EAAE,WAAW;AAC7B,QAAI,EAAE,oBAAoB,EAAE,gBACxB,QAAO,EAAE,cAAc,EAAE;AAE7B,WAAO,EAAE,kBAAkB,EAAE;;AAEjC,UAAO,EAAE,YAAY,EAAE;;AAE3B,SAAO,EAAE,gBAAgB,EAAE;;;;;CAK/B,OAAO,mBAAmB,OAAO;AAC7B,SAAO,MAAM,gBAAgB,MAAM;;CAEvC,SAAS;AACL,SAAO;;;;;;;;;;AC9Wf,IAAaE,cAAb,MAAaA,oBAAkBC,QAAM;CACjC,YAAY,0BAA0B,sBAAsB,oBAAoB,gBAAgB;AAC5F,QAAM,0BAA0B,sBAAsB,oBAAoB,eAAe;AACzF,OAAK,2BAA2B;AAChC,OAAK,uBAAuB;AAC5B,OAAK,qBAAqB;AAC1B,OAAK,iBAAiB;;;;;CAK1B,WAAW;AACP,SAAO,MAAM,KAAK,2BAA2B,MAAM,KAAK,uBAAuB,SAAS,KAAK,qBAAqB,MAAM,KAAK,iBAAiB;;;;;CAKlJ,gBAAgB,OAAO;AACnB,SAAQD,YAAU,gBAAgB,MAAM,MAAM;;;;;CAKlD,OAAO,gBAAgB,GAAG,GAAG;AACzB,SAAQ,EAAE,6BAA6B,EAAE,4BACrC,EAAE,yBAAyB,EAAE,wBAC7B,EAAE,uBAAuB,EAAE,sBAC3B,EAAE,mBAAmB,EAAE;;;;;CAK/B,eAAe;AACX,MAAI,KAAK,6BAA6B,KAAK,mBAAmB,KAAK,yBAAyB,KAAK,YAC7F,QAAO;AAEX,SAAO;;;;;CAKX,eAAe,eAAe,WAAW;AACrC,MAAI,KAAK,cAAc,KAAK,EACxB,QAAO,IAAIA,YAAU,KAAK,iBAAiB,KAAK,aAAa,eAAe,UAAU;AAE1F,SAAO,IAAIA,YAAU,eAAe,WAAW,KAAK,iBAAiB,KAAK,YAAY;;;;;CAK1F,cAAc;AACV,SAAO,IAAIE,WAAS,KAAK,oBAAoB,KAAK,eAAe;;;;;CAKrE,oBAAoB;AAChB,SAAO,IAAIA,WAAS,KAAK,0BAA0B,KAAK,qBAAqB;;;;;CAKjF,iBAAiB,iBAAiB,aAAa;AAC3C,MAAI,KAAK,cAAc,KAAK,EACxB,QAAO,IAAIF,YAAU,iBAAiB,aAAa,KAAK,eAAe,KAAK,UAAU;AAE1F,SAAO,IAAIA,YAAU,KAAK,eAAe,KAAK,WAAW,iBAAiB,YAAY;;;;;CAM1F,OAAO,cAAc,OAAO,MAAM,OAAO;AACrC,SAAO,IAAIA,YAAU,MAAM,YAAY,MAAM,QAAQ,IAAI,YAAY,IAAI,OAAO;;;;;CAKpF,OAAO,UAAU,OAAO,WAAW;AAC/B,MAAI,cAAc,EACd,QAAO,IAAIA,YAAU,MAAM,iBAAiB,MAAM,aAAa,MAAM,eAAe,MAAM,UAAU;MAGpG,QAAO,IAAIA,YAAU,MAAM,eAAe,MAAM,WAAW,MAAM,iBAAiB,MAAM,YAAY;;;;;CAM5G,OAAO,cAAc,KAAK;AACtB,SAAO,IAAIA,YAAU,IAAI,0BAA0B,IAAI,sBAAsB,IAAI,oBAAoB,IAAI,eAAe;;;;;CAK5H,OAAO,mBAAmB,GAAG,GAAG;AAC5B,MAAI,KAAK,CAAC,KAAK,CAAC,KAAK,EACjB,QAAO;AAEX,MAAI,CAAC,KAAK,CAAC,EACP,QAAO;AAEX,MAAI,EAAE,WAAW,EAAE,OACf,QAAO;AAEX,OAAK,IAAI,IAAI,GAAG,MAAM,EAAE,QAAQ,IAAI,KAAK,IACrC,KAAI,CAAC,KAAK,gBAAgB,EAAE,IAAI,EAAE,GAAG,CACjC,QAAO;AAGf,SAAO;;;;;CAKX,OAAO,aAAa,KAAK;AACrB,SAAQ,OACA,OAAO,IAAI,6BAA6B,YACxC,OAAO,IAAI,yBAAyB,YACpC,OAAO,IAAI,uBAAuB,YAClC,OAAO,IAAI,mBAAmB;;;;;CAK1C,OAAO,oBAAoB,iBAAiB,aAAa,eAAe,WAAW,WAAW;AAC1F,MAAI,cAAc,EACd,QAAO,IAAIA,YAAU,iBAAiB,aAAa,eAAe,UAAU;AAEhF,SAAO,IAAIA,YAAU,eAAe,WAAW,iBAAiB,YAAY;;;;;;ACtIpF,IAAa,eAAb,MAA0B;CACtB,cAAc;AACV,OAAK,YAAY,EAAE;AACnB,OAAK,yBAAyB,SAAU,GAAG;AACvC,oBAAiB;AACb,QAAI,EAAE,MACF,OAAM,IAAI,MAAM,EAAE,UAAU,SAAS,EAAE,MAAM;AAEjD,UAAM;MACP,EAAE;;;CAGb,KAAK,GAAG;AACJ,OAAK,UAAU,SAAS,aAAa;AACjC,YAAS,EAAE;IACb;;CAEN,kBAAkB,GAAG;AACjB,OAAK,uBAAuB,EAAE;AAC9B,OAAK,KAAK,EAAE;;CAGhB,0BAA0B,GAAG;AACzB,OAAK,uBAAuB,EAAE;;;AAGtC,MAAa,eAAe,IAAI,cAAc;AAC9C,SAAgB,kBAAkB,GAAG;AAEjC,KAAI,CAAC,oBAAoB,EAAE,CACvB,cAAa,kBAAkB,EAAE;;AAyBzC,MAAM,eAAe;;;;AAIrB,SAAgB,oBAAoB,OAAO;AACvC,KAAI,iBAAiB,kBACjB,QAAO;AAEX,QAAO,iBAAiB,SAAS,MAAM,SAAS,gBAAgB,MAAM,YAAY;;AAItF,IAAa,oBAAb,cAAuC,MAAM;CACzC,cAAc;AACV,QAAM,aAAa;AACnB,OAAK,OAAO,KAAK;;;;;;ACvEzB,SAAgB,KAAK,IAAI;CACrB,MAAM,QAAQ;CACd,IAAI,UAAU;CACd,IAAI;AACJ,QAAO,WAAY;AACf,MAAI,QACA,QAAO;AAEX,YAAU;AACV,WAAS,GAAG,MAAM,OAAO,UAAU;AACnC,SAAO;;;;;;ACVf,IAAW;CACV,SAAU,YAAU;CACjB,SAAS,GAAG,OAAO;AACf,SAAO,SAAS,OAAO,UAAU,YAAY,OAAO,MAAM,OAAO,cAAc;;AAEnF,YAAS,KAAK;CACd,MAAM,SAAS,OAAO,OAAO,EAAE,CAAC;CAChC,SAAS,QAAQ;AACb,SAAO;;AAEX,YAAS,QAAQ;CACjB,UAAU,OAAO,SAAS;AACtB,QAAM;;AAEV,YAAS,SAAS;CAClB,SAAS,KAAK,UAAU;AACpB,SAAO,YAAY;;AAEvB,YAAS,OAAO;CAChB,SAAS,QAAQ,UAAU;AACvB,SAAO,CAAC,YAAY,SAAS,OAAO,WAAW,CAAC,MAAM,CAAC,SAAS;;AAEpE,YAAS,UAAU;CACnB,SAAS,MAAM,UAAU;AACrB,SAAO,SAAS,OAAO,WAAW,CAAC,MAAM,CAAC;;AAE9C,YAAS,QAAQ;CACjB,SAAS,KAAK,UAAU,WAAW;AAC/B,OAAK,MAAM,WAAW,SAClB,KAAI,UAAU,QAAQ,CAClB,QAAO;AAGf,SAAO;;AAEX,YAAS,OAAO;CAChB,SAAS,KAAK,UAAU,WAAW;AAC/B,OAAK,MAAM,WAAW,SAClB,KAAI,UAAU,QAAQ,CAClB,QAAO;;AAKnB,YAAS,OAAO;CAChB,UAAU,OAAO,UAAU,WAAW;AAClC,OAAK,MAAM,WAAW,SAClB,KAAI,UAAU,QAAQ,CAClB,OAAM;;AAIlB,YAAS,SAAS;CAClB,UAAU,IAAI,UAAU,IAAI;EACxB,IAAI,QAAQ;AACZ,OAAK,MAAM,WAAW,SAClB,OAAM,GAAG,SAAS,QAAQ;;AAGlC,YAAS,MAAM;CACf,UAAU,OAAO,GAAG,WAAW;AAC3B,OAAK,MAAM,YAAY,UACnB,MAAK,MAAM,WAAW,SAClB,OAAM;;AAIlB,YAAS,SAAS;CAClB,UAAU,aAAa,WAAW;AAC9B,OAAK,MAAM,YAAY,UACnB,MAAK,MAAM,WAAW,SAClB,OAAM;;AAIlB,YAAS,eAAe;CACxB,SAAS,OAAO,UAAU,SAAS,cAAc;EAC7C,IAAI,QAAQ;AACZ,OAAK,MAAM,WAAW,SAClB,SAAQ,QAAQ,OAAO,QAAQ;AAEnC,SAAO;;AAEX,YAAS,SAAS;;;;CAIlB,UAAU,MAAM,KAAK,QAAM,KAAK,IAAI,QAAQ;AACxC,MAAIG,SAAO,EACP,WAAQ,IAAI;AAEhB,MAAI,KAAK,EACL,OAAM,IAAI;WAEL,KAAK,IAAI,OACd,MAAK,IAAI;AAEb,SAAOA,SAAO,IAAI,SACd,OAAM,IAAIA;;AAGlB,YAAS,QAAQ;;;;;CAKjB,SAAS,QAAQ,UAAU,SAAS,OAAO,mBAAmB;EAC1D,MAAM,WAAW,EAAE;AACnB,MAAI,WAAW,EACX,QAAO,CAAC,UAAU,SAAS;EAE/B,MAAM,WAAW,SAAS,OAAO,WAAW;AAC5C,OAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK;GAC7B,MAAM,OAAO,SAAS,MAAM;AAC5B,OAAI,KAAK,KACL,QAAO,CAAC,UAAUC,WAAS,OAAO,CAAC;AAEvC,YAAS,KAAK,KAAK,MAAM;;AAE7B,SAAO,CAAC,UAAU,EAAE,CAAC,OAAO,YAAY;AAAE,UAAO;KAAa,CAAC;;AAEnE,YAAS,UAAU;;;;;CAKnB,SAAS,OAAO,GAAG,GAAG,cAAc,IAAI,OAAO,OAAO,IAAI;EACtD,MAAM,KAAK,EAAE,OAAO,WAAW;EAC/B,MAAM,KAAK,EAAE,OAAO,WAAW;AAC/B,SAAO,MAAM;GACT,MAAM,KAAK,GAAG,MAAM;GACpB,MAAM,KAAK,GAAG,MAAM;AACpB,OAAI,GAAG,SAAS,GAAG,KACf,QAAO;YAEF,GAAG,KACR,QAAO;YAEF,CAAC,WAAW,GAAG,OAAO,GAAG,MAAM,CACpC,QAAO;;;AAInB,YAAS,SAAS;GACnB,aAAa,WAAW,EAAE,EAAE;;;;ACtI/B,IAAI,oBAAoB;AAsCxB,SAAS,gBAAgB,GAAG;AACxB,uBAAsB,QAAQ,sBAAsB,KAAK,KAAa,kBAAkB,gBAAgB,EAAE;AAC1G,QAAO;;AAEX,SAAS,eAAe,YAAY;AAChC,uBAAsB,QAAQ,sBAAsB,KAAK,KAAa,kBAAkB,eAAe,WAAW;;AAEtH,SAAS,sBAAsB,OAAO,QAAQ;AAC1C,uBAAsB,QAAQ,sBAAsB,KAAK,KAAa,kBAAkB,UAAU,OAAO,OAAO;;AAEpH,SAAS,uBAAuB,UAAU,QAAQ;AAC9C,KAAI,CAAC,kBACD;AAEJ,MAAK,MAAM,SAAS,SAChB,mBAAkB,UAAU,OAAO,OAAO;;AAUlD,IAAa,oBAAb,cAAuC,MAAM;CACzC,YAAY,QAAQ;AAChB,QAAM,yDAAyD,OAAO,KAAK,KAAK,CAAC,GAAG;AACpF,OAAK,SAAS;;;AAMtB,SAAgB,QAAQ,KAAK;AACzB,KAAI,SAAS,GAAG,IAAI,EAAE;EAClB,IAAI,SAAS,EAAE;AACf,OAAK,MAAM,KAAK,IACZ,KAAI,EACA,KAAI;AACA,KAAE,SAAS;WAER,GAAG;AACN,UAAO,KAAK,EAAE;;AAI1B,MAAI,OAAO,WAAW,EAClB,OAAM,OAAO;WAER,OAAO,SAAS,EACrB,OAAM,IAAI,kBAAkB,OAAO;AAEvC,SAAO,MAAM,QAAQ,IAAI,GAAG,EAAE,GAAG;YAE5B,KAAK;AACV,MAAI,SAAS;AACb,SAAO;;;AAGf,SAAgB,mBAAmB,GAAG,aAAa;CAC/C,MAAM,SAAS,mBAAmB,QAAQ,YAAY,CAAC;AACvD,wBAAuB,aAAa,OAAO;AAC3C,QAAO;;AAEX,SAAgB,aAAa,IAAI;CAC7B,MAAMC,SAAO,gBAAgB,EACzB,SAAS,WAAW;AAChB,iBAAeA,OAAK;AACpB,MAAI;GACN,EACL,CAAC;AACF,QAAOA;;AAEX,IAAa,kBAAb,MAAa,gBAAgB;CACzB,cAAc;AACV,OAAK,6BAAa,IAAI,KAAK;AAC3B,OAAK,cAAc;AACnB,kBAAgB,KAAK;;;;;;;CAOzB,UAAU;AACN,MAAI,KAAK,YACL;AAEJ,iBAAe,KAAK;AACpB,OAAK,cAAc;AACnB,OAAK,OAAO;;;;;CAKhB,IAAI,aAAa;AACb,SAAO,KAAK;;;;;CAKhB,QAAQ;AACJ,MAAI;AACA,WAAQ,KAAK,WAAW,QAAQ,CAAC;YAE7B;AACJ,QAAK,WAAW,OAAO;;;CAG/B,IAAI,GAAG;AACH,MAAI,CAAC,EACD,QAAO;AAEX,MAAI,MAAM,KACN,OAAM,IAAI,MAAM,0CAA0C;AAE9D,wBAAsB,GAAG,KAAK;AAC9B,MAAI,KAAK,aACL;OAAI,CAAC,gBAAgB,yBACjB,SAAQ,sBAAK,IAAI,MAAM,sHAAsH,EAAC,MAAM;QAIxJ,MAAK,WAAW,IAAI,EAAE;AAE1B,SAAO;;;AAGf,gBAAgB,2BAA2B;AAC3C,IAAa,aAAb,MAAwB;CACpB,cAAc;AACV,OAAK,SAAS,IAAI,iBAAiB;AACnC,kBAAgB,KAAK;AACrB,wBAAsB,KAAK,QAAQ,KAAK;;CAE5C,UAAU;AACN,iBAAe,KAAK;AACpB,OAAK,OAAO,SAAS;;CAEzB,UAAU,GAAG;AACT,MAAI,MAAM,KACN,OAAM,IAAI,MAAM,0CAA0C;AAE9D,SAAO,KAAK,OAAO,IAAI,EAAE;;;AAGjC,WAAW,OAAO,OAAO,OAAO,EAAE,UAAU,IAAK,CAAC;;;;;AAqDlD,IAAa,iBAAb,MAA4B;CACxB,cAAc;AACV,OAAK,gBAAgB;AACrB,OAAK,cAAc;AACnB,OAAK,cAAc;AACnB,kBAAgB,KAAK;;CAEzB,IAAI,IAAI;EACJ,IAAI,WAAW;AACf,OAAK,cAAc,WAAW;AAC9B,OAAK,cAAc,aAAa;AAChC,OAAK,gBAAgB;AACjB,OAAI,UAAU;AACV,cAAU;AACV,eAAW;AACX,mBAAe,KAAK;;;AAG5B,SAAO;;;;;;AC1Qf,IAAM,OAAN,MAAM,KAAK;CACP,YAAY,SAAS;AACjB,OAAK,UAAU;AACf,OAAK,OAAO,KAAK;AACjB,OAAK,OAAO,KAAK;;;AAGzB,KAAK,YAAY,IAAI,KAAK,OAAU;AACpC,IAAa,aAAb,MAAwB;CACpB,cAAc;AACV,OAAK,SAAS,KAAK;AACnB,OAAK,QAAQ,KAAK;AAClB,OAAK,QAAQ;;CAEjB,IAAI,OAAO;AACP,SAAO,KAAK;;CAEhB,UAAU;AACN,SAAO,KAAK,WAAW,KAAK;;CAEhC,QAAQ;EACJ,IAAI,OAAO,KAAK;AAChB,SAAO,SAAS,KAAK,WAAW;GAC5B,MAAM,OAAO,KAAK;AAClB,QAAK,OAAO,KAAK;AACjB,QAAK,OAAO,KAAK;AACjB,UAAO;;AAEX,OAAK,SAAS,KAAK;AACnB,OAAK,QAAQ,KAAK;AAClB,OAAK,QAAQ;;CAEjB,QAAQ,SAAS;AACb,SAAO,KAAK,QAAQ,SAAS,MAAM;;CAEvC,KAAK,SAAS;AACV,SAAO,KAAK,QAAQ,SAAS,KAAK;;CAEtC,QAAQ,SAAS,UAAU;EACvB,MAAM,UAAU,IAAI,KAAK,QAAQ;AACjC,MAAI,KAAK,WAAW,KAAK,WAAW;AAChC,QAAK,SAAS;AACd,QAAK,QAAQ;aAER,UAAU;GAEf,MAAM,UAAU,KAAK;AACrB,QAAK,QAAQ;AACb,WAAQ,OAAO;AACf,WAAQ,OAAO;SAEd;GAED,MAAM,WAAW,KAAK;AACtB,QAAK,SAAS;AACd,WAAQ,OAAO;AACf,YAAS,OAAO;;AAEpB,OAAK,SAAS;EACd,IAAI,YAAY;AAChB,eAAa;AACT,OAAI,CAAC,WAAW;AACZ,gBAAY;AACZ,SAAK,QAAQ,QAAQ;;;;CAIjC,QAAQ;AACJ,MAAI,KAAK,WAAW,KAAK,UACrB;OAEC;GACD,MAAM,MAAM,KAAK,OAAO;AACxB,QAAK,QAAQ,KAAK,OAAO;AACzB,UAAO;;;CAGf,MAAM;AACF,MAAI,KAAK,UAAU,KAAK,UACpB;OAEC;GACD,MAAM,MAAM,KAAK,MAAM;AACvB,QAAK,QAAQ,KAAK,MAAM;AACxB,UAAO;;;CAGf,QAAQ,MAAM;AACV,MAAI,KAAK,SAAS,KAAK,aAAa,KAAK,SAAS,KAAK,WAAW;GAE9D,MAAM,SAAS,KAAK;AACpB,UAAO,OAAO,KAAK;AACnB,QAAK,KAAK,OAAO;aAEZ,KAAK,SAAS,KAAK,aAAa,KAAK,SAAS,KAAK,WAAW;AAEnE,QAAK,SAAS,KAAK;AACnB,QAAK,QAAQ,KAAK;aAEb,KAAK,SAAS,KAAK,WAAW;AAEnC,QAAK,QAAQ,KAAK,MAAM;AACxB,QAAK,MAAM,OAAO,KAAK;aAElB,KAAK,SAAS,KAAK,WAAW;AAEnC,QAAK,SAAS,KAAK,OAAO;AAC1B,QAAK,OAAO,OAAO,KAAK;;AAG5B,OAAK,SAAS;;CAElB,EAAE,OAAO,YAAY;EACjB,IAAI,OAAO,KAAK;AAChB,SAAO,SAAS,KAAK,WAAW;AAC5B,SAAM,KAAK;AACX,UAAO,KAAK;;;;;;;ACpHxB,IAAI;AACJ,MAAM,mBAAmB;AACzB,IAAI,aAAa;AACjB,IAAI,eAAe;AACnB,IAAI,WAAW;AAEf,IAAI,YAAY;AAChB,IAAI,SAAS;AAEb,IAAI,SAAS;AAEb,IAAI,UAAU;AACd,IAAI,YAAY;AAEhB,IAAI,aAAa;AACjB,MAAa,UAAW,OAAO,SAAS,WAAW,OAAO,OAAO,WAAW,WAAW,SAAS,EAAE;AAClG,IAAI,cAAc;AAClB,IAAI,OAAO,QAAQ,WAAW,eAAe,OAAO,QAAQ,OAAO,YAAY,YAE3E,eAAc,QAAQ,OAAO;SAExB,OAAO,YAAY,YAExB,eAAc;AAGlB,MAAM,qBADoB,SAAS,KAAK,gBAAgB,QAAQ,gBAAgB,KAAK,IAAI,KAAK,IAAI,YAAY,cAAc,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,cAAc,aAC7H,gBAAgB,QAAQ,gBAAgB,KAAK,IAAI,KAAK,IAAI,YAAY,UAAU;AAEjI,IAAI,OAAO,cAAc,YAAY,CAAC,oBAAoB;AACtD,cAAa,UAAU;AACvB,cAAa,WAAW,QAAQ,UAAU,IAAI;AAC9C,gBAAe,WAAW,QAAQ,YAAY,IAAI;AAClD,WAAU,WAAW,QAAQ,YAAY,IAAI,KAAK,WAAW,QAAQ,OAAO,IAAI,KAAK,WAAW,QAAQ,SAAS,IAAI,MAAM,CAAC,CAAC,UAAU,kBAAkB,UAAU,iBAAiB;AACpL,YAAW,WAAW,QAAQ,QAAQ,IAAI;AAC1C,UAAS;AACT,WAAU,UAAU;AACpB,aAAY;WAGP,OAAO,gBAAgB,UAAU;AACtC,cAAc,YAAY,aAAa;AACvC,gBAAgB,YAAY,aAAa;AACzC,YAAY,YAAY,aAAa;AACrC,CAAe,YAAc,YAAY,IAAI,WAAa,YAAY,IAAI;AAE1E,CAAU,YAAY,IAAI,SAAW,YAAY,IAAI;AACrD,WAAU;AACV,aAAY;CACZ,MAAM,eAAe,YAAY,IAAI;AACrC,KAAI,aACA,KAAI;EACA,MAAM,YAAY,KAAK,MAAM,aAAa;EAC1C,MAAM,WAAW,UAAU,mBAAmB;AAC9C,YAAU,UAAU;AAEpB,cAAY,WAAW,WAAW;AAClC,EAA0B,UAAU;UAEjC,GAAG;AAGd,aAAY;MAIZ,SAAQ,MAAM,8BAA8B;AAiBhD,MAAa,cAAe,UAAU,OAAO,QAAQ,kBAAkB;AAEvE,MAAa,YAAY;;;;;;;AAazB,MAAa,qBAAqB;AAC9B,KAAI,OAAO,QAAQ,gBAAgB,cAAc,CAAC,QAAQ,eAAe;EACrE,IAAI,UAAU,EAAE;AAChB,UAAQ,iBAAiB,YAAY,MAAM;AACvC,OAAI,EAAE,QAAQ,EAAE,KAAK,wBACjB,MAAK,IAAI,IAAI,GAAG,MAAM,QAAQ,QAAQ,IAAI,KAAK,KAAK;IAChD,MAAM,YAAY,QAAQ;AAC1B,QAAI,UAAU,OAAO,EAAE,KAAK,yBAAyB;AACjD,aAAQ,OAAO,GAAG,EAAE;AACpB,eAAU,UAAU;AACpB;;;IAId;EACF,IAAI,SAAS;AACb,UAAQ,aAAa;GACjB,MAAM,OAAO,EAAE;AACf,WAAQ,KAAK;IACT,IAAI;IACM;IACb,CAAC;AACF,WAAQ,YAAY,EAAE,yBAAyB,MAAM,EAAE,IAAI;;;AAGnE,SAAQ,aAAa,WAAW,SAAS;IACzC;AAEJ,IAAI,kBAAkB;AACtB,IAAI,0BAA0B;AAC9B,SAAgB,iBAAiB;AAC7B,KAAI,CAAC,yBAAyB;AAC1B,4BAA0B;EAC1B,MAAM,OAAO,IAAI,WAAW,EAAE;AAC9B,OAAK,KAAK;AACV,OAAK,KAAK;AAEV,oBADa,IAAI,YAAY,KAAK,OAAO,CACjB,OAAO;;AAEnC,QAAO;;AAEX,MAAa,WAAW,CAAC,EAAE,aAAa,UAAU,QAAQ,SAAS,IAAI;AACvE,MAAa,YAAY,CAAC,EAAE,aAAa,UAAU,QAAQ,UAAU,IAAI;AACzE,MAAa,WAAW,CAAC,EAAE,CAAC,YAAa,aAAa,UAAU,QAAQ,SAAS,IAAI;AACrF,MAAa,SAAS,CAAC,EAAE,aAAa,UAAU,QAAQ,OAAO,IAAI;AACnE,MAAa,YAAY,CAAC,EAAE,aAAa,UAAU,QAAQ,UAAU,IAAI;;;;AC7IzE,MAAM,oBAAqB,QAAQ,eAAe,OAAO,QAAQ,YAAY,QAAQ;AACrF,IAAa,YAAb,MAAa,UAAU;CACnB,YAAY,gBAAgB;AACxB,OAAK,kBAAkB,qBAAqB;AAC5C,OAAK,aAAa,KAAK,MAAM;AAC7B,OAAK,YAAY;;CAErB,OAAO,OAAO,iBAAiB,MAAM;AACjC,SAAO,IAAI,UAAU,eAAe;;CAExC,OAAO;AACH,OAAK,YAAY,KAAK,MAAM;;CAEhC,UAAU;AACN,MAAI,KAAK,cAAc,GACnB,QAAO,KAAK,YAAY,KAAK;AAEjC,SAAO,KAAK,MAAM,GAAG,KAAK;;CAE9B,OAAO;AACH,SAAO,KAAK,kBAAkB,QAAQ,YAAY,KAAK,GAAG,KAAK,KAAK;;;;;;ACX5E,IAAW;CACV,SAAU,SAAO;AACd,SAAM,aAAa,WAAW;CAC9B,SAAS,sBAAsB,SAAS;;;;CAiBxC,SAASC,OAAK,OAAO;AACjB,UAAQ,UAAU,WAAW,MAAM,gBAAgB;GAE/C,IAAI,UAAU;GACd,IAAI;AACJ,YAAS,OAAM,MAAK;AAChB,QAAI,QACA;aAEK,OACL,QAAO,SAAS;QAGhB,WAAU;AAEd,WAAO,SAAS,KAAK,UAAU,EAAE;MAClC,MAAM,YAAY;AACrB,OAAI,QACA,QAAO,SAAS;AAEpB,UAAO;;;AAGf,SAAM,OAAOA;;;;;;CAMb,SAAS,IAAI,OAAO,OAAK,YAAY;AACjC,SAAO,UAAU,UAAU,WAAW,MAAM,gBAAgB,OAAM,MAAK,SAAS,KAAK,UAAUC,MAAI,EAAE,CAAC,EAAE,MAAM,YAAY,EAAE,WAAW;;AAE3I,SAAM,MAAM;;;;;;CAMZ,SAAS,QAAQ,OAAO,MAAM,YAAY;AACtC,SAAO,UAAU,UAAU,WAAW,MAAM,gBAAgB,OAAM,MAAK;AAAE,QAAK,EAAE;AAAE,YAAS,KAAK,UAAU,EAAE;KAAK,MAAM,YAAY,EAAE,WAAW;;AAEpJ,SAAM,UAAU;CAChB,SAAS,OAAO,OAAO,UAAQ,YAAY;AACvC,SAAO,UAAU,UAAU,WAAW,MAAM,gBAAgB,OAAM,MAAKC,SAAO,EAAE,IAAI,SAAS,KAAK,UAAU,EAAE,EAAE,MAAM,YAAY,EAAE,WAAW;;AAEnJ,SAAM,SAAS;;;;CAIf,SAASC,SAAO,OAAO;AACnB,SAAO;;AAEX,SAAM,SAASA;CACf,SAAS,IAAI,GAAG,QAAQ;AACpB,UAAQ,UAAU,WAAW,MAAM,gBAAgB,mBAAmB,GAAG,OAAO,KAAI,UAAS,OAAM,MAAK,SAAS,KAAK,UAAU,EAAE,EAAE,MAAM,YAAY,CAAC,CAAC;;AAE5J,SAAM,MAAM;;;;;;CAMZ,SAAS,OAAO,OAAO,OAAO,SAAS,YAAY;EAC/C,IAAI,SAAS;AACb,SAAO,IAAI,QAAO,MAAK;AACnB,YAAS,MAAM,QAAQ,EAAE;AACzB,UAAO;KACR,WAAW;;AAElB,SAAM,SAAS;CACf,SAAS,SAAS,OAAO,YAAY;EACjC,IAAI;EACJ,MAAM,UAAU;GACZ,qBAAqB;AACjB,eAAW,MAAM,QAAQ,MAAM,QAAQ;;GAE3C,uBAAuB;AACnB,aAAS,SAAS;;GAEzB;AACD,MAAI,CAAC,WACD,uBAAsB,QAAQ;EAElC,MAAM,UAAU,IAAI,QAAQ,QAAQ;AACpC,MAAI,WACA,YAAW,IAAI,QAAQ;AAE3B,SAAO,QAAQ;;CAEnB,SAAS,SAAS,OAAO,OAAO,QAAQ,KAAK,UAAU,OAAO,sBAAsB,YAAY;EAC5F,IAAI;EACJ,IAAI,SAAS;EACb,IAAI,SAAS;EACb,IAAI,oBAAoB;EACxB,MAAM,UAAU;GACZ;GACA,qBAAqB;AACjB,mBAAe,OAAM,QAAO;AACxB;AACA,cAAS,MAAM,QAAQ,IAAI;AAC3B,SAAI,WAAW,CAAC,QAAQ;AACpB,cAAQ,KAAK,OAAO;AACpB,eAAS;;AAEb,kBAAa,OAAO;AACpB,cAAS,iBAAiB;MACtB,MAAM,UAAU;AAChB,eAAS;AACT,eAAS;AACT,UAAI,CAAC,WAAW,oBAAoB,EAChC,SAAQ,KAAK,QAAQ;AAEzB,0BAAoB;QACrB,MAAM;MACX;;GAEN,uBAAuB;AACnB,iBAAa,SAAS;;GAE7B;AACD,MAAI,CAAC,WACD,uBAAsB,QAAQ;EAElC,MAAM,UAAU,IAAI,QAAQ,QAAQ;AACpC,MAAI,WACA,YAAW,IAAI,QAAQ;AAE3B,SAAO,QAAQ;;AAEnB,SAAM,WAAW;;;;;;CAMjB,SAAS,MAAM,OAAO,UAAU,GAAG,MAAM,MAAM,GAAG,YAAY;EAC1D,IAAI,YAAY;EAChB,IAAI;AACJ,SAAO,OAAO,QAAO,UAAS;GAC1B,MAAM,aAAa,aAAa,CAAC,OAAO,OAAO,MAAM;AACrD,eAAY;AACZ,WAAQ;AACR,UAAO;KACR,WAAW;;AAElB,SAAM,QAAQ;;;;;;CAMd,SAAS,MAAM,OAAO,KAAK,YAAY;AACnC,SAAO,CACHC,QAAM,OAAO,OAAO,KAAK,WAAW,EACpCA,QAAM,OAAO,QAAO,MAAK,CAAC,IAAI,EAAE,EAAE,WAAW,CAChD;;AAEL,SAAM,QAAQ;;;;;;CAMd,SAAS,OAAO,OAAO,oBAAoB,OAAO,UAAU,EAAE,EAAE;EAC5D,IAAIC,WAAS,QAAQ,OAAO;EAC5B,IAAI,WAAW,OAAM,MAAK;AACtB,OAAIA,SACA,UAAO,KAAK,EAAE;OAGd,SAAQ,KAAK,EAAE;IAErB;EACF,MAAM,cAAc;AAChB,OAAIA,SACA,UAAO,SAAQ,MAAK,QAAQ,KAAK,EAAE,CAAC;AAExC,cAAS;;EAEb,MAAM,UAAU,IAAI,QAAQ;GACxB,qBAAqB;AACjB,QAAI,CAAC,SACD,YAAW,OAAM,MAAK,QAAQ,KAAK,EAAE,CAAC;;GAG9C,wBAAwB;AACpB,QAAIA,SACA,KAAI,kBACA,YAAW,MAAM;QAGjB,QAAO;;GAInB,uBAAuB;AACnB,QAAI,SACA,UAAS,SAAS;AAEtB,eAAW;;GAElB,CAAC;AACF,SAAO,QAAQ;;AAEnB,SAAM,SAAS;CACf,MAAM,eAAe;EACjB,YAAY,OAAO;AACf,QAAK,QAAQ;;EAEjB,IAAI,IAAI;AACJ,UAAO,IAAI,eAAe,IAAI,KAAK,OAAO,GAAG,CAAC;;EAElD,QAAQ,IAAI;AACR,UAAO,IAAI,eAAe,QAAQ,KAAK,OAAO,GAAG,CAAC;;EAEtD,OAAO,IAAI;AACP,UAAO,IAAI,eAAe,OAAO,KAAK,OAAO,GAAG,CAAC;;EAErD,OAAO,OAAO,SAAS;AACnB,UAAO,IAAI,eAAe,OAAO,KAAK,OAAO,OAAO,QAAQ,CAAC;;EAEjE,QAAQ;AACJ,UAAO,IAAI,eAAe,MAAM,KAAK,MAAM,CAAC;;EAEhD,SAAS,OAAO,QAAQ,KAAK,UAAU,OAAO,sBAAsB;AAChE,UAAO,IAAI,eAAe,SAAS,KAAK,OAAO,OAAO,OAAO,SAAS,qBAAqB,CAAC;;EAEhG,GAAG,UAAU,UAAU,aAAa;AAChC,UAAO,KAAK,MAAM,UAAU,UAAU,YAAY;;EAEtD,KAAK,UAAU,UAAU,aAAa;AAClC,UAAOL,OAAK,KAAK,MAAM,CAAC,UAAU,UAAU,YAAY;;;;;;CAMhE,SAAS,MAAM,OAAO;AAClB,SAAO,IAAI,eAAe,MAAM;;AAEpC,SAAM,QAAQ;CACd,SAAS,qBAAqB,SAAS,WAAW,SAAM,OAAM,IAAI;EAC9D,MAAM,MAAM,GAAG,SAAS,OAAO,KAAKC,MAAI,GAAG,KAAK,CAAC;EACjD,MAAM,2BAA2B,QAAQ,GAAG,WAAW,GAAG;EAC1D,MAAM,6BAA6B,QAAQ,eAAe,WAAW,GAAG;EACxE,MAAM,SAAS,IAAI,QAAQ;GAAE;GAAoB;GAAsB,CAAC;AACxE,SAAO,OAAO;;AAElB,SAAM,uBAAuB;CAC7B,SAAS,oBAAoB,SAAS,WAAW,SAAM,OAAM,IAAI;EAC7D,MAAM,MAAM,GAAG,SAAS,OAAO,KAAKA,MAAI,GAAG,KAAK,CAAC;EACjD,MAAM,2BAA2B,QAAQ,iBAAiB,WAAW,GAAG;EACxE,MAAM,6BAA6B,QAAQ,oBAAoB,WAAW,GAAG;EAC7E,MAAM,SAAS,IAAI,QAAQ;GAAE;GAAoB;GAAsB,CAAC;AACxE,SAAO,OAAO;;AAElB,SAAM,sBAAsB;CAC5B,SAAS,UAAU,OAAO;AACtB,SAAO,IAAI,SAAQ,YAAWD,OAAK,MAAM,CAAC,QAAQ,CAAC;;AAEvD,SAAM,YAAY;CAClB,SAAS,gBAAgB,OAAO,SAAS;AACrC,UAAQ,OAAU;AAClB,SAAO,OAAM,MAAK,QAAQ,EAAE,CAAC;;AAEjC,SAAM,kBAAkB;CACxB,SAAS,yBAAyB,OAAO,SAAS;EAC9C,IAAI,QAAQ;EACZ,SAAS,IAAI,GAAG;AACZ,aAAU,QAAQ,UAAU,KAAK,KAAa,MAAM,SAAS;AAC7D,WAAQ,IAAI,iBAAiB;AAC7B,WAAQ,GAAG,MAAM;;AAErB,MAAI,OAAU;EACd,MAAM,aAAa,OAAM,MAAK,IAAI,EAAE,CAAC;AACrC,SAAO,mBAAmB;AACtB,cAAW,SAAS;AACpB,aAAU,QAAQ,UAAU,KAAK,KAAa,MAAM,SAAS;IAC/D;;AAEN,SAAM,2BAA2B;GAClC,UAAU,QAAQ,EAAE,EAAE;AACzB,IAAM,iBAAN,MAAM,eAAe;CACjB,YAAY,MAAM;AACd,OAAK,iBAAiB;AACtB,OAAK,mBAAmB;AACxB,OAAK,kBAAkB;AACvB,OAAK,QAAQ,GAAG,KAAK,GAAG,eAAe;;CAE3C,MAAM,eAAe;AACjB,OAAK,aAAa,IAAI,UAAU,KAAK;AACrC,OAAK,iBAAiB;;CAE1B,OAAO;AACH,MAAI,KAAK,YAAY;GACjB,MAAM,UAAU,KAAK,WAAW,SAAS;AACzC,QAAK,mBAAmB;AACxB,QAAK,oBAAoB;AACzB,WAAQ,KAAK,YAAY,KAAK,MAAM,gBAAgB,QAAQ,QAAQ,EAAE,CAAC,cAAc,KAAK,eAAe,qBAAqB,KAAK,gBAAgB,QAAQ,EAAE,CAAC,iBAAiB,KAAK,iBAAiB,GAAG;AACxM,QAAK,aAAa;;;;AAI9B,eAAe,UAAU;AACzB,IAAI,8BAA8B;AAClC,IAAM,iBAAN,MAAqB;CACjB,YAAY,iBAAiB,OAAO,KAAK,QAAQ,CAAC,SAAS,GAAG,CAAC,MAAM,GAAG,EAAE,EAAE;AACxE,OAAK,kBAAkB;AACvB,OAAK,OAAO;AACZ,OAAK,iBAAiB;;CAE1B,UAAU;AACN,MAAI,KAAK,QACL,MAAK,QAAQ,OAAO;;CAG5B,MAAM,OAAO,eAAe;EACxB,IAAI,YAAY;AAChB,MAAI,OAAO,KAAK,oBAAoB,SAChC,aAAY,KAAK;AAErB,MAAI,aAAa,KAAK,gBAAgB,UAClC;AAEJ,MAAI,CAAC,KAAK,QACN,MAAK,0BAAU,IAAI,KAAK;EAE5B,MAAM,QAAS,KAAK,QAAQ,IAAI,MAAM,MAAM,IAAI;AAChD,OAAK,QAAQ,IAAI,MAAM,OAAO,QAAQ,EAAE;AACxC,OAAK,kBAAkB;AACvB,MAAI,KAAK,kBAAkB,GAAG;AAG1B,QAAK,iBAAiB,YAAY;GAElC,IAAI;GACJ,IAAI,WAAW;AACf,QAAK,MAAM,CAACM,SAAOC,YAAU,KAAK,QAC9B,KAAI,CAAC,YAAY,WAAWA,SAAO;AAC/B,eAAWD;AACX,eAAWC;;AAGnB,WAAQ,KAAK,IAAI,KAAK,KAAK,6CAA6C,cAAc,8CAA8C,SAAS,IAAI;AACjJ,WAAQ,KAAK,SAAS;;AAE1B,eAAa;GACT,MAAMA,UAAS,KAAK,QAAQ,IAAI,MAAM,MAAM,IAAI;AAChD,QAAK,QAAQ,IAAI,MAAM,OAAOA,UAAQ,EAAE;;;;AAIpD,IAAM,aAAN,MAAM,WAAW;CACb,YAAY,OAAO;AACf,OAAK,QAAQ;;CAEjB,OAAO,SAAS;EACZ,IAAIC;AACJ,SAAO,IAAI,YAAY,wBAAK,IAAI,OAAO,EAAC,WAAW,QAAQA,SAAO,KAAK,IAAIA,OAAK,GAAG;;CAEvF,QAAQ;AACJ,UAAQ,KAAK,KAAK,MAAM,MAAM,KAAK,CAAC,MAAM,EAAE,CAAC,KAAK,KAAK,CAAC;;;AAGhE,IAAM,WAAN,MAAe;CACX,YAAY,UAAU,cAAc,OAAO;AACvC,OAAK,WAAW;AAChB,OAAK,eAAe;AACpB,OAAK,QAAQ;AACb,OAAK,eAAe,IAAI,gBAAgB;;CAE5C,OAAO,GAAG;AACN,OAAK,SAAS,KAAK,KAAK,cAAc,EAAE;;;;;;;;;;;;;;;;;;;;;;;;AAwBhD,IAAa,UAAb,MAAqB;CACjB,YAAY,SAAS;EACjB,IAAIA;AACJ,OAAK,YAAY;AACjB,OAAK,WAAW;AAChB,OAAK,cAAc,8BAA8B,IAAI,IAAI,eAAe,KAAK,YAAY,KAAK,SAAS,qBAAqB,GAAG;AAC/H,OAAK,aAAa,OAAK,KAAK,cAAc,QAAQA,SAAO,KAAK,IAAI,KAAK,IAAIA,KAAG,aAAa,IAAI,eAAe,KAAK,SAAS,UAAU,GAAG;;CAE7I,UAAU;EACN,IAAIA,MAAI,IAAI,IAAI;AAChB,MAAI,CAAC,KAAK,WAAW;AACjB,QAAK,YAAY;AAUjB,OAAI,KAAK,WAaL,MAAK,WAAW,OAAO;AAE3B,IAAC,OAAK,KAAK,oBAAoB,QAAQA,SAAO,KAAK,KAAaA,KAAG,OAAO;AAC1E,IAAC,MAAM,KAAK,KAAK,cAAc,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,0BAA0B,QAAQ,OAAO,KAAK,KAAa,GAAG,KAAK,GAAG;AACzI,IAAC,KAAK,KAAK,iBAAiB,QAAQ,OAAO,KAAK,KAAa,GAAG,SAAS;;;;;;;CAOjF,IAAI,QAAQ;AACR,MAAI,CAAC,KAAK,OACN,MAAK,UAAU,UAAU,UAAU,gBAAgB;GAC/C,IAAIA,MAAI,IAAI;AACZ,OAAI,CAAC,KAAK,WACN,MAAK,aAAa,IAAI,YAAY;GAEtC,MAAM,gBAAgB,KAAK,WAAW,SAAS;AAC/C,OAAI,mBAAmB,OAAK,KAAK,cAAc,QAAQA,SAAO,KAAK,IAAI,KAAK,IAAIA,KAAG,oBAC/E,MAAK,SAAS,mBAAmB,KAAK;GAE1C,IAAI;GACJ,IAAI;AACJ,OAAI,KAAK,eAAe,KAAK,WAAW,QAAQ,IAAI;AAEhD,YAAQ,WAAW,QAAQ;AAC3B,oBAAgB,KAAK,YAAY,MAAM,OAAO,KAAK,WAAW,OAAO,EAAE;;GAK3E,MAAM,WAAW,IAAI,SAAS,UAAU,UAAU,MAAM;GACxD,MAAM,iBAAiB,KAAK,WAAW,KAAK,SAAS;AACrD,OAAI,mBAAmB,KAAK,KAAK,cAAc,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,uBAC/E,MAAK,SAAS,sBAAsB,KAAK;AAE7C,QAAK,KAAK,KAAK,cAAc,QAAQ,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,iBAC7D,MAAK,SAAS,iBAAiB,MAAM,UAAU,SAAS;GAE5D,MAAM,SAAS,SAAS,aAAa,UAAU;AAC3C,QAAI,cACA,gBAAe;AAEnB,QAAI,CAAC,KAAK,WAAW;AACjB,qBAAgB;AAChB,SAAI,KAAK,YAAY,KAAK,SAAS,sBAE/B;UAAI,EADkB,KAAK,cAAc,CAAC,KAAK,WAAW,SAAS,EAE/D,MAAK,SAAS,qBAAqB,KAAK;;;KAItD;AACF,OAAI,uBAAuB,gBACvB,aAAY,IAAI,OAAO;YAElB,MAAM,QAAQ,YAAY,CAC/B,aAAY,KAAK,OAAO;AAE5B,UAAO;;AAGf,SAAO,KAAK;;;;;;CAMhB,KAAK,OAAO;EACR,IAAIA,MAAI;AACR,MAAI,KAAK,YAAY;AAIjB,OAAI,CAAC,KAAK,eACN,MAAK,iBAAiB,IAAI,YAAY;AAE1C,QAAK,IAAI,YAAY,KAAK,WACtB,MAAK,eAAe,KAAK,CAAC,UAAU,MAAM,CAAC;AAG/C,IAAC,OAAK,KAAK,cAAc,QAAQA,SAAO,KAAK,KAAaA,KAAG,MAAM,KAAK,eAAe,KAAK;AAC5F,UAAO,KAAK,eAAe,OAAO,GAAG;IACjC,MAAM,CAAC,UAAUC,WAAS,KAAK,eAAe,OAAO;AACrD,QAAI;AACA,cAAS,OAAOA,QAAM;aAEnB,GAAG;AACN,uBAAkB,EAAE;;;AAG5B,IAAC,KAAK,KAAK,cAAc,QAAQ,OAAO,KAAK,KAAa,GAAG,MAAM;;;;;;;ACxiB/E,MAAa,wBAAwB;;;;;;;;AAQrC,SAAS,iBAAiB,eAAe,IAAI;CACzC,IAAI,SAAS;AACb,MAAK,MAAM,OAAO,uBAAuB;AACrC,MAAI,aAAa,QAAQ,IAAI,IAAI,EAC7B;AAEJ,YAAU,OAAO;;AAErB,WAAU;AACV,QAAO,IAAI,OAAO,QAAQ,IAAI;;AAGlC,MAAa,sBAAsB,kBAAkB;AACrD,SAAgB,0BAA0B,gBAAgB;CACtD,IAAI,SAAS;AACb,KAAI,kBAAmB,0BAA0B,OAC7C,KAAI,CAAC,eAAe,QAAQ;EACxB,IAAI,QAAQ;AACZ,MAAI,eAAe,WACf,UAAS;AAEb,MAAI,eAAe,UACf,UAAS;AAEb,MAAI,eAAe,QACf,UAAS;AAEb,WAAS,IAAI,OAAO,eAAe,QAAQ,MAAM;OAGjD,UAAS;AAGjB,QAAO,YAAY;AACnB,QAAO;;;;;;;;ACvCX,IAAW;CACV,SAAU,gBAAc;;;;AAIrB,gBAAa,eAAa,UAAU,KAAK;;;;AAIzC,gBAAa,eAAa,YAAY,KAAK;;;;;;AAM3C,gBAAa,eAAa,mBAAmB,KAAK;;;;AAIlD,gBAAa,eAAa,aAAa,KAAK;GAC7C,iBAAiB,eAAe,EAAE,EAAE;;;;AAIvC,IAAa,qCAAb,MAAgD;CAC5C,YAAY,QAAQ;AAChB,OAAK,oBAAoB;AACzB,OAAK,4BAA4B;AACjC,OAAK,OAAO,OAAO;AACnB,OAAK,QAAQ,OAAO;AAEpB,OAAK,YAAY;AACjB,OAAK,aAAa;AAClB,OAAK,WAAW;AAChB,MAAI,MAAM,QAAQ,OAAO,MAAM,CAC3B,MAAK,IAAI,IAAI,GAAG,MAAM,OAAO,MAAM,QAAQ,IAAI,KAAK,IAEhD,SADc,OAAO,MAAM,IAC3B;GACI,KAAK;AACD,SAAK,YAAY;AACjB;GACJ,KAAK;AACD,SAAK,aAAa;AAClB;GACJ,KAAK;AACD,SAAK,WAAW;AAChB;;;CAKpB,KAAK,eAAe;AAChB,UAAQ,eAAR;GACI,KAAK,EACD,QAAO;GACX,KAAK,EACD,QAAO,KAAK;GAChB,KAAK,EACD,QAAO,KAAK;GAChB,KAAK,EACD,QAAO,KAAK;;;CAGxB,gBAAgB,SAAS,QAAQ;AAE7B,MAAI,QAAQ,eAAe,KAAK,EAC5B,QAAO;EAEX,MAAM,aAAa,QAAQ,uBAAuB,SAAS,EAAE;EAC7D,MAAM,oBAAoB,QAAQ,qBAAqB,WAAW;AAClE,SAAO,KAAK,KAAK,kBAAkB;;CAEvC,6BAA6B,cAAc,YAAY;AACnD,OAAK,IAAI,WAAW,cAAc,YAAY,YAAY,YAAY;GAClE,MAAM,YAAY,OAAO,aAAa,SAAS;AAC/C,OAAI,CAAC,KAAK,KAAK,SAAS,UAAU,IAAI,CAAC,KAAK,MAAM,SAAS,UAAU,CACjE,QAAO;;AAGf,SAAO;;;;;CAKX,uBAAuB;AACnB,MAAI,CAAC,KAAK,2BAA2B;AACjC,QAAK,4BAA4B;AACjC,OAAI,CAAC,KAAK,kBACN,MAAK,oBAAoB,KAAK,6BAA6B,IAAiB,GAAgB;AAEhG,OAAI,CAAC,KAAK,kBACN,MAAK,oBAAoB,KAAK,6BAA6B,IAAY,IAAY;AAEvF,OAAI,CAAC,KAAK,kBACN,MAAK,oBAAoB,KAAK,6BAA6B,IAAY,GAAW;;AAG1F,SAAO,KAAK;;;;;;AAMpB,IAAa,mBAAb,MAA8B;CAC1B,YAAY,kBAAkB;AAC1B,OAAK,8CAA8B,IAAI,KAAK;AAC5C,OAAK,4CAA4B,IAAI,KAAK;AAC1C,OAAK,+CAA+B,IAAI,KAAK;AAC7C,OAAK,6CAA6B,IAAI,KAAK;AAC3C,OAAK,kDAAkC,IAAI,KAAK;AAChD,OAAK,MAAM,QAAQ,kBAAkB;AACjC,eAAY,KAAK,6BAA6B,KAAK,KAAK,OAAO,EAAE,EAAE,KAAK;AACxE,eAAY,KAAK,2BAA2B,KAAK,KAAK,OAAO,KAAK,KAAK,SAAS,EAAE,EAAE,KAAK;AACzF,eAAY,KAAK,8BAA8B,KAAK,MAAM,OAAO,EAAE,EAAE,KAAK;AAC1E,eAAY,KAAK,4BAA4B,KAAK,MAAM,OAAO,KAAK,MAAM,SAAS,EAAE,EAAE,KAAK;AAC5F,OAAI,KAAK,MAAM,WAAW,KAAK,KAAK,KAAK,WAAW,EAChD,aAAY,KAAK,iCAAiC,KAAK,OAAO,KAAK;;;;AAKnF,SAAS,YAAY,QAAQ,KAAK,OAAO;AACrC,KAAI,OAAO,IAAI,IAAI,CACf,QAAO,IAAI,IAAI,CAAC,KAAK,MAAM;KAG3B,QAAO,IAAI,KAAK,CAAC,MAAM,CAAC;;;;;ACjIhC,SAAgB,uBAAuB,SAAS,QAAQ;CACpD,MAAM,aAAa,QAAQ,UAAU;CACrC,MAAM,aAAa,QAAQ,uBAAuB,OAAO;CACzD,MAAM,oBAAoB,QAAQ,cAAc,WAAW;CAC3D,IAAI,iBAAiB;AACrB,QAAO,iBAAiB,IAAI,cAAc,QAAQ,cAAc,iBAAiB,EAAE,KAAK,kBACpF;CAEJ,IAAI,kBAAkB;AACtB,QAAO,kBAAkB,KAAK,QAAQ,cAAc,kBAAkB,EAAE,KAAK,kBACzE;AAEJ,QAAO,IAAI,iBAAiB,SAAS,mBAAmB,iBAAiB,iBAAiB,GAAG,QAAQ,eAAe,gBAAgB,EAAE,QAAQ,aAAa,eAAe,CAAC;;AAE/K,IAAa,mBAAb,MAA8B;CAC1B,YAAY,QAAQ,YAAY,iBAAiB,gBAAgB,iBAAiB,gBAAgB;AAC9F,OAAK,yBAAyB;AAC9B,OAAK,UAAU;AACf,OAAK,aAAa;AAClB,OAAK,mBAAmB;AACxB,OAAK,kBAAkB;AACvB,OAAK,kBAAkB;AACvB,OAAK,kBAAkB;;CAE3B,iBAAiB;AAEb,SAD0B,KAAK,QAAQ,gBAAgB,CAC9B,UAAU,KAAK,iBAAiB,KAAK,gBAAgB;;CAElF,2BAA2B,QAAQ;AAE/B,SAD0B,KAAK,QAAQ,gBAAgB,CAC9B,UAAU,GAAG,KAAK,kBAAkB,OAAO;;CAExE,gBAAgB;AACZ,SAAO,KAAK,kBAAkB,KAAK;;CAEvC,uBAAuB,QAAQ;AAC3B,SAAO,KAAK,QAAQ,uBAAuB,SAAS,KAAK,gBAAgB,GAAG,KAAK;;CAErF,qBAAqB,YAAY;AAC7B,SAAO,KAAK,QAAQ,qBAAqB,aAAa,KAAK,iBAAiB;;;AAGpF,SAAgB,sBAAsB,mBAAmB;AACrD,SAAQ,oBAAoB,OAAmB;;;;;AC1CnD,IAAa,uBAAb,MAAa,qBAAqB;CAC9B,YAAY,QAAQ;AAChB,MAAI,OAAO,iBACP,MAAK,oBAAoB,OAAO,iBAAiB,KAAI,OAAM,IAAI,mCAAmC,GAAG,CAAC;WAEjG,OAAO,SACZ,MAAK,oBAAoB,OAAO,SAAS,KAAI,MAAK,IAAI,mCAAmC;GAAE,MAAM,EAAE;GAAI,OAAO,EAAE;GAAI,CAAC,CAAC;MAGtH,MAAK,oBAAoB,EAAE;AAE/B,MAAI,OAAO,sBACP,MAAK,yBAAyB,oBAAoB,OAAO,sBAAsB,KAAI,MAAK,CAAC,EAAE,IAAI,EAAE,GAAG,CAAC,CAAC;WAEjG,OAAO,SACZ,MAAK,yBAAyB,oBAAoB,OAAO,SACpD,KAAK,MAAM,CAAC,EAAE,IAAI,EAAE,GAAG,CAAC,CAKxB,QAAQ,MAAM,EAAE,EAAE,OAAO,OAAO,EAAE,OAAO,KAAK,CAAC;MAGpD,MAAK,yBAAyB,EAAE;AAEpC,MAAI,OAAO,8BAA8B,OAAO,2BAA2B,YAAY;GACnF,MAAM,aAAa,OAAO,2BAA2B;AAErD,QAAK,kBAAkB,KAAK,IAAI,mCAAmC;IAAE,MAAM,WAAW;IAAM,OAAO,WAAW,SAAS;IAAI,CAAC,CAAC;;AAEjI,OAAK,mBAAmB,OAAO,OAAO,oBAAoB,WAAW,OAAO,kBAAkB,qBAAqB;AACnH,OAAK,oBAAoB,OAAO,oBAAoB,KAAK;;CAE7D,sBAAsB;AAClB,SAAO,KAAK;;CAEhB,wBAAwB;AACpB,SAAO,KAAK;;CAEhB,sBAAsB;AAClB,SAAO,KAAK;;CAEhB,uBAAuB;AACnB,SAAO,KAAK;;;AAGpB,qBAAqB,4CAA4C;AACjE,SAAS,oBAAoB,cAAc;AACvC,QAAO,aAAa,QAAQ,CAAC,MAAM,WAAW,SAAS,MAAM,UAAU,GAAG;;;;;;;;;AC+E9E,SAAgB,SAAS,OAAO,SAAQ,UAAS,OAAO;CACpD,MAAM,uBAAO,IAAI,KAAK;AACtB,QAAO,MAAM,QAAO,YAAW;EAC3B,MAAM,MAAM,MAAM,QAAQ;AAC1B,MAAI,KAAK,IAAI,IAAI,CACb,QAAO;AAEX,OAAK,IAAI,IAAI;AACb,SAAO;GACT;;;;;AC9GN,SAAgB,aAAa,QAAQ,QAAQ;AACzC,QAAU,OAAO,SAAS,MAAM,MAAO,IACjC,OAAO,SAAS,MAAM,MAAO;;;;;AC3BvC,IAAI;AACJ,SAAS,yBAAyB;AAC9B,KAAI,CAAC,qBACD,wBAAuB,IAAI,YAAY,WAAW;AAEtD,QAAO;;AAEX,IAAI;AACJ,SAAS,yBAAyB;AAC9B,KAAI,CAAC,qBACD,wBAAuB,IAAI,YAAY,WAAW;AAEtD,QAAO;;AAEX,IAAI;AACJ,SAAgB,yBAAyB;AACrC,KAAI,CAAC,qBACD,wBAAuBC,gBAAyB,GAAG,wBAAwB,GAAG,wBAAwB;AAE1G,QAAO;;AAEX,MAAa,iBAAkB,OAAO,gBAAgB;AACtD,IAAW;AACX,IAAW;AACX,IAAI,gBAAgB;AAChB,wBAAuB,aAAa,IAAI,cAAc,SAAS;AAC/D,iBAAgB;OAEf;AACD,wBAAuB,aAAa,IAAI,qBAAqB;AAC7D,iBAAgB;;AAEpB,SAAS,sBAAsB,QAAQ,QAAQ,KAAK;CAChD,MAAM,OAAO,IAAI,YAAY,OAAO,QAAQ,QAAQ,IAAI;AACxD,KAAI,MAAM,MAAM,KAAK,OAAO,SAAU,KAAK,OAAO,OAK9C,QAAO,oBAAoB,QAAQ,QAAQ,IAAI;AAEnD,QAAO,wBAAwB,CAAC,OAAO,KAAK;;AAEhD,SAAS,oBAAoB,QAAQ,QAAQ,KAAK;CAC9C,MAAM,SAAS,EAAE;CACjB,IAAI,YAAY;AAChB,MAAK,IAAI,IAAI,GAAG,IAAI,KAAK,KAAK;EAC1B,MAAM,WAAWC,aAAoB,QAAQ,OAAO;AACpD,YAAU;AACV,SAAO,eAAe,OAAO,aAAa,SAAS;;AAEvD,QAAO,OAAO,KAAK,GAAG;;AAE1B,IAAM,gBAAN,MAAoB;CAChB,YAAY,UAAU;AAClB,OAAK,YAAY,WAAW;AAC5B,OAAK,UAAU,IAAI,YAAY,KAAK,UAAU;AAC9C,OAAK,oBAAoB;AACzB,OAAK,gBAAgB;;CAEzB,QAAQ;AACJ,OAAK,oBAAoB;AACzB,OAAK,gBAAgB;;CAEzB,QAAQ;AACJ,MAAI,KAAK,sBAAsB,MAAM;AACjC,QAAK,cAAc;AACnB,UAAO,KAAK,kBAAkB,KAAK,GAAG;;AAE1C,SAAO,KAAK,cAAc;;CAE9B,eAAe;AACX,MAAI,KAAK,kBAAkB,EACvB,QAAO;EAEX,MAAM,OAAO,IAAI,YAAY,KAAK,QAAQ,QAAQ,GAAG,KAAK,cAAc;AACxE,SAAO,wBAAwB,CAAC,OAAO,KAAK;;CAEhD,eAAe;EACX,MAAM,eAAe,KAAK,cAAc;AACxC,OAAK,gBAAgB;AACrB,MAAI,KAAK,sBAAsB,KAC3B,MAAK,oBAAoB,CAAC,aAAa;MAGvC,MAAK,kBAAkB,KAAK,kBAAkB,UAAU;;CAGhE,OAAO,UAAU;EACb,MAAM,iBAAiB,KAAK,YAAY,KAAK;AAC7C,MAAI,kBAAkB,GAClB;OAAI,mBAAmB,KAAKC,gBAAwB,SAAS,CACzD,MAAK,cAAc;;AAG3B,OAAK,QAAQ,KAAK,mBAAmB;;CAEzC,YAAY,UAAU;AAClB,MAAI,KAAK,kBAAkB,KAAK,UAE5B,MAAK,cAAc;AAEvB,OAAK,QAAQ,KAAK,mBAAmB;;CAEzC,kBAAkB,KAAK;EACnB,MAAM,SAAS,IAAI;AACnB,MAAI,KAAK,gBAAgB,UAAU,KAAK,WAAW;AAE/C,QAAK,cAAc;AACnB,QAAK,kBAAkB,KAAK,kBAAkB,UAAU;AACxD;;AAEJ,OAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IACxB,MAAK,QAAQ,KAAK,mBAAmB,IAAI,WAAW,EAAE;;;AAIlE,IAAM,sBAAN,MAA0B;CACtB,cAAc;AACV,OAAK,UAAU,EAAE;AACjB,OAAK,aAAa;;CAEtB,QAAQ;AACJ,OAAK,UAAU,EAAE;AACjB,OAAK,aAAa;;CAEtB,QAAQ;AACJ,SAAO,KAAK,QAAQ,KAAK,GAAG;;CAEhC,OAAO,UAAU;AACb,OAAK,QAAQ,KAAK,gBAAgB,OAAO,aAAa,SAAS;;CAEnE,YAAY,UAAU;AAClB,OAAK,QAAQ,KAAK,gBAAgB,OAAO,aAAa,SAAS;;CAEnE,kBAAkB,KAAK;AACnB,OAAK,QAAQ,KAAK,gBAAgB;;;;;;;;;;;;;;;;;;;;;ACzH1C,IAAa,kBAAb,MAAa,gBAAgB;CACzB,YAAY,YAAY,OAAO,MAAM,OAAO,cAAc,eAAe;AACrE,OAAK,wBAAwB;AAC7B,OAAK,aAAa;AAClB,OAAK,QAAQ;AACb,OAAK,OAAO;AACZ,OAAK,QAAQ;AACb,OAAK,eAAe;AACpB,OAAK,gBAAgB;AACrB,OAAK,WAAW,gBAAgB,OAAO,KAAK,KAAK;AACjD,OAAK,YAAY,gBAAgB,OAAO,KAAK,MAAM;;;;;CAKvD,OAAO,MAAM;AACT,SAAO,KAAK,SAAS,IAAI,KAAK;;;;;CAKlC,QAAQ,MAAM;AACV,SAAO,KAAK,UAAU,IAAI,KAAK;;CAEnC,OAAO,OAAO,KAAK;EACf,MAAM,yBAAS,IAAI,KAAK;AACxB,OAAK,MAAM,WAAW,IAClB,QAAO,IAAI,QAAQ;AAEvB,SAAO;;;;;;;;;;;;;;;;AAgBf,SAAS,mBAAmB,UAAU;CAClC,MAAM,IAAI,SAAS;AACnB,YAAW,SAAS,KAAI,MAAK,CAAC,EAAE,GAAG,aAAa,EAAE,EAAE,GAAG,aAAa,CAAC,CAAC;CACtE,MAAM,QAAQ,EAAE;AAChB,MAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IACnB,OAAM,KAAK;CAEf,MAAM,kBAAkB,GAAG,MAAM;EAC7B,MAAM,CAAC,OAAO,UAAU;EACxB,MAAM,CAAC,OAAO,UAAU;AACxB,SAAQ,UAAU,SAAS,UAAU,UAAU,WAAW,SAAS,WAAW;;CAElF,MAAM,eAAe,IAAI,OAAO;EAC5B,MAAM,OAAO,KAAK,IAAI,IAAI,GAAG;EAC7B,MAAM,OAAO,KAAK,IAAI,IAAI,GAAG;AAC7B,OAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IACnB,KAAI,MAAM,OAAO,KACb,OAAM,KAAK;;AAKvB,MAAK,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK;EACxB,MAAM,IAAI,SAAS;AACnB,OAAK,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK;GAC5B,MAAM,IAAI,SAAS;AACnB,OAAI,eAAe,GAAG,EAAE,CACpB,aAAY,MAAM,IAAI,MAAM,GAAG;;;CAI3C,MAAM,SAAS,EAAE;AACjB,MAAK,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK;EACxB,MAAM,cAAc,EAAE;EACtB,MAAM,eAAe,EAAE;AACvB,OAAK,IAAI,IAAI,GAAG,IAAI,GAAG,IACnB,KAAI,MAAM,OAAO,GAAG;GAChB,MAAM,CAAC,MAAM,SAAS,SAAS;AAC/B,eAAY,KAAK,KAAK;AACtB,gBAAa,KAAK,MAAM;;AAGhC,MAAI,YAAY,SAAS,EACrB,QAAO,KAAK;GACR,MAAM;GACN,OAAO;GACV,CAAC;;AAGV,QAAO;;AAEX,IAAa,mBAAb,MAA8B;CAC1B,YAAY,YAAY,WAAW;AAC/B,OAAK,yBAAyB;EAC9B,MAAM,WAAW,mBAAmB,UAAU;AAC9C,OAAK,WAAW,SAAS,KAAK,GAAG,UAAU;AACvC,UAAO,IAAI,gBAAgB,YAAY,OAAO,EAAE,MAAM,EAAE,OAAO,uBAAuB,EAAE,MAAM,EAAE,OAAO,UAAU,MAAM,EAAE,+BAA+B,EAAE,MAAM,EAAE,OAAO,UAAU,MAAM,CAAC;IAC5L;AACF,OAAK,eAAe,oBAAoB,KAAK,SAAS;AACtD,OAAK,gBAAgB,4BAA4B,KAAK,SAAS;AAC/D,OAAK,gBAAgB,EAAE;AACvB,OAAK,oBAAoB,EAAE;AAC3B,OAAK,mBAAmB;AACxB,OAAK,MAAM,WAAW,KAAK,UAAU;AACjC,QAAK,MAAM,QAAQ,QAAQ,MAAM;AAC7B,SAAK,cAAc,QAAQ;AAC3B,SAAK,kBAAkB,QAAQ;AAC/B,SAAK,mBAAmB,KAAK,IAAI,KAAK,kBAAkB,KAAK,OAAO;;AAExE,QAAK,MAAM,SAAS,QAAQ,OAAO;AAC/B,SAAK,cAAc,SAAS;AAC5B,SAAK,kBAAkB,SAAS;AAChC,SAAK,mBAAmB,KAAK,IAAI,KAAK,kBAAkB,MAAM,OAAO;;;;;AAKrF,SAAS,oBAAoB,KAAK,UAAU,cAAc,MAAM;AAC5D,MAAK,IAAI,IAAI,GAAG,MAAM,SAAS,QAAQ,IAAI,KAAK,KAAK;AACjD,MAAI,MAAM,aACN;EAEJ,MAAM,UAAU,SAAS;AACzB,OAAK,MAAM,QAAQ,QAAQ,KACvB,KAAI,KAAK,QAAQ,IAAI,IAAI,EACrB,MAAK,KAAK,KAAK;AAGvB,OAAK,MAAM,SAAS,QAAQ,MACxB,KAAI,MAAM,QAAQ,IAAI,IAAI,EACtB,MAAK,KAAK,MAAM;;;AAKhC,SAAS,UAAU,GAAG,GAAG;AACrB,QAAO,EAAE,SAAS,EAAE;;AAExB,SAAS,OAAO,KAAK;AACjB,KAAI,IAAI,UAAU,EACd,QAAO;CAEX,MAAM,SAAS,EAAE;CACjB,MAAM,uBAAO,IAAI,KAAK;AACtB,MAAK,MAAM,WAAW,KAAK;AACvB,MAAI,KAAK,IAAI,QAAQ,CACjB;AAEJ,SAAO,KAAK,QAAQ;AACpB,OAAK,IAAI,QAAQ;;AAErB,QAAO;;;;;;;;;;;;;;;;;;;;;;;;;AAyBX,SAAS,uBAAuB,MAAM,OAAO,UAAU,cAAc;CAEjE,IAAI,SAAS,EAAE;AACf,UAAS,OAAO,OAAO,KAAK;AAC5B,UAAS,OAAO,OAAO,MAAM;AAC7B,MAAK,IAAI,IAAI,GAAG,MAAM,OAAO,QAAQ,IAAI,KAAK,IAC1C,qBAAoB,OAAO,IAAI,UAAU,cAAc,OAAO;AAElE,UAAS,OAAO,OAAO;AACvB,QAAO,KAAK,UAAU;AACtB,QAAO,SAAS;AAChB,QAAO,sBAAsB,OAAO;;;;;;;;;;;;AAYxC,SAAS,+BAA+B,MAAM,OAAO,UAAU,cAAc;CAEzE,IAAI,SAAS,EAAE;AACf,UAAS,OAAO,OAAO,KAAK;AAC5B,UAAS,OAAO,OAAO,MAAM;AAC7B,MAAK,IAAI,IAAI,GAAG,MAAM,OAAO,QAAQ,IAAI,KAAK,IAC1C,qBAAoB,OAAO,IAAI,UAAU,cAAc,OAAO;AAElE,UAAS,OAAO,OAAO;AACvB,QAAO,KAAK,UAAU;AACtB,QAAO,SAAS;AAChB,QAAO,sBAAsB,OAAO,IAAI,iBAAiB,CAAC;;;;;;;;;;;;AAY9D,SAAS,oBAAoB,UAAU;CACnC,IAAI,SAAS,EAAE;AACf,MAAK,MAAM,WAAW,UAAU;AAC5B,OAAK,MAAM,QAAQ,QAAQ,KACvB,QAAO,KAAK,KAAK;AAErB,OAAK,MAAM,SAAS,QAAQ,MACxB,QAAO,KAAK,MAAM;;AAG1B,UAAS,OAAO,OAAO;AACvB,QAAO,sBAAsB,OAAO;;;;;;;;;;;;;;;AAexC,SAAS,4BAA4B,UAAU;CAC3C,IAAI,SAAS,EAAE;AACf,MAAK,MAAM,WAAW,UAAU;AAC5B,OAAK,MAAM,QAAQ,QAAQ,KACvB,QAAO,KAAK,KAAK;AAErB,OAAK,MAAM,SAAS,QAAQ,MACxB,QAAO,KAAK,MAAM;;AAG1B,UAAS,OAAO,OAAO;AACvB,QAAO,sBAAsB,OAAO,IAAI,iBAAiB,CAAC;;AAE9D,SAAS,wBAAwB,KAAK;CAElC,MAAM,uBAAwB,WAAW,KAAK,IAAI;AAClD,OAAMC,uBAA+B,IAAI;AACzC,QAAQ,uBAAuB,MAAM,IAAI,OAAO;;AAEpD,SAAS,sBAAsB,QAAQ;CACnC,MAAM,WAAW,IAAI,OAAO,IAAI,wBAAwB,CAAC,KAAK,MAAM,CAAC;AACrE,QAAOC,aAAqB,UAAU,KAAK;;AAE/C,MAAM,oBAAoB,WAAY;CAClC,SAAS,QAAQ,KAAK;AAClB,MAAIC,gBAA8B;GAE9B,MAAM,MAAM,IAAI,YAAY,IAAI,OAAO;GACvC,IAAI,SAAS;AACb,QAAK,IAAI,IAAI,IAAI,SAAS,GAAG,KAAK,GAAG,IACjC,KAAI,YAAY,IAAI,WAAW,EAAE;AAErC,UAAOC,wBAAsC,CAAC,OAAO,IAAI;SAExD;GACD,MAAM,SAAS,EAAE;GACjB,IAAI,YAAY;AAChB,QAAK,IAAI,IAAI,IAAI,SAAS,GAAG,KAAK,GAAG,IACjC,QAAO,eAAe,IAAI,OAAO,EAAE;AAEvC,UAAO,OAAO,KAAK,GAAG;;;CAG9B,IAAI,YAAY;CAChB,IAAI,aAAa;AACjB,QAAO,SAASC,mBAAiB,KAAK;AAClC,MAAI,cAAc,KAAK;AACnB,eAAY;AACZ,gBAAa,QAAQ,UAAU;;AAEnC,SAAO;;IAEX;AACJ,IAAa,gBAAb,MAA2B;CACvB,OAAO,uBAAuB,sBAAsB,YAAY,cAAc,QAAQ;EAClF,MAAM,IAAI,aAAa,MAAM,qBAAqB;AAClD,MAAI,CAAC,EACD,QAAO;EAEX,MAAM,cAAc,aAAa,UAAU,EAAE,SAAS;EACtD,MAAM,cAAc,EAAE,GAAG;EACzB,MAAM,sBAAsB,SAAS;AACrC,SAAO,IAAIC,QAAM,YAAY,sBAAsB,cAAc,GAAG,YAAY,sBAAsB,EAAE;;CAE5G,OAAO,uBAAuB,sBAAsB,YAAY,UAAU,aAAa,WAAW;EAG9F,MAAM,iBADmB,iBAAiB,SAAS,CACX,UAAU,SAAS,SAAS,WAAW,SAAS,SAAS,YAAY;AAC7G,SAAO,KAAK,uBAAuB,sBAAsB,YAAY,gBAAgB,YAAY;;CAErG,OAAO,sBAAsB,cAAc,YAAY,MAAM,QAAQ;EACjE,MAAM,IAAI,KAAK,MAAM,aAAa;AAClC,MAAI,CAAC,EACD,QAAO;EAEX,MAAM,cAAc,EAAE,SAAS;EAC/B,MAAM,cAAc,EAAE,GAAG;AACzB,MAAI,gBAAgB,EAChB,QAAO;EAEX,MAAM,sBAAsB,SAAS;AACrC,SAAO,IAAIA,QAAM,YAAY,sBAAsB,GAAG,YAAY,sBAAsB,IAAI,YAAY;;CAE5G,OAAO,uBAAuB,cAAc,YAAY,UAAU,aAAa,WAAW;EACtF,MAAM,SAAS,SAAS,UAAU,aAAa,UAAU;AACzD,SAAO,KAAK,sBAAsB,cAAc,YAAY,QAAQ,YAAY;;;;;;ACjWxF,IAAa,kCAAb,MAA6C;CACzC,YAAY,kBAAkB;AAC1B,OAAK,oBAAoB;;CAE7B,wBAAwB;EACpB,MAAM,SAAS,EAAE;AACjB,MAAI,KAAK,kBACL,MAAK,MAAM,WAAW,KAAK,kBAAkB,SACzC,MAAK,MAAM,SAAS,QAAQ,OAAO;GAC/B,MAAM,WAAW,MAAM,OAAO,MAAM,SAAS,EAAE;AAC/C,UAAO,KAAK,SAAS;;AAIjC,SAAO,SAAS,OAAO;;CAE3B,oBAAoB,WAAW,SAAS,QAAQ;AAC5C,MAAI,CAAC,KAAK,qBAAqB,KAAK,kBAAkB,SAAS,WAAW,EACtE,QAAO;EAEX,MAAM,aAAa,QAAQ,uBAAuB,SAAS,EAAE;AAC7D,MAAI,sBAAsB,QAAQ,qBAAqB,WAAW,CAAC,CAC/D,QAAO;EAEX,MAAM,uBAAuB,KAAK,kBAAkB;EACpD,MAAM,OAAO,QAAQ,gBAAgB,CAAC,UAAU,GAAG,SAAS,EAAE,GAAG;EACjE,MAAM,IAAI,cAAc,uBAAuB,sBAAsB,GAAG,MAAM,GAAG,KAAK,OAAO;AAC7F,MAAI,CAAC,EACD,QAAO;EAEX,MAAM,cAAc,KAAK,UAAU,EAAE,cAAc,GAAG,EAAE,YAAY,EAAE,CAAC,aAAa;AAEpF,MADe,KAAK,kBAAkB,kBAAkB,aAEpD,QAAO;EAEX,MAAM,oBAAoB,QAAQ,2BAA2B,EAAE,cAAc,EAAE;AAC/E,MAAI,CAAC,QAAQ,KAAK,kBAAkB,CAEhC,QAAO;AAEX,SAAO,EACH,kBAAkB,aACrB;;;;;;AC7CT,SAAS,iBAAiB,KAAK;AAC3B,KAAI,IAAI,OACJ,KAAI,YAAY;AAEpB,QAAO;;AAEX,IAAa,qBAAb,MAAgC;CAC5B,YAAY,kBAAkB;AAC1B,OAAK,oBAAoB;;CAE7B,eAAe,MAAM;AACjB,MAAI,KAAK,mBACL;OAAI,KAAK,kBAAkB,yBAAyB,iBAAiB,KAAK,kBAAkB,sBAAsB,IAAI,KAAK,kBAAkB,sBAAsB,KAAK,KAAK,CACzK,QAAO;;AAMf,SAAO;;CAEX,eAAe,MAAM;AACjB,MAAI,KAAK,qBAAqB,KAAK,kBAAkB,yBAAyB,iBAAiB,KAAK,kBAAkB,sBAAsB,IAAI,KAAK,kBAAkB,sBAAsB,KAAK,KAAK,CACnM,QAAO;AAEX,SAAO;;CAEX,qBAAqB,MAAM;AACvB,MAAI,KAAK,qBAAqB,KAAK,kBAAkB,yBAAyB,iBAAiB,KAAK,kBAAkB,sBAAsB,IAAI,KAAK,kBAAkB,sBAAsB,KAAK,KAAK,CACnM,QAAO;AAEX,SAAO;;CAEX,aAAa,MAAM;AAEf,MAAI,KAAK,qBAAqB,KAAK,kBAAkB,yBAAyB,iBAAiB,KAAK,kBAAkB,sBAAsB,IAAI,KAAK,kBAAkB,sBAAsB,KAAK,KAAK,CACnM,QAAO;AAEX,SAAO;;CAEX,kBAAkB,MAAM;EACpB,IAAI,MAAM;AACV,MAAI,KAAK,eAAe,KAAK,CACzB,QAAO;AAEX,MAAI,KAAK,eAAe,KAAK,CACzB,QAAO;AAEX,MAAI,KAAK,qBAAqB,KAAK,CAC/B,QAAO;AAEX,MAAI,KAAK,aAAa,KAAK,CACvB,QAAO;AAEX,SAAO;;;;;;ACnDf,IAAa,iBAAb,MAAa,eAAe;CACxB,YAAY,MAAM;AACd,SAAO,QAAQ,EAAE;AACjB,OAAK,WAAW,KAAK,YAAY;GAC7B,CAAC,KAAK,IAAI;GACV,CAAC,KAAK,IAAI;GACV,CAAC,KAAK,IAAI;GACb;AACD,OAAK,YAAY,EAAE;AACnB,OAAK,SAAS,SAAS,YAAY;GAC/B,MAAM,aAAa,eAAe,yBAAyB,QAAQ,GAAG;GACtE,MAAM,cAAc,eAAe,0BAA0B,QAAQ,GAAG;AACxE,OAAI,cAAc,YACd,MAAK,UAAU,KAAK;IAChB,MAAM,QAAQ;IACF;IACZ,OAAO,QAAQ;IACF;IAChB,CAAC;IAER;AACF,OAAK,eAAe,KAAK,gBAAgB,EAAE;;CAE/C,QAAQ,YAAY,kBAAkB,iBAAiB,gBAAgB;AAEnE,MAAI,cAAc,EACd,MAAK,IAAI,IAAI,GAAG,MAAM,KAAK,aAAa,QAAQ,IAAI,KAAK,KAAK;GAC1D,MAAM,OAAO,KAAK,aAAa;AAiB/B,OAhBkB;IAAC;KACX,KAAK,KAAK;KACV,MAAM;KACT;IAAE;KACC,KAAK,KAAK;KACV,MAAM;KACT;IAAE;KACC,KAAK,KAAK;KACV,MAAM;KACT;IAAC,CAAC,OAAO,QAAQ;AAClB,QAAI,CAAC,IAAI,IACL,QAAO;AAEX,QAAI,IAAI,YAAY;AACpB,WAAO,IAAI,IAAI,KAAK,IAAI,KAAK;KAC/B,CAEE,QAAO,KAAK;;AAKxB,MAAI,cAAc,GACd;OAAI,gBAAgB,SAAS,KAAK,eAAe,SAAS,EACtD,MAAK,IAAI,IAAI,GAAG,MAAM,KAAK,UAAU,QAAQ,IAAI,KAAK,KAAK;IACvD,MAAM,UAAU,KAAK,UAAU;AAC/B,QAAI,QAAQ,WAAW,KAAK,gBAAgB,IAAI,QAAQ,YAAY,KAAK,eAAe,CACpF,QAAO,EAAE,cAAc,aAAa,eAAe;;;AAMnE,MAAI,cAAc,GACd;OAAI,gBAAgB,SAAS,GACzB;SAAK,IAAI,IAAI,GAAG,MAAM,KAAK,UAAU,QAAQ,IAAI,KAAK,IAElD,KADgB,KAAK,UAAU,GACnB,WAAW,KAAK,gBAAgB,CACxC,QAAO,EAAE,cAAc,aAAa,QAAQ;;;AAK5D,SAAO;;CAEX,OAAO,yBAAyB,SAAS;EACrC,IAAI,MAAMC,uBAA+B,QAAQ;AACjD,MAAI,CAAC,KAAK,KAAK,IAAI,OAAO,EAAE,CAAC,CACzB,OAAM,QAAQ;AAElB,SAAO;AACP,SAAO,eAAe,YAAY,IAAI;;CAE1C,OAAO,0BAA0B,SAAS;EACtC,IAAI,MAAMA,uBAA+B,QAAQ;AACjD,MAAI,CAAC,KAAK,KAAK,IAAI,OAAO,IAAI,SAAS,EAAE,CAAC,CACtC,OAAM,MAAM;AAEhB,QAAM,UAAU;AAChB,SAAO,eAAe,YAAY,IAAI;;CAE1C,OAAO,YAAY,KAAK;AACpB,MAAI;AACA,UAAO,IAAI,OAAO,IAAI;WAEnB,KAAK;AACR,qBAAkB,IAAI;AACtB,UAAO;;;;;;;ACjGnB,IAAW;CACV,SAAU,SAAO;AACd,SAAM,6BAAa,IAAI,KAAK;AAC5B,SAAM,YAAY;AAClB,SAAM,kBAAkB;CACxB,SAAS,uBAAuB,MAAM;AAClC,SAAO,KAAKC,QAAM,oBAAoB,EAAE;;AAE5C,SAAM,yBAAyB;GAChC,UAAU,QAAQ,EAAE,EAAE;AACzB,MAAa,wBAAwB,gBAAgB,uBAAuB;AAC5E,SAAS,uBAAuB,IAAI,QAAQ,OAAO;AAC/C,KAAI,OAAO,MAAM,eAAe,OAC5B,QAAO,MAAM,iBAAiB,KAAK;EAAE;EAAI;EAAO,CAAC;MAEhD;AACD,SAAO,MAAM,mBAAmB,CAAC;GAAE;GAAI;GAAO,CAAC;AAC/C,SAAO,MAAM,aAAa;;;;;;AAMlC,SAAgB,gBAAgB,WAAW;AACvC,KAAI,MAAM,WAAW,IAAI,UAAU,CAC/B,QAAO,MAAM,WAAW,IAAI,UAAU;CAE1C,MAAM,KAAK,SAAU,QAAQ,KAAK,OAAO;AACrC,MAAI,UAAU,WAAW,EACrB,OAAM,IAAI,MAAM,mEAAmE;AAEvF,yBAAuB,IAAI,QAAQ,MAAM;;AAE7C,IAAG,iBAAiB;AACpB,OAAM,WAAW,IAAI,WAAW,GAAG;AACnC,QAAO;;;;;ACnCX,MAAa,wBAAwB,gBAAgB,uBAAuB;;;;ACA5E,MAAa,mBAAmB,gBAAgB,kBAAkB;;;;ACDlE,IAAa,iBAAb,MAA4B;CACxB,YAAY,MAAM,kBAAkB,EAAE,EAAE,+BAA+B,OAAO;AAC1E,OAAK,OAAO;AACZ,OAAK,kBAAkB;AACvB,OAAK,+BAA+B;;;;;;ACH5C,MAAM,YAAY,EAAE;AACpB,SAAgB,kBAAkB,IAAI,kBAAkB,8BAA8B;AAClF,KAAI,EAAE,4BAA4B,gBAC9B,oBAAmB,IAAI,eAAe,kBAAkB,EAAE,EAAE,6BAA6B;AAE7F,WAAU,KAAK,CAAC,IAAI,iBAAiB,CAAC;;;;;ACN1C,IAAI,gCAA2B,cAAe,SAAU,YAAY,QAAQ,KAAK,MAAM;CACnF,IAAI,IAAI,UAAU,QAAQ,IAAI,IAAI,IAAI,SAAS,SAAS,OAAO,OAAO,OAAO,yBAAyB,QAAQ,IAAI,GAAG,MAAM;AAC3H,KAAI,OAAO,YAAY,YAAY,OAAO,QAAQ,aAAa,WAAY,KAAI,QAAQ,SAAS,YAAY,QAAQ,KAAK,KAAK;KACzH,MAAK,IAAI,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,IAAK,KAAI,IAAI,WAAW,GAAI,MAAK,IAAI,IAAI,EAAE,EAAE,GAAG,IAAI,IAAI,EAAE,QAAQ,KAAK,EAAE,GAAG,EAAE,QAAQ,IAAI,KAAK;AAChJ,QAAO,IAAI,KAAK,KAAK,OAAO,eAAe,QAAQ,KAAK,EAAE,EAAE;;AAEhE,IAAI,6BAAwB,WAAY,SAAU,YAAY,WAAW;AACrE,QAAO,SAAU,QAAQ,KAAK;AAAE,YAAU,QAAQ,KAAK,WAAW;;;AAiBtE,IAAa,0CAAb,MAAqD;CACjD,YAAY,YAAY;AACpB,OAAK,aAAa;;CAEtB,QAAQ,YAAY;AAChB,SAAO,CAAC,KAAK,aAAa,OAAO,KAAK,eAAe;;;AAG7D,MAAa,gCAAgC,gBAAgB,+BAA+B;AAC5F,IAAI,+BAA+B,MAAMC,uCAAqC,WAAW;CACrF,YAAY,sBAAsB,iBAAiB;AAC/C,SAAO;AACP,OAAK,uBAAuB;AAC5B,OAAK,kBAAkB;AACvB,OAAK,qBAAqB,KAAK,UAAU,IAAI,SAAS,CAAC;AACvD,OAAK,cAAc,KAAK,mBAAmB;AAC3C,OAAK,iCAAiB,IAAI,KAAK;EAC/B,MAAM,qBAAqB,IAAI,IAAI,OAAO,OAAO,6BAA6B,CAAC;AAC/E,OAAK,UAAU,KAAK,qBAAqB,0BAA0B,MAAM;GACrE,MAAM,sBAAsB,EAAE,OAAO,KAAK,MAAM,MAAM,mBAAmB,IAAI,EAAE,CAAC;GAChF,MAAM,qBAAqB,EAAE,OAAO,UAC/B,QAAQ,CAAC,kBAAkB,UAAU,KAAK,MAAM,MAAM,mBAAmB,IAAI,EAAE,CAAC,CAAC,CACjF,KAAK,CAAC,sBAAsB,iBAAiB;AAClD,OAAI,qBAAqB;AACrB,SAAK,eAAe,OAAO;AAC3B,SAAK,mBAAmB,KAAK,IAAI,wCAAwC,OAAU,CAAC;SAGpF,MAAK,MAAM,cAAc,mBACrB,KAAI,KAAK,gBAAgB,uBAAuB,WAAW,EAAE;AACzD,SAAK,eAAe,OAAO,WAAW;AACtC,SAAK,mBAAmB,KAAK,IAAI,wCAAwC,WAAW,CAAC;;IAInG,CAAC;AACH,OAAK,UAAU,8BAA8B,aAAa,MAAM;AAC5D,QAAK,eAAe,OAAO,EAAE,WAAW;AACxC,QAAK,mBAAmB,KAAK,IAAI,wCAAwC,EAAE,WAAW,CAAC;IACzF,CAAC;;CAEP,yBAAyB,YAAY;EACjC,IAAI,SAAS,KAAK,eAAe,IAAI,WAAW;AAChD,MAAI,CAAC,QAAQ;AACT,YAAS,cAAc,YAAY,KAAK,sBAAsB,KAAK,gBAAgB;AACnF,QAAK,eAAe,IAAI,YAAY,OAAO;;AAE/C,SAAO;;;AAGf,+BAA+B,WAAW,CACtC,QAAQ,GAAG,sBAAsB,EACjC,QAAQ,GAAG,iBAAiB,CAC/B,EAAE,6BAA6B;AAEhC,SAAS,cAAc,YAAY,sBAAsB,iBAAiB;CACtE,IAAI,iBAAiB,8BAA8B,yBAAyB,WAAW;AACvF,KAAI,CAAC,gBAAgB;AACjB,MAAI,CAAC,gBAAgB,uBAAuB,WAAW,CACnD,OAAM,IAAI,MAAM,gBAAgB,WAAW,+BAA+B;AAE9E,mBAAiB,IAAI,8BAA8B,YAAY,EAAE,CAAC;;CAEtE,MAAM,mBAAmB,4BAA4B,eAAe,YAAY,qBAAqB;CACrG,MAAM,OAAO,8BAA8B,CAAC,eAAe,kBAAkB,iBAAiB,CAAC;AAE/F,QADe,IAAI,8BAA8B,eAAe,YAAY,KAAK;;AAGrF,MAAM,+BAA+B;CACjC,UAAU;CACV,uBAAuB;CAC1B;AACD,SAAS,4BAA4B,YAAY,sBAAsB;CACnE,MAAM,WAAW,qBAAqB,SAAS,6BAA6B,UAAU,EAClF,oBAAoB,YACvB,CAAC;CACF,MAAM,wBAAwB,qBAAqB,SAAS,6BAA6B,uBAAuB,EAC5G,oBAAoB,YACvB,CAAC;AACF,QAAO;EACH,UAAU,qBAAqB,SAAS;EACxC,uBAAuB,qBAAqB,sBAAsB;EACrE;;AAEL,SAAS,qBAAqB,MAAM;AAChC,KAAI,CAAC,MAAM,QAAQ,KAAK,CACpB;AAEJ,QAAO,KAAK,KAAI,SAAQ;AACpB,MAAI,CAAC,MAAM,QAAQ,KAAK,IAAI,KAAK,WAAW,EACxC;AAEJ,SAAO,CAAC,KAAK,IAAI,KAAK,GAAG;GAC3B,CAAC,QAAQ,MAAM,CAAC,CAAC,EAAE;;AAEzB,IAAa,mCAAb,MAA8C;CAC1C,YAAY,YAAY;AACpB,OAAK,aAAa;;;AAG1B,IAAa,oCAAb,MAA+C;CAC3C,cAAc;AACV,OAAK,2BAAW,IAAI,KAAK;AACzB,OAAK,eAAe,IAAI,SAAS;AACjC,OAAK,cAAc,KAAK,aAAa;;;;;CAKzC,SAAS,YAAY,eAAe,WAAW,GAAG;EAC9C,IAAI,UAAU,KAAK,SAAS,IAAI,WAAW;AAC3C,MAAI,CAAC,SAAS;AACV,aAAU,IAAI,8BAA8B,WAAW;AACvD,QAAK,SAAS,IAAI,YAAY,QAAQ;;EAE1C,MAAM,aAAa,QAAQ,SAAS,eAAe,SAAS;AAC5D,OAAK,aAAa,KAAK,IAAI,iCAAiC,WAAW,CAAC;AACxE,SAAO,mBAAmB;AACtB,cAAW,SAAS;AACpB,QAAK,aAAa,KAAK,IAAI,iCAAiC,WAAW,CAAC;IAC1E;;CAEN,yBAAyB,YAAY;EACjC,MAAM,UAAU,KAAK,SAAS,IAAI,WAAW;AAC7C,UAAQ,YAAY,QAAQ,YAAY,KAAK,IAAI,KAAK,IAAI,QAAQ,0BAA0B,KAAK;;CAErG,YAAY,YAAY;EACpB,MAAM,QAAQ,KAAK,yBAAyB,WAAW;AACvD,MAAI,CAAC,MACD,QAAO;AAEX,SAAO,MAAM,YAAY;;CAG7B,sBAAsB,YAAY;EAC9B,MAAM,QAAQ,KAAK,yBAAyB,WAAW;AACvD,MAAI,CAAC,MACD,QAAO;AAEX,SAAO,MAAM,sBAAsB;;;;;;;;;CASvC,sBAAsB,OAAO,YAAY,oBAAoB;EACzD,MAAM,aAAa,MAAM,wBAAwB,YAAY,EAAE;AAC/D,MAAI,aAAa,GAAG;GAChB,IAAI;GACJ,IAAI,mBAAmB;AACvB,QAAK,iBAAiB,aAAa,GAAG,kBAAkB,GAAG,kBAAkB;AACzE,QAAI,MAAM,wBAAwB,gBAAgB,EAAE,KAAK,WACrD,QAAO;IAEX,MAAM,OAAO,MAAM,eAAe,eAAe;AACjD,QAAI,mBAAmB,aAAa,KAAK,IAAI,QAAQ,KAAK,KAAK,IAAI,SAAS,IAAI;AAC5E,wBAAmB;AACnB;;AAEJ,WAAO;;;AAGf,SAAO;;;;;;;;;;;;;;CAcX,wBAAwB,YAAY,OAAO,YAAY,uBAAuB,MAAM;AAChF,MAAI,aAAa,EACb,QAAO;EAEX,MAAM,qBAAqB,KAAK,sBAAsB,MAAM,eAAe,CAAC;AAC5E,MAAI,CAAC,mBACD,QAAO;AAEX,MAAI,cAAc,EACd,QAAO;GACH,aAAa;GACb,QAAQ;GACX;EAEL,MAAM,yBAAyB,KAAK,sBAAsB,OAAO,YAAY,mBAAmB;AAChG,MAAI,yBAAyB,EACzB,QAAO;WAEF,yBAAyB,EAC9B,QAAO;GACH,aAAa;GACb,QAAQ;GACX;EAEL,MAAM,gCAAgC,MAAM,eAAe,uBAAuB;AAClF,MAAI,mBAAmB,eAAe,8BAA8B,IAAI,mBAAmB,qBAAqB,8BAA8B,CAC1I,QAAO;GACH,aAAaC,qBAA6B,8BAA8B;GACxE,QAAQ,aAAa;GACrB,MAAM;GACT;WAEI,mBAAmB,eAAe,8BAA8B,CACrE,QAAO;GACH,aAAaA,qBAA6B,8BAA8B;GACxE,QAAQ;GACR,MAAM;GACT;OAEA;AAMD,OAAI,2BAA2B,EAC3B,QAAO;IACH,aAAaA,qBAA6B,MAAM,eAAe,uBAAuB,CAAC;IACvF,QAAQ;IACR,MAAM;IACT;GAEL,MAAM,eAAe,yBAAyB;GAC9C,MAAM,6BAA6B,mBAAmB,kBAAkB,MAAM,eAAe,aAAa,CAAC;AAC3G,OAAI,EAAE,6BAA8B,MAC/B,6BAA6B,GAA+B;IAC7D,IAAI,WAAW;AACf,SAAK,IAAI,IAAI,eAAe,GAAG,IAAI,GAAG,KAAK;AACvC,SAAI,mBAAmB,qBAAqB,MAAM,eAAe,EAAE,CAAC,CAChE;AAEJ,gBAAW;AACX;;AAEJ,WAAO;KACH,aAAaA,qBAA6B,MAAM,eAAe,WAAW,EAAE,CAAC;KAC7E,QAAQ;KACR,MAAM,WAAW;KACpB;;AAEL,OAAI,qBACA,QAAO;IACH,aAAaA,qBAA6B,MAAM,eAAe,uBAAuB,CAAC;IACvF,QAAQ;IACR,MAAM;IACT;QAEA;AAED,SAAK,IAAI,IAAI,wBAAwB,IAAI,GAAG,KAAK;KAC7C,MAAM,cAAc,MAAM,eAAe,EAAE;AAC3C,SAAI,mBAAmB,eAAe,YAAY,CAC9C,QAAO;MACH,aAAaA,qBAA6B,YAAY;MACtD,QAAQ,aAAa;MACrB,MAAM;MACT;cAEI,mBAAmB,qBAAqB,YAAY,EAAE;MAC3D,IAAI,WAAW;AACf,WAAK,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,KAAK;AAC5B,WAAI,mBAAmB,qBAAqB,MAAM,eAAe,EAAE,CAAC,CAChE;AAEJ,kBAAW;AACX;;AAEJ,aAAO;OACH,aAAaA,qBAA6B,MAAM,eAAe,WAAW,EAAE,CAAC;OAC7E,QAAQ;OACR,MAAM,WAAW;OACpB;gBAEI,mBAAmB,eAAe,YAAY,CACnD,QAAO;MACH,aAAaA,qBAA6B,YAAY;MACtD,QAAQ;MACR,MAAM;MACT;;AAGT,WAAO;KACH,aAAaA,qBAA6B,MAAM,eAAe,EAAE,CAAC;KAClE,QAAQ;KACR,MAAM;KACT;;;;CAIb,qBAAqB,YAAY,cAAc,YAAY,YAAY,iBAAiB;AACpF,MAAI,aAAa,EACb,QAAO;EAEX,MAAM,kBAAkB,KAAK,yBAAyB,WAAW;AACjE,MAAI,CAAC,gBACD,QAAO;EAEX,MAAM,qBAAqB,KAAK,sBAAsB,WAAW;AACjE,MAAI,CAAC,mBACD,QAAO;EAEX,MAAM,SAAS,KAAK,wBAAwB,YAAY,cAAc,WAAW;EACjF,MAAM,cAAc,aAAa,eAAe,WAAW;AAC3D,MAAI,QAAQ;GACR,MAAM,cAAc,OAAO;AAC3B,OAAI,gBAAgB,QAAW;IAC3B,MAAM,cAAc,gBAAgB,QAAQ,YAAY,IAAI,aAAa,eAAe,YAAY,EAAE,GAAG;AACzG,QAAI,aAAa;KACb,IAAI,cAAcA,qBAA6B,aAAa,eAAe,YAAY,CAAC;AACxF,SAAI,YAAY,WACZ,eAAc,YAAY,UAAU,GAAG,YAAY,SAAS,YAAY,WAAW;AAEvF,SAAK,YAAY,iBAAiB,aAAa,UAC1C,YAAY,iBAAiB,aAAa,cAC3C,eAAc,gBAAgB,YAAY,YAAY;cAEjD,YAAY,iBAAiB,aAAa,QAC/C,eAAc,gBAAgB,cAAc,YAAY;AAE5D,SAAI,mBAAmB,eAAe,YAAY,CAC9C,eAAc,gBAAgB,cAAc,YAAY;AAE5D,SAAI,YAAY,WACZ,gBAAe,YAAY;AAE/B,YAAOA,qBAA6B,YAAY;;;AAGxD,OAAI,mBAAmB,eAAe,YAAY,CAC9C,KAAI,OAAO,WAAW,aAAa,OAC/B,QAAO,OAAO;OAGd,QAAO,gBAAgB,cAAc,OAAO,YAAY;YAIxD,OAAO,WAAW,aAAa,OAC/B,QAAO,gBAAgB,YAAY,OAAO,YAAY;OAGtD,QAAO,OAAO;;AAI1B,SAAO;;CAEX,kBAAkB,YAAY,OAAO,OAAO,iBAAiB;AACzD,MAAI,aAAa,EACb,QAAO;AAEX,QAAM,kBAAkB,MAAM,gBAAgB;EAC9C,MAAM,aAAa,MAAM,cAAc,MAAM,gBAAgB;EAC7D,MAAM,mBAAmB,uBAAuB,YAAY,MAAM,cAAc,EAAE;EAClF,MAAM,iBAAiB,iBAAiB,gBAAgB;EACxD,IAAI,mBAAmB;EACvB,IAAI;AACJ,MAAI,iBAAiB,kBAAkB,KAAK,WAAW,cAAc,EAAE,KAAK,iBAAiB,YAAY;AAErG,sBAAmB;AACnB,qBAAkB,eAAe,OAAO,GAAG,MAAM,cAAc,IAAI,iBAAiB,gBAAgB;QAGpG,mBAAkB,WAAW,gBAAgB,CAAC,UAAU,GAAG,MAAM,cAAc,EAAE;EAErF,IAAI;AACJ,MAAI,MAAM,SAAS,CACf,kBAAiB,eAAe,OAAO,MAAM,cAAc,IAAI,iBAAiB,gBAAgB;MAIhG,kBAD4B,KAAK,oBAAoB,OAAO,MAAM,eAAe,MAAM,UAAU,CAC5D,gBAAgB,CAAC,OAAO,MAAM,YAAY,IAAI,iBAAiB,gBAAgB;EAExH,MAAM,qBAAqB,KAAK,sBAAsB,iBAAiB,WAAW;AAClF,MAAI,CAAC,mBACD,QAAO;EAEX,MAAM,oBAAoB;EAC1B,MAAM,oBAAoBA,qBAA6B,gBAAgB;EACvE,MAAM,eAAe;GACjB,gBAAgB,eAAe;AAC3B,WAAO,MAAM,cAAc,WAAW;;GAE1C,qBAAqB;AACjB,WAAO,MAAM,eAAe;;GAEhC,0BAA0B,YAAY,WAAW;AAC7C,WAAO,MAAM,wBAAwB,YAAY,OAAO;;GAE5D,iBAAiB,eAAe;AAC5B,QAAI,eAAe,MAAM,gBACrB,QAAO;QAGP,QAAO,MAAM,eAAe,WAAW;;GAGlD;EACD,MAAM,oBAAoBA,qBAA6B,WAAW,gBAAgB,CAAC;EACnF,MAAM,mBAAmB,KAAK,wBAAwB,YAAY,cAAc,MAAM,kBAAkB,EAAE;AAC1G,MAAI,CAAC,kBAAkB;GACnB,MAAM,cAAc,mBAAmB,oBAAoB;AAC3D,UAAO;IACU;IACb,YAAY;IACf;;EAEL,IAAI,mBAAmB,mBAAmB,oBAAoB,iBAAiB;AAC/E,MAAI,iBAAiB,WAAW,aAAa,OACzC,oBAAmB,gBAAgB,YAAY,iBAAiB;AAEpE,MAAI,mBAAmB,eAAe,eAAe,CACjD,oBAAmB,gBAAgB,cAAc,iBAAiB;AAEtE,SAAO;GACH,aAAa,mBAAmB,oBAAoB;GACpD,YAAY;GACf;;;;;;CAML,uBAAuB,YAAY,OAAO,OAAO,IAAI,iBAAiB;AAClE,MAAI,aAAa,EACb,QAAO;EAEX,MAAM,mBAAmB,KAAK,oBAAoB,OAAO,MAAM,iBAAiB,MAAM,YAAY;AAClG,MAAI,iBAAiB,gBAEjB,QAAO;EAEX,MAAM,qBAAqB,KAAK,sBAAsB,iBAAiB,WAAW;AAClF,MAAI,CAAC,mBACD,QAAO;EAEX,MAAM,iBAAiB,iBAAiB,gBAAgB;EACxD,MAAM,iBAAiB,eAAe,OAAO,GAAG,MAAM,cAAc,IAAI,iBAAiB,gBAAgB;EAEzG,IAAI;AACJ,MAAI,MAAM,SAAS,CACf,iBAAgB,eAAe,OAAO,MAAM,cAAc,IAAI,iBAAiB,gBAAgB;MAI/F,iBAD4B,KAAK,oBAAoB,OAAO,MAAM,eAAe,MAAM,UAAU,CAC7D,gBAAgB,CAAC,OAAO,MAAM,YAAY,IAAI,iBAAiB,gBAAgB;AAIvH,MAAI,CAAC,mBAAmB,eAAe,iBAAiB,cAAc,IAAI,mBAAmB,eAAe,iBAAiB,KAAK,cAAc,EAAE;GAG9I,MAAM,IAAI,KAAK,wBAAwB,YAAY,OAAO,MAAM,iBAAiB,MAAM;AACvF,OAAI,CAAC,EACD,QAAO;GAEX,IAAI,cAAc,EAAE;AACpB,OAAI,EAAE,WAAW,aAAa,OAC1B,eAAc,gBAAgB,cAAc,YAAY;AAE5D,UAAO;;AAEX,SAAO;;CAEX,kBAAkB,OAAO,YAAY;EACjC,MAAM,qBAAqB,KAAK,sBAAsB,MAAM,eAAe,CAAC;AAC5E,MAAI,CAAC,mBACD,QAAO;AAEX,MAAI,aAAa,KAAK,aAAa,MAAM,cAAc,CACnD,QAAO;AAEX,SAAO,mBAAmB,kBAAkB,MAAM,eAAe,WAAW,CAAC;;CAIjF,eAAe,YAAY,OAAO,OAAO;EACrC,MAAM,mBAAmB,KAAK,oBAAoB,OAAO,MAAM,iBAAiB,MAAM,YAAY;EAClG,MAAM,kBAAkB,KAAK,yBAAyB,iBAAiB,WAAW;AAClF,MAAI,CAAC,gBACD,QAAO;EAEX,MAAM,iBAAiB,iBAAiB,gBAAgB;EACxD,MAAM,kBAAkB,eAAe,OAAO,GAAG,MAAM,cAAc,IAAI,iBAAiB,gBAAgB;EAE1G,IAAI;AACJ,MAAI,MAAM,SAAS,CACf,kBAAiB,eAAe,OAAO,MAAM,cAAc,IAAI,iBAAiB,gBAAgB;MAIhG,kBAD4B,KAAK,oBAAoB,OAAO,MAAM,eAAe,MAAM,UAAU,CAC5D,gBAAgB,CAAC,OAAO,MAAM,YAAY,IAAI,iBAAiB,gBAAgB;EAExH,IAAI,mBAAmB;AACvB,MAAI,MAAM,kBAAkB,KAAK,iBAAiB,oBAAoB,GAAG;GAErE,MAAM,+BAA+B,KAAK,oBAAoB,OAAO,MAAM,kBAAkB,EAAE;AAC/F,OAAI,6BAA6B,eAAe,iBAAiB,WAE7D,oBAAmB,6BAA6B,gBAAgB;;EAGxE,MAAM,cAAc,gBAAgB,QAAQ,YAAY,kBAAkB,iBAAiB,eAAe;AAC1G,MAAI,CAAC,YACD,QAAO;EAEX,MAAM,eAAe,YAAY;EACjC,IAAI,aAAa,YAAY;EAC7B,MAAM,aAAa,YAAY,cAAc;AAE7C,MAAI,CAAC,WACD,KAAK,iBAAiB,aAAa,UAC9B,iBAAiB,aAAa,cAC/B,cAAa;MAGb,cAAa;WAGZ,iBAAiB,aAAa,OACnC,cAAa,MAAO;EAExB,IAAI,cAAc,KAAK,yBAAyB,OAAO,MAAM,iBAAiB,MAAM,YAAY;AAChG,MAAI,WACA,eAAc,YAAY,UAAU,GAAG,YAAY,SAAS,WAAW;AAE3E,SAAO;GACW;GACF;GACA;GACC;GAChB;;CAEL,yBAAyB,OAAO,YAAY,QAAQ;EAChD,MAAM,WAAW,MAAM,eAAe,WAAW;EACjD,IAAI,cAAcA,qBAA6B,SAAS;AACxD,MAAI,YAAY,SAAS,SAAS,EAC9B,eAAc,YAAY,UAAU,GAAG,SAAS,EAAE;AAEtD,SAAO;;CAEX,oBAAoB,OAAO,YAAY,cAAc;AACjD,QAAM,kBAAkB,WAAW;AAGnC,SAAO,uBAFY,MAAM,cAAc,WAAW,EAClC,OAAO,iBAAiB,cAAc,MAAM,iBAAiB,WAAW,GAAG,IAAI,eAAe,EAC7D;;;;;;AAMzD,MAAa,gCAAgC,IAAI,mCAAmC;AACpF,IAAM,gCAAN,MAAoC;CAChC,YAAY,YAAY;AACpB,OAAK,aAAa;AAClB,OAAK,YAAY;AACjB,OAAK,WAAW,EAAE;AAClB,OAAK,SAAS;AACd,OAAK,YAAY;;CAErB,SAAS,eAAe,UAAU;EAC9B,MAAM,QAAQ,IAAI,kCAAkC,eAAe,UAAU,EAAE,KAAK,OAAO;AAC3F,OAAK,SAAS,KAAK,MAAM;AACzB,OAAK,YAAY;AACjB,SAAO,mBAAmB;AACtB,QAAK,IAAI,IAAI,GAAG,IAAI,KAAK,SAAS,QAAQ,IACtC,KAAI,KAAK,SAAS,OAAO,OAAO;AAC5B,SAAK,SAAS,OAAO,GAAG,EAAE;AAC1B,SAAK,YAAY;AACjB;;IAGV;;CAEN,2BAA2B;AACvB,MAAI,CAAC,KAAK,WAAW;GACjB,MAAM,SAAS,KAAK,UAAU;AAC9B,OAAI,OACA,MAAK,YAAY,IAAI,8BAA8B,KAAK,YAAY,OAAO;;AAGnF,SAAO,KAAK;;CAEhB,WAAW;AACP,MAAI,KAAK,SAAS,WAAW,EACzB,QAAO;AAEX,OAAK,SAAS,KAAK,kCAAkC,IAAI;AACzD,SAAO,8BAA8B,KAAK,SAAS,KAAI,MAAK,EAAE,cAAc,CAAC;;;AAGrF,SAAS,8BAA8B,SAAS;CAC5C,IAAI,SAAS;EACT,UAAU;EACV,UAAU;EACV,aAAa;EACb,kBAAkB;EAClB,cAAc;EACd,kBAAkB;EAClB,kBAAkB;EAClB,iBAAiB;EACjB,SAAS;EACT,uBAAuB;EACvB,4BAA4B;EAC/B;AACD,MAAK,MAAM,SAAS,QAChB,UAAS;EACL,UAAU,MAAM,YAAY,OAAO;EACnC,UAAU,MAAM,YAAY,OAAO;EACnC,aAAa,MAAM,eAAe,OAAO;EACzC,kBAAkB,MAAM,oBAAoB,OAAO;EACnD,cAAc,MAAM,gBAAgB,OAAO;EAC3C,kBAAkB,MAAM,oBAAoB,OAAO;EACnD,kBAAkB,MAAM,oBAAoB,OAAO;EACnD,iBAAiB,MAAM,mBAAmB,OAAO;EACjD,SAAS,MAAM,WAAW,OAAO;EACjC,uBAAuB,MAAM,yBAAyB,OAAO;EAC7D,4BAA4B,MAAM,8BAA8B,OAAO;EAC1E;AAEL,QAAO;;AAEX,IAAM,oCAAN,MAAwC;CACpC,YAAY,eAAe,UAAU,OAAO;AACxC,OAAK,gBAAgB;AACrB,OAAK,WAAW;AAChB,OAAK,QAAQ;;CAEjB,OAAO,IAAI,GAAG,GAAG;AACb,MAAI,EAAE,aAAa,EAAE,SAEjB,QAAO,EAAE,QAAQ,EAAE;AAGvB,SAAO,EAAE,WAAW,EAAE;;;;;;AAM9B,IAAa,gCAAb,MAAa,8BAA8B;CACvC,YAAY,YAAY,kBAAkB;AACtC,OAAK,aAAa;AAClB,OAAK,mBAAmB;AACxB,OAAK,YAAY;AACjB,OAAK,qBAAqB;AAC1B,OAAK,kBACD,KAAK,iBAAiB,YAClB,KAAK,iBAAiB,oBACtB,KAAK,iBAAiB,eACpB,IAAI,eAAe,KAAK,iBAAiB,GACzC;AACV,OAAK,WAAW,8BAA8B,gBAAgB,KAAK,iBAAiB;AACpF,OAAK,gBAAgB,IAAI,qBAAqB,KAAK,iBAAiB;AACpE,OAAK,iBAAiB,KAAK,iBAAiB,eAAe;AAC3D,OAAK,mBAAmB,KAAK,iBAAiB;AAC9C,MAAI,KAAK,iBAAiB,iBACtB,MAAK,qBAAqB,IAAI,mBAAmB,KAAK,iBAAiB,iBAAiB;MAGxF,MAAK,qBAAqB;AAE9B,OAAK,eAAe,KAAK,iBAAiB,WAAW,EAAE;;CAE3D,oBAAoB;AAChB,SAAO,0BAA0B,KAAK,eAAe;;CAEzD,IAAI,WAAW;AACX,MAAI,CAAC,KAAK,aAAa,KAAK,iBAAiB,SACzC,MAAK,YAAY,IAAI,iBAAiB,KAAK,YAAY,KAAK,iBAAiB,SAAS;AAE1F,SAAO,KAAK;;CAEhB,IAAI,oBAAoB;AACpB,MAAI,CAAC,KAAK,mBACN,MAAK,qBAAqB,IAAI,gCAAgC,KAAK,SAAS;AAEhF,SAAO,KAAK;;CAEhB,QAAQ,YAAY,kBAAkB,iBAAiB,gBAAgB;AACnE,MAAI,CAAC,KAAK,gBACN,QAAO;AAEX,SAAO,KAAK,gBAAgB,QAAQ,YAAY,kBAAkB,iBAAiB,eAAe;;CAEtG,sBAAsB;AAClB,SAAO,IAAI,iBAAiB,KAAK,cAAc,qBAAqB,CAAC;;CAEzE,wBAAwB;AACpB,SAAO,KAAK,cAAc,uBAAuB;;CAErD,sBAAsB;AAClB,SAAO,KAAK,cAAc,qBAAqB;;CAEnD,OAAO,gBAAgB,MAAM;EACzB,MAAM,cAAc,KAAK;AACzB,MAAI,CAAC,YACD,QAAO;EAGX,MAAM,WAAW,EAAE;AACnB,MAAI,YAAY,YACZ,UAAS,mBAAmB,YAAY;AAE5C,MAAI,YAAY,cAAc;GAC1B,MAAM,CAAC,YAAY,YAAY,YAAY;AAC3C,YAAS,yBAAyB;AAClC,YAAS,uBAAuB;;AAEpC,SAAO;;;AAGf,kBAAkB,+BAA+B,6BAA6B;;;;ACpuB9E,MAAM,cAAc,OAAO,OAAO,KAAK;AACvC,SAAgB,mBAAmB,KAAK,OAAO;AAC3C,KAAI,SAAS,EACT,QAAO;AAEX,KAAI,CAAC,YAAY,KACb,aAAY,OAAO,CAAC,IAAI,IAAI;CAEhC,MAAM,QAAQ,YAAY;AAC1B,MAAK,IAAI,IAAI,MAAM,QAAQ,KAAK,OAAO,IACnC,OAAM,KAAK,MAAM,IAAI,KAAK;AAE9B,QAAO,MAAM;;AAEjB,IAAa,eAAb,MAAa,aAAa;CACtB,YAAY,OAAO,MAAM;AACrB,OAAK,QAAQ;AACb,OAAK,aAAa;AAClB,OAAK,eAAe;AACpB,OAAK,wCAAwC;AAC7C,OAAK,gCAAgC;;CAEzC,OAAO,cAAc,MAAM,QAAQ,SAAS,YAAY,cAAc;EAElE,MAAM,4BAA4B,cAAc,wBAAwB,MAAM,QAAQ,QAAQ;AAC9F,MAAI,aAIA,QAAO,mBAHQ,mBAAmB,KAAK,WAAW,EAC3B,cAAc,kBAAkB,2BAA2B,WAAW,GACxD,WACS;MAM9C,QAAO,mBAHQ,KACQ,cAAc,kBAAkB,2BAA2B,QAAQ,GACrD,QACS;;CAGtD,OAAO,YAAY,MAAM,QAAQ,SAAS,YAAY,cAAc;EAEhE,MAAM,4BAA4B,cAAc,wBAAwB,MAAM,QAAQ,QAAQ;AAC9F,MAAI,aAIA,QAAO,mBAHQ,mBAAmB,KAAK,WAAW,EAC3B,cAAc,kBAAkB,2BAA2B,WAAW,GACxD,WACS;MAM9C,QAAO,mBAHQ,KACQ,cAAc,kBAAkB,2BAA2B,QAAQ,GACrD,QACS;;CAGtD,kBAAkB,SAAS,OAAO,MAAM;AACpC,MAAI,KAAK,sCACL,SAAQ,wBAAwB,OAAO,KAAK;MAG5C,SAAQ,iBAAiB,OAAO,KAAK;;CAG7C,kBAAkB,OAAO,SAAS;EAC9B,MAAM,YAAY,KAAK,WAAW;EAClC,IAAI,UAAU,KAAK,WAAW;AAC9B,MAAI,KAAK,WAAW,cAAc,KAAK,cAAc,QACjD,WAAU,UAAU;EAExB,MAAM,EAAE,SAAS,YAAY,iBAAiB,KAAK;EACnD,MAAM,yBAA0B,cAAc;AAC9C,MAAI,KAAK,MAAM,aAAa;AAExB,OAAI,KAAK,WAAW,SAAS,EACzB;QAAI,QAAQ,KAAK,MAAM,eAAe,UAAU,CAAC,CAC7C,MAAK,wCAAwC;;GAIrD,IAAI,0BAA0B,GAAG,cAAc;AAC/C,QAAK,IAAI,aAAa,WAAW,cAAc,SAAS,cAAc,0BAA0B,aAAa;AACzG,kBAAc;IACd,MAAM,WAAW,MAAM,eAAe,WAAW;IACjD,IAAI,sBAAsBC,wBAAgC,SAAS;AACnE,QAAI,KAAK,MAAM,cAAc,SAAS,WAAW,KAAK,wBAAwB,GAE1E;AAEJ,QAAI,CAAC,0BAA0B,CAAC,KAAK,MAAM,aAAa,SAAS,WAAW,EAExE;AAEJ,QAAI,wBAAwB,GAExB,uBAAsB,SAAS;AAEnC,QAAI,aAAa,GAEb;SADkC,cAAc,wBAAwB,UAAU,sBAAsB,GAAG,QAAQ,GACnF,eAAe,GAG3C;UAAI,MAAM,kBAAkB,aAAa,EAAE,EAAE;OACzC,MAAM,cAAc,8BAA8B,eAAe,KAAK,MAAM,YAAY,OAAO,IAAIC,QAAM,aAAa,GAAG,MAAM,iBAAiB,aAAa,EAAE,EAAE,aAAa,GAAG,MAAM,iBAAiB,aAAa,EAAE,CAAC,CAAC;AACzN,WAAI,aAAa;AACb,sBAAc;AACd,YAAI,YAAY,WACZ,MAAK,IAAI,IAAI,GAAG,OAAO,YAAY,WAAW,QAAQ,IAAI,QAAQ,cAAc,YAAY,IACxF,KAAI,YAAY,WAAW,WAAW,EAAE,KAAK,GACzC;YAGA;AAIZ,YAAI,YAAY,WACZ,eAAc,KAAK,IAAI,GAAG,cAAc,YAAY,WAAW;AAGnE,aAAK,IAAI,IAAI,GAAG,IAAI,aAAa,KAAK;AAClC,aAAI,wBAAwB,KAAK,SAAS,WAAW,sBAAsB,EAAE,KAAK,GAC9E;AAEJ;;;;;;AAMpB,QAAI,KAAK,MAAM,aAAa,wBAAwB,EAEhD;IAEJ,IAAI;AACJ,QAAI,KAAK,MAAM,UACX,iBAAgB,aAAa,cAAc,UAAU,sBAAsB,GAAG,SAAS,YAAY,aAAa;QAGhH,iBAAgB,aAAa,YAAY,UAAU,sBAAsB,GAAG,SAAS,YAAY,aAAa;AAElH,SAAK,kBAAkB,SAAS,IAAIA,QAAM,YAAY,GAAG,YAAY,sBAAsB,EAAE,EAAE,cAAc;AAC7G,QAAI,eAAe,aAAa,CAAC,KAAK,WAAW,SAAS,CAEtD,MAAK,gCAAiC,KAAK,WAAW,eAAe,sBAAsB;;SAIlG;AAED,OAAI,CAAC,KAAK,MAAM,aAAa,KAAK,WAAW,SAAS,IAAI,MAAM,cAAc,UAAU,KAAK,EACzF,MAAK,wCAAwC;GAEjD,MAAM,YAAa,eAAe,mBAAmB,KAAK,WAAW,GAAG;AACxE,QAAK,IAAI,aAAa,WAAW,cAAc,SAAS,cAAc;IAClE,MAAM,WAAW,MAAM,eAAe,WAAW;IACjD,IAAI,sBAAsBD,wBAAgC,SAAS;AACnE,QAAI,KAAK,MAAM,cAAc,SAAS,WAAW,KAAK,wBAAwB,GAE1E;AAEJ,QAAI,CAAC,0BAA0B,CAAC,KAAK,MAAM,aAAa,SAAS,WAAW,EAExE;AAEJ,QAAI,wBAAwB,GAExB,uBAAsB,SAAS;AAEnC,QAAI,KAAK,MAAM,aAAa,wBAAwB,EAEhD;AAEJ,QAAI,KAAK,MAAM,WAAW;AACtB,2BAAsB,KAAK,IAAI,qBAAqB,WAAW;AAC/D,UAAK,IAAI,IAAI,GAAG,IAAI,qBAAqB,IAErC,KADY,SAAS,WAAW,EAAE,KACtB,GAAa;AACrB,4BAAsB,IAAI;AAC1B;;AAGR,UAAK,kBAAkB,SAAS,IAAIC,QAAM,YAAY,GAAG,YAAY,sBAAsB,EAAE,EAAE,GAAG;WAEjG;AACD,UAAK,kBAAkB,SAAS,IAAIA,QAAM,YAAY,GAAG,YAAY,EAAE,EAAE,UAAU;AACnF,SAAI,eAAe,aAAa,CAAC,KAAK,WAAW,SAAS,CAEtD,MAAK,gCAAiC,KAAK,WAAW,gBAAgB;;;;AAKtF,OAAK,eAAe,QAAQ,eAAe,KAAK,WAAW;;CAE/D,mBAAmB,OAAO,QAAQ;AAC9B,MAAI,KAAK,uCAAuC;GAC5C,MAAM,SAAS,OAAO,0BAA0B,CAAC;AACjD,UAAO,IAAIC,YAAU,OAAO,MAAM,eAAe,OAAO,MAAM,WAAW,OAAO,MAAM,eAAe,OAAO,MAAM,UAAU;;EAEhI,MAAM,SAAS,OAAO,oBAAoB,KAAK,aAAa;AAC5D,MAAI,KAAK,+BAA+B;GAEpC,MAAM,qBAAqB,KAAK,WAAW;AAE3C,OAD0B,OAAO,eACR,mBACrB,QAAO;AAEX,OAAI,OAAO,cAAc,KAAK,EAC1B,QAAO,IAAIA,YAAU,OAAO,iBAAiB,oBAAoB,OAAO,eAAe,OAAO,UAAU;AAE5G,UAAO,IAAIA,YAAU,OAAO,eAAe,OAAO,WAAW,OAAO,iBAAiB,mBAAmB;;AAE5G,SAAO;;;;;;;;;;AC/Mf,MAAM,qBAAqB,EACzB,QAAQ,GACT;AAGD,MAAM,qBAAqB;CACzB,UAAU;CACV,aAAa;CACb,UAAU;CACX;AAED,MAAM,6BACJ;AAEF,SAAS,gBAAgB,IAAI;AAC3B,QACE,KAAK,KAAK,GAAG,IACZ,KAAK,QACH,GAAG,aAAa,IAAI,GAAG,aAAa,IACnC,2BAA2B,KAAK,GAAG;;AAI3C,SAASC,MAAI,MAAM,QAAQ;AACzB,KAAI,EAAE,gBAAgBA,OACpB,QAAO,IAAIA,MAAI,MAAM,OAAO;AAG9B,MAAK,OAAO;AACZ,MAAK,KAAK;;AAGZ,SAAS,OAAO,IAAI,UAAQ,MAAM;AAChC,IAAG,SAASC,UAAQ,KAAK;;AAG3B,SAAS,MAAM,KAAK;AAClB,QAAO,WAAY;;AAOrB,IAAI,OAAO,UAAU,WAAW;AAgBhC,IAAI,eAAe,SAAU,QAAQ,SAAS;AAC5C,MAAK,MAAM,KAAK,QAAQ;AACxB,MAAK,SAAS;AACd,MAAK,UAAU,WAAW;AAC1B,MAAK,gBAAgB,KAAK,kBAAkB;AAC5C,MAAK,YAAY;;AAGnB,aAAa,YAAY;CACvB,KAAK,WAAY;AACf,SAAO,KAAK,OAAO,KAAK,OAAO;;CAEjC,KAAK,WAAY;AACf,SAAO,KAAK,OAAO,KAAK;;CAE1B,MAAM,WAAY;AAChB,SAAO,KAAK,OAAO,OAAO,KAAK,IAAI,IAAI;;CAEzC,MAAM,WAAY;AAChB,MAAI,KAAK,MAAM,KAAK,OAAO,OAAQ,QAAO,KAAK,OAAO,OAAO,KAAK,MAAM;;CAE1E,KAAK,SAAU,OAAO;EACpB,IAAI,KAAK,KAAK,OAAO,OAAO,KAAK,IAAI;AACrC,MAAI,OAAO,SAAS,UAAU,IAAI,KAAK,MAAM;OACxC,IAAI,KAAK,OAAO,MAAM,OAAO,MAAM,KAAK,GAAG,GAAG,MAAM,GAAG;AAC5D,MAAI,IAAI;AACN,KAAE,KAAK;AACP,UAAO;;;CAGX,UAAU,SAAU,OAAO;EACzB,IAAI,QAAQ,KAAK;AACjB,SAAO,KAAK,IAAI,MAAM;AACtB,SAAO,KAAK,MAAM;;CAEpB,UAAU,WAAY;EACpB,IAAI,QAAQ,KAAK;AACjB,SAAO,aAAa,KAAK,KAAK,OAAO,OAAO,KAAK,IAAI,CAAC,CAAE,GAAE,KAAK;AAC/D,SAAO,KAAK,MAAM;;CAEpB,WAAW,WAAY;AACrB,OAAK,MAAM,KAAK,OAAO;;CAEzB,QAAQ,SAAU,IAAI;EACpB,IAAI,QAAQ,KAAK,OAAO,QAAQ,IAAI,KAAK,IAAI;AAC7C,MAAI,QAAQ,IAAI;AACd,QAAK,MAAM;AACX,UAAO;;;CAGX,QAAQ,SAAU,GAAG;AACnB,OAAK,OAAO;;CAEd,QAAQ,WAAY;AAClB,QAAM;;CAER,aAAa,WAAY;AACvB,QAAM;;CAER,OAAO,SAAU,SAAS,SAAS,iBAAiB;AAClD,MAAI,OAAO,WAAW,UAAU;GAC9B,IAAI,QAAQ,SAAU,KAAK;AACzB,WAAO,kBAAkB,IAAI,aAAa,GAAG;;AAG/C,OAAI,MADS,KAAK,OAAO,OAAO,KAAK,KAAK,QAAQ,OAAO,CACxC,IAAI,MAAM,QAAQ,EAAE;AACnC,QAAI,YAAY,MAAO,MAAK,OAAO,QAAQ;AAC3C,WAAO;;SAEJ;GACL,IAAI,QAAQ,KAAK,OAAO,MAAM,KAAK,IAAI,CAAC,MAAM,QAAQ;AACtD,OAAI,SAAS,MAAM,QAAQ,EAAG,QAAO;AACrC,OAAI,SAAS,YAAY,MAAO,MAAK,OAAO,MAAM,GAAG;AACrD,UAAO;;;CAGX,SAAS,WAAY;AACnB,SAAO,KAAK,OAAO,MAAM,KAAK,OAAO,KAAK,IAAI;;CAEhD,gBAAgB,SAAU,GAAG,OAAO;AAClC,OAAK,aAAa;AAClB,MAAI;AACF,UAAO,OAAO;YACN;AACR,QAAK,aAAa;;;CAGvB;AAED,SAAS,QAAQ,KAAK;AACpB,QAAO,IAAID,MAAI,IAAI,aAAa,GAAG,IAAI,SAAS,EAAE;;AAGpD,SAAS,YAAY,KAAK;AACxB,QAAO,IAAIE,gDAAS,IAAI,OAAO,GAAG,IAAI,KAAK,EAAE;;AAG/C,IAAM,SAAN,MAAa;CACX,YAAY,IAAI,IAAI,MAAM,IAAI;AAC5B,OAAK,KAAK;AACV,OAAK,KAAK;AACV,OAAK,aAAa,OAAO;AACzB,OAAK,SAAS,KAAK;AACnB,KAAG,MAAM,KAAK,MAAM;;CAGtB,QAAQ;AACN,SAAO,KAAK,GAAG,MAAM,KAAK;;CAG5B,OAAO;AACL,SAAO,QAAQ,KAAK;;;AAIxB,SAAS,cAAc,GAAG,OAAO,OAAO;CACtC,IAAI,YAAY;CAChB,IAAI,UAAUC,+CAAQ,EAAE;AAExB,KAAI,EAAE,KAAK;AACT,YAAU,EAAE;AACZ,cAAY;;CAGd,IAAI,MAAM;CACV,IAAI,qBAAqB;AAEzB,SAAQ,EAAE,SAAV;EACE,KAAKA,+CAAQ;EACb,KAAKA,+CAAQ;EACb,KAAKA,+CAAQ;EACb,KAAKA,+CAAQ,KACX,QAAO;EACT,KAAKA,+CAAQ;AACX,wBAAqB;AACrB,SAAM;AACN;EACF,KAAKA,+CAAQ;AACX,wBAAqB;AACrB;;AAIJ,KAAI,QAAQ,WAAW,MAAM,IAAI,QAAQ,WAAW,OAAO,CACzD,OAAM,QAAQ,QAAQ,SAAS,GAAG,aAAa;UACtC,QAAQ,WAAW,QAAQ,CACpC,OAAM,QAAQ,MAAM,GAAG,EAAE;UAChB,QAAQ,WAAW,SAAS,CACrC,OAAM,QAAQ,MAAM,GAAG,EAAE;UAChB,QAAQ,SAAS,QAAQ,EAAE;AACpC,uBAAqB;AACrB,QAAM,QAAQ,UAAU,GAAG,QAAQ,SAAS,EAAE;YAE9C,QAAQ,WAAW,MAAM,IAEzB,QAAQ,WAAW,UAAU,IAC7B,CAAC,IAED,OAAM,EAAE,aAAa;AAGvB,KAAI,CAAC,sBAAsB,CAAC,EAAE,UAAU,CAAC,EAAE,WAAW,CAAC,EAAE,QACvD,OAAM,EAAE,OAAO,EAAE,aAAa;MACzB;AACL,MAAI,EAAE,OACJ,OAAM,OAAO;AAEf,MAAI,EAAE,QACJ,OAAM,QAAQ;AAEhB,MAAI,EAAE,QACJ,OAAM,QAAQ;AAEhB,MAAI,EAAE,SACJ,OAAM,SAAS;;AAInB,KAAI,IAAI,WAAW,KAAK,UACtB,OAAM,IAAI,IAAI;AAGhB,QAAO;;AAGT,IAAM,YAAN,MAAM,UAAU;CAwFd,YAAY,QAAQ;OA6BpB,iBAAiB,MAAM;AAGrB,OAAI,EAAE,aAAa,mBAAoB,EAAE,YAAYA,+CAAQ,OAC3D;AAGF,OAAI,CAAC,KAAK,SACR;GAGF,MAAM,MAAM,cAAc,EAAE;AAE5B,OAAI,KAAK,YACP,MAAK,kBAAkB,KAAK,EAAE;AAGhC,OAAI,CAAC,IACH;GAGF,MAAM,SAAS,KAAK,MAAM;AAC1B,OAAI,UAAU,OAAO,WAAW,UAAU,OAAO,QAAQ,MAAM;IAC7D,MAAM,MAAM,UAAU,OAAO,QAAQ,KAAK,KAAK,KAAK;AACpD,QAAI,KAAK;AACP,OAAE,gBAAgB;AAClB,OAAE,iBAAiB;AAEnB,SAAI;AACF,WAAK;cACE,KAAK;AACZ,cAAQ,MAAM,IAAI;;;;;OAiE1B,sBAAsB,MAAM;GAC1B,MAAM,EAAE,UAAU,WAAW;GAC7B,MAAM,EAAE,qBAAW;GACnB,MAAM,YAAYC,SAAO,cAAc;AAEvC,OAAI,CAAC,KAAK,UAAU,KAAK,IAAI,EAAE,WAAW,WAAW,UAAU,SAAS,EAAE;IACxE,MAAM,SAASA,SAAO,UAAU,CAAC,iBAAiB,SAAS,WAAW;AAEtE,QAAI,EAAE,SAAS,WAAW,QAAQ;AAChC,cAAO,YAAY,IAAIF,gDAAS,EAAE,SAAS,YAAY,SAAS,EAAE,CAAC;AACnE;;;AAIJ,QAAK,SAAS,kBAAkB,MAAM,EAAE;;OAG1C,gBAAgB,MAAM;GACpB,MAAM,EAAE,YAAY;GACpB,MAAM,SAAS;IACb,MAAM,QAAQ,QAAQ,KAAK,aAAW;AACpC,SAAI,KAAKG,SAAO,KAAK;AACrB,YAAO;OACN,EAAE,CAAC;IACN,QAAQ;IACT;GACD,MAAM,QAAS,KAAK,QAAQ,KAAK,SAAS,EAAE;AAE5C,OAAI,CAAC,MAAM,eACT,OAAM,iBACJ,KAAK,UAAU,aAAa,KAAK,UAAU,UAAU,OAAO;AAGhE,OAAI,KAAK,sBAAsB,CAC7B;AAGF,OAAI,CAAC,MAAM,WACT,OAAM,aAAa,MAAM,SAAS;OAElC,OAAM,WAAW,OAAO,MAAM,aAAa;AAG7C,QAAK,SAAS,UAAU,MAAM,OAAO;;AAvKrC,OAAK,SAAS;AACd,OAAK,QAAQ,EACX,QAAQ,OACT;AACD,OAAK,QAAQ,EAAE;AACf,OAAK,OAAO;AACZ,OAAK,cAAc,EAAE;AACrB,OAAK,YAAY,EAAE;AACnB,OAAK,QAAQ,EAAE;AACf,OAAK,WAAW;AAChB,OAAK,YAAY;AACjB,OAAK,UAAU,EAAE;AACjB,OAAK,mBAAmB;AACxB,OAAK,YAAY,KAAK,OAAO,iBAAiB,cAAc,KAAK;;CAGnE,SAAS;AACP,YAAU,OAAO,IAAI,OAAO,KAAK;;CAGnC,oBAAoB;AAClB,OAAK,YAAY,KACf,KAAK,OAAO,0BAA0B,KAAK,mBAAmB,EAC9D,KAAK,OAAO,wBAAwB,KAAK,aAAa,EACtD,KAAK,OAAO,UAAU,KAAK,cAAc,CAC1C;;CAwCH,kBAAkB,KAAK,GAAG;EACxB,IAAI,cAAc;EAClB,IAAI,OAAO;EACX,MAAM,MAAM,KAAK,OAAO,aAAa;EACrC,IAAI,QAAQ,IAAIC,6CACd,IAAI,YACJ,IAAI,QACJ,IAAI,YACJ,IAAI,SAAS,EACd;EACD,IAAI,mBAAmB;AAEvB,MAAI,IAAI,WAAW,IAAI,CACrB,QAAO,IAAI;WACF,SAAS,QAClB,QAAO;WACE,SAAS,aAAa;GAC/B,MAAM,WAAW,KAAK,aAAa,KAAK;AAExC,OAAI,CAAC,SACH;AAGF,iBAAc;AACd,UAAO;AACP,WAAQ,IAAIA,6CACV,IAAI,YACJ,IAAI,QACJ,IAAI,YACJ,IAAI,SAAS,EACd;QAED;AAGF,IAAE,gBAAgB;AAClB,IAAE,iBAAiB;AAEnB,MAAI,CAAC,KAAK,aACR,MAAK,eAAe,EAAE;AAGxB,MAAI,CAAC,YACH,MAAK,aAAa,KAAK,KAAK,OAAO,UAAU,CAAC,gBAAgB,MAAM,CAAC;AAGvE,OAAK,OAAO,aAAa,OAAO,CAC9B;GACE,MAAM;GACN;GACA;GACD,CACF,CAAC;AAEF,MAAI,YACF,MAAK,OAAO,YAAY,MAAM,kBAAkB,CAAC;;CAkDrD,UAAU,KAAK,OAAO;AACpB,OAAK,MAAM,OAAO;AAElB,MAAI,QAAQ,QACV,+CAAa,SAAS,MAAM;;CAIhC,mBAAmB;EACjB,MAAM,EAAE,WAAW;EACnB,IAAI,OAAO;AAEX,MAAI,OAAO,OAAO,qBAAqB,WACrC,QAAO,OAAO,kBAAkB;WACvB,kBAAkBC,8CAE3B,QAAOA,8CAAa;AAGtB,SAAO;GACL,UAAU,OAAO,UAAU,KAAK,SAAS;GACzC,UAAU,EACR,aAAa,OAAO,UAAU,KAAK,YAAY,EAChD;GACD,UAAU,OAAO,UAAU,KAAK,SAAS;GAC1C;;CAGH,UAAU,KAAK;AACb,MAAI,QAAQ,WACV,QAAO,KAAK,kBAAkB,CAAC;WACtB,QAAQ,kBACjB,QAAO,KAAK,WAAW,GAAG;WACjB,QAAQ,iBACjB,QAAO,CAAC,KAAK,OAAO,UAAU,CAAC,YAAY,CAAC;OACvC;AACL,OAAI,OAAO,KAAK,OAAO,qBAAqB,WAC1C,QAAO,KAAK,OAAO,qBAAqB,CAAC;AAE3C,UAAO,KAAK,OAAO,eAAe,CAAC;;;CAIvC,SAAS,UAAQ,GAAG,MAAM;EACxB,MAAM,YAAY,KAAK,UAAUN;AACjC,MAAI,CAAC,UACH;AAGF,YAAU,SAAS,YAAY,QAAQ,GAAG,KAAK,CAAC;;CAGlD,GAAG,OAAO,SAAS;AACjB,MAAI,CAAC,KAAK,UAAU,OAClB,MAAK,UAAU,SAAS,EAAE;AAG5B,OAAK,UAAU,OAAO,KAAK,QAAQ;;CAGrC,IAAI,OAAO,SAAS;EAClB,MAAM,YAAY,KAAK,UAAU;AACjC,MAAI,CAAC,UACH;AAGF,OAAK,UAAU,SAAS,UAAU,QAAQ,MAAM,MAAM,QAAQ;;CAGhE,YAAY;AACV,SAAO;;CAGT,WAAW;AACT,SAAO,KAAK,WAAW,GAAG;;CAG5B,YAAY;AACV,SAAO,KAAK,OAAO,UAAU,CAAC,cAAc;;CAG9C,oBAAoB;AAClB,SAAO;;CAGT,QAAQ,MAAM;AACZ,MAAI,OAAO,EACT,QAAO;EAGT,MAAM,WADQ,KAAK,OAAO,UAAU,CACb,cAAc;AAErC,MAAI,OAAO,IAAI,SACb,QAAO,WAAW;AAGpB,SAAO,KAAK,OAAO,UAAU,CAAC,eAAe,OAAO,EAAE;;CAGxD,sBAAsB,WAAW;AAC/B,MAAI,UAAU,SAAS,CACrB,QAAO,UAAU,aAAa;AAIhC,SADe,UAAU,cAAc,KACrBO,0DAAmB,MACjC,UAAU,kBAAkB,GAC5B,UAAU,gBAAgB;;CAGhC,oBAAoB,WAAW;AAC7B,MAAI,UAAU,SAAS,CACrB,QAAO,UAAU,aAAa;AAIhC,SADe,UAAU,cAAc,KACrBA,0DAAmB,MACjC,UAAU,gBAAgB,GAC1B,UAAU,kBAAkB;;CAGlC,UAAU,OAAO,MAAM;AACrB,MAAI,CAAC,KACH,QAAO,QAAQ,KAAK,OAAO,aAAa,CAAC;EAG3C,MAAM,MAAM,KAAK,OAAO,cAAc;EACtC,IAAI;AAEJ,MAAI,IAAI,SAAS,CACf,OAAM,IAAI,aAAa;WACd,SAAS,SAClB,OAAM,KAAK,sBAAsB,IAAI;MAErC,OAAM,KAAK,oBAAoB,IAAI;AAGrC,SAAO,QAAQ,IAAI;;CAGrB,SAAS,OAAO,KAAK;EACnB,MAAM,KAAK,YAAY,MAAM;EAC7B,MAAM,KAAK,YAAY,IAAI;AAE3B,SAAO,KAAK,OAAO,UAAU,CAAC,gBAAgBF,6CAAM,cAAc,IAAI,GAAG,CAAC;;CAG5E,eAAe;EACb,IAAI,OAAO,EAAE;EACb,IAAI,SAAS,KAAK;AAClB,SAAO,eAAe,CAAC,IAAI,SAAU,KAAK;AACxC,QAAK,KAAK,OAAO,UAAU,CAAC,gBAAgB,IAAI,CAAC;IACjD;AACF,SAAO,KAAK,KAAK,KAAK;;CAGxB,aAAa,MAAM,OAAO,KAAK;EAC7B,MAAM,KAAK,YAAY,MAAM;EAC7B,MAAM,KAAK,CAAC,MAAM,KAAK,YAAY,IAAI;AAEvC,OAAK,OAAO,aAAa,OAAO,CAC9B;GACE;GACA,OAAOA,6CAAM,cAAc,IAAI,GAAG;GACnC,CACF,CAAC;AAEF,OAAK,cAAc;;CAGrB,eAAe;AACb,OAAK,OAAO,cAAc;;CAG5B,UAAU,MAAM,IAAI;EAClB,IAAI,MAAM;AAEV,MAAI,OAAO,SAAS,UAAU;AAC5B,SAAM,EAAE;AACR,OAAI,OAAO;AACX,OAAI,KAAK;;EAGX,MAAM,YAAY,KAAK,OAAO,UAAU,CAAC,iBAAiB,YAAY,IAAI,CAAC;AAC3E,OAAK,OAAO,YAAY,YAAY,IAAI,CAAC;AACzC,OAAK,OAAO,eAAe,UAAU;;CAGvC,oBAAoB;AAClB,SAAO,CAAC,KAAK,OAAO,cAAc,CAAC,SAAS;;CAG9C,UAAU,IAAI,OAAO;AACnB,SAAO,IAAI;;CAGb,iBAAiB;EACf,MAAM,aAAa,KAAK,OAAO,eAAe;AAE9C,MAAI,CAAC,WAAW,UAAU,KAAK,uBAC7B,QAAO,CACL;GACE,QAAQ,KAAK,UAAU,SAAS;GAChC,MAAM,KAAK,UAAU,OAAO;GAC7B,CACF;AAGH,SAAO,WAAW,KAAK,QAAQ;AACjB,OAAI,aAAa;AACf,OAAI,kBAAkB;AACxB,OAAI,gBAAgB;AAEhC,UAAO;IACL,QAAQ,KAAK,QAAQ,QAAQ,KAAK,sBAAsB,IAAI,CAAC,CAAC;IAC9D,MAAM,KAAK,QAAQ,QAAQ,KAAK,oBAAoB,IAAI,CAAC,CAAC;IAC3D;IACD;;CAGJ,QAAQ;AACN,OAAK,OAAO,OAAO;;CAGrB,cAAc,YAAY,WAAW;EACnC,MAAM,SAAS,CAAC,CAAC,KAAK,OAAO,eAAe,CAAC;EAC7C,MAAM,OAAO,WAAW,KAAK,OAAK,UAAU;GAC1C,MAAM,EAAE,QAAQ,SAASG;AAEzB,OAAI,OACF,QAAOC,iDAAU,cAAc,YAAY,OAAO,EAAE,YAAY,KAAK,CAAC;OAEtE,QAAOA,iDAAU,cAAc,YAAY,KAAK,EAAE,YAAY,OAAO,CAAC;IAExE;AAEF,MAAI,CAAC,WAAW,YACL,KAAK,WACd,MAAK,KAAK,KAAK,OAAO,WAAW,EAAE,CAAC,GAAG;AAGzC,MAAI,CAAC,KAAK,OACR;EAGF,MAAM,MAAM,KAAK;EACjB,IAAI;AAEJ,MAAI,IAAI,cAAc,KAAKF,0DAAmB,IAC5C,eAAc,IAAI,gBAAgB;MAElC,eAAc,IAAI,kBAAkB;AAGtC,OAAK,OAAO,cAAc,KAAK;AAC/B,OAAK,OAAO,eAAe,YAAY;;CAGzC,aAAa,KAAK,IAAI;EACpB,MAAM,QAAQF,6CAAM,cAAc,YAAY,IAAI,EAAE,YAAY,GAAG,CAAC;AACpE,OAAK,OAAO,aAAa,MAAM;;CAGjC,gBAAgB;EACd,MAAM,EAAE,WAAW;AACnB,SAAO,OACJ,eAAe,CACf,KAAK,QAAQ,OAAO,UAAU,CAAC,gBAAgB,IAAI,CAAC;;CAGzD,kBAAkB,OAAO;EACvB,MAAM,EAAE,WAAW;AAEnB,SAAO,eAAe,CAAC,SAAS,KAAK,UAAU;AAC7C,UAAO,aAAa,OAAO,CACzB;IACE,OAAO;IACP,MAAM,MAAM;IACZ,kBAAkB;IACnB,CACF,CAAC;IACF;;CAGJ,gBAAgB,QAAQ;AACtB,MAAI,QAAQ;AACV,QAAK,cAAc;AACnB,QAAK,cAAc;SACd;AACL,QAAK,cAAc;AACnB,QAAK,cAAc;AACnB,QAAK,eAAe,EAAE;;;CAI1B,WAAW,KAAK,MAAM;AACpB,SAAO;GACL,KAAK,IAAI;GACT,MAAM,IAAI;GACX;;CAGH,WAAW,KAAK,MAAM;AACpB,MAAI,SAAS,SAAS;;CAIxB,QAAQ,GAAG;AAET,SAAO,QADK,KAAK,OAAO,UAAU,CAAC,iBAAiB,YAAY,EAAE,CAAC,CAChD;;CAGrB,YAAY,QAAQ,SAAS;EAC3B,MAAM,KAAK,IAAI,OAAO,MAAM,KAAK,QAAQ,OAAO,MAAM,OAAO,GAAG;AAEhE,MAAI,CAAC,WAAW,CAAC,QAAQ,WACvB,IAAG,eAAe;AAGpB,OAAK,MAAM,GAAG,MAAM;AACpB,SAAO;;CAGT,gBAAgB;EACd,MAAM,EAAE,WAAW;EACnB,MAAM,CAAC,SAAS,OAAO,kBAAkB;AAEzC,SAAO;GACL,MAAM;GACN,KAAK,MAAM,kBAAkB;GAC7B,QAAQ,OAAO,UAAU,CAAC,cAAc;GACxC,cAAc,MAAM,gBAAgB,MAAM,kBAAkB;GAC7D;;CAGH,oBAAoB,QAAQ;AAC1B,OAAK,OAAO,QAAQ,OAAO,OAAO;;CAGpC,UAAU;AACR,OAAK,SAAS,UAAU;AACxB,OAAK,eAAe;AAEpB,MAAI,UAAU,OAAO,IACnB,WAAU,OAAO,IAAI,OAAO,KAAK;AAGnC,OAAK,YAAY,SAAS,MAAM,EAAE,SAAS,CAAC;;CAG9C,gBAAgB;CAChB,oBAAoB;CAEpB,aAAa,QAAQ,MAAM;AACzB,OAAK,UAAU,IAAI,MAAM;EACzB,MAAM,SAAS,KAAK,kBAAkB;AACtC,OAAK,qBAAqB,OAAO,SAAS,eAAe;AAEzD,OAAK,OAAO,cAAc;GACxB,aAAa,OAAO,SAAS;GAC7B,gBAAgB;GAChB,aAAa;GACd,CAAC;;CAGJ,eAAe;AACb,OAAK,UAAU,IAAI,KAAK;AAExB,OAAK,OAAO,cAAc;GACxB,aAAa,KAAK,sBAAsB;GACxC,gBAAgB;GAChB,aAAa;GACd,CAAC;;CAGJ,uBAAuB;AACrB,SAAO,KAAK;;CAGd,WAAW;AAET,SAAO;GAAE,OAAO,WAAY;GAAI,MAAM,WAAY;GAAI;;CAGxD,sBAAsB;EACpB,MAAM,SAAS,KAAK,OAAO,kBAAkB;AAC7C,MAAI,CAAC,OAAO,OACV,QAAO;GACL,KAAK;GACL,QAAQ;GACT;EAGH,MAAM,MAAM;GACV,KAAK;GACL,QAAQ;GACT;AAED,SAAO,QAAQ,KAAK,UAAU;AAC5B,OAAI,MAAM,kBAAkB,IAAI,IAC9B,KAAI,MAAM,MAAM;AAGlB,OAAI,MAAM,gBAAgB,IAAI,OAC5B,KAAI,SAAS,MAAM;AAGrB,UAAO;KACN,IAAI;AAEP,MAAI,OAAO;AACX,MAAI,UAAU;AAEd,SAAO;;CAGT,SAAS,UAAU,QAAQ,MAAM;EAC/B,MAAM,EAAE,WAAW;EACnB,IAAI,cAAc;EAClB,IAAI,YAAY;EAChB,MAAM,MAAM,YAAY,SAAS;AAEjC,MAAI,SAAS,QAAQ;GACnB,MAAM,eAAe,OAAO,eAAe,CAAC;GAC5C,MAAM,aAAa,KAAK,kBAAkB,CAAC,SAAS;AACpD,iBAAc,cAAc,KAAK,MAAM,eAAe,WAAW;AACjE,eAAY;;AAGd,MAAI,cAAc,OAChB,KAAI,cAAc;AAGpB,SAAO,QAAQ,IAAI;;CAGrB,oBAAoB,KAAK;EACvB,MAAM,OAAO,YAAY,IAAI;EAC7B,MAAM,QAAQ,KAAK,OAAO,UAAU;EACpC,IAAI;AAEJ,MAAI,MAAM,aACR,OAAM,MAAM,aAAa,aAAa,KAAK;OACtC;;AACL,gCAAM,MAAM,oGAAe,KAAK;;AAGlC,MAAI,CAAC,OAAO,EAAE,IAAI,WAAW,GAC3B,QAAO,EACL,IAAI,MACL;AAGH,SAAO,EACL,IAAI,QAAQ,IAAI,GAAG,kBAAkB,CAAC,EACvC;;CAGH,gCAAgC,MAAM;AACpC,SAAO,KAAK,OAAO,UAAU,CAAC,gCAAgC,OAAO,EAAE,GAAG;;CAG5E,SAAS,GAAG,GAAG;AACb,MAAI,CAAC,KAAK,CAAC,EACT;AAEF,MAAI,CAAC,GAAG;AACN,OAAI,IAAI,EACN,KAAI,KAAK,OAAO,aAAa,CAAC,aAAa;AAE7C,QAAK,OAAO,aAAa,KAAK,OAAO,oBAAoB,IAAI,EAAE,CAAC;;;CAIpE,kBAAkB,cAAc;EAC9B,MAAM,EAAE,WAAW;EACnB,MAAM,MAAM,OAAO,aAAa;EAChC,MAAM,QAAQA,6CAAM,cAAc,KAAK,IAAI;AAE3C,UAAQ,cAAR;GACE,KAAK;AACH,WAAO,iBAAiB,MAAM;AAC9B;GACF,KAAK;AACH,WAAO,oBAAoB,MAAM;AACjC;GACF,KAAK;;AAEH,mCAAO,+FAAe,OAAO,mBAAmB,OAAO;AACvD;;;CAIN,gBAAgB,OAAO,KAAK;EAC1B,IAAI,YAAY;EAChB,IAAI,UAAU;AAEd,MAAI,iBAAiB,UAAU,CAAC,MAAM,QAAQ;AAC5C,eAAY,CAAC,MAAM;AACnB,WAAQ,MAAM;AACd,aAAU;;AAGZ,MAAI,IAAI,MAAM,OAAW,KAAI,KAAK,OAAO;EAEzC,MAAM,YAAY,YAAY,IAAI;EAClC,MAAM,UAAU;EAChB,MAAM,EAAE,WAAW;EACnB,IAAI,aAAa;EACjB,MAAM,QAAQ,OAAO,UAAU;EAC/B,MAAM,UAAU,MAAM,YAAY,OAAO,OAAO,SAAS,UAAU,IAAI,EAAE;AAEzE,SAAO;GACL,aAAa;AACX,WAAO;;GAET,WAAW;AACT,WAAO,KAAK,KAAK,MAAM;;GAEzB,eAAe;AACb,WAAO,KAAK,KAAK,KAAK;;GAExB,OAAO,OAAO;AACZ,QAAI,CAAC,WAAW,CAAC,QAAQ,OACvB,QAAO;AAGT,iBADY,QAAQ,OACD;AACnB,YAAQ,gBAAgB,CAAC,WAAW,EAAE,mBAAmB;AACzD,YAAQ,gBACN,QAAQ,KAAK,MAAM,EAAE,MAAM,CAAC,QAAQ,MAAM,CAAC,EAAE,YAAY,WAAW,CAAC,CACtE;AAED,WAAO;;GAET,KAAK,MAAM;AACT,QAAI,CAAC,WAAW,CAAC,QAAQ,OACvB,QAAO;IAGT,IAAI;AAEJ,QAAI,MAAM;KACR,MAAMK,QAAM,aAAa,WAAW,kBAAkB,GAAG;AACzD,aAAQ,MAAM,kBAAkB,OAAOA,OAAK,SAAS,UAAU;AAE/D,SAAI,CAAC,SAAS,CAAC,MAAM,MAAM,kBAAkB,CAAC,gBAAgBA,MAAI,CAChE,QAAO;WAEJ;KACL,MAAMA,QAAM,aACR,MAAM,cACJ,MAAM,YAAY,WAAW,gBAAgB,CAAC,GAAG,EAClD,GACD;AACJ,aAAQ,MAAM,cAAc,OAAOA,OAAK,SAAS,UAAU;AAC3D,SAAI,CAAC,SAAS,CAACA,MAAI,gBAAgB,MAAM,MAAM,kBAAkB,CAAC,CAChE,QAAO;;AAIX,iBAAa,MAAM;AACnB,YAAQ,gBAAgB,CAAC,WAAW,EAAE,mBAAmB;AACzD,YAAQ,gBACN,QAAQ,KAAK,MAAM,EAAE,MAAM,CAAC,QAAQ,MAAM,CAAC,EAAE,YAAY,WAAW,CAAC,CACtE;AAED,WAAO;;GAET,OAAO;AACL,WAAO,cAAc,QAAQ,WAAW,kBAAkB,CAAC;;GAE7D,KAAK;AACH,WAAO,cAAc,QAAQ,WAAW,gBAAgB,CAAC;;GAE3D,QAAQ,MAAM;AACZ,QAAI,YAAY;AACd,YAAO,aACL,OACA,CACE;MACE,OAAO;MACP;MACA,kBAAkB;MACnB,CACF,EACD,SAAU,OAAO;MACf,MAAM,EAAE,eAAe,cAAc,MAAM,GAAG;AAC9C,mBAAa,WAAW,eAAe,eAAe,UAAU;OAEnE;AACD,YAAO,YAAY,WAAW,kBAAkB,CAAC;;;GAGtD;;CAGH,gBAAgB,QAAQ,YAAY,aAAa;EAC/C,MAAM,gBAAgB,aAAa;AACnC,OAAK,iBAAiB,KAAK,OAAO,iBAChC,KAAK,kBAAkB,EAAE,EACzB,OAAO,KAAK,WAAW;GACrB;GACA,SAAS;IACP,YACEJ,8CAAa,uBAAuB;IACtC,QAAQ;IACR;IACA,iBAAiB;IAClB;GACF,EAAE,CACJ;AAED,SAAO,KAAK;;CAGd,WAAW,EAAE,SAAS,aAAa,OAAO;EACxC,IAAI,YAAY;EAChB,IAAI,UAAU;AAEd,MAAI,SAAS,iBAAiB,UAAU,CAAC,MAAM,QAAQ;AACrD,aAAU;AACV,eAAY,CAAC,MAAM;AACnB,WAAQ,MAAM;;EAGhB,MAAM,QAAQ,KAAK,OAChB,UAAU,CACV,cAAc,OAAO,KAAK,OAAO,aAAa,EAAE,SAAS,UAAU;AAEtE,MAAI,CAAC,SAAS,CAAC,MAAM,MACnB;AAGF,OAAK,gBAAgB,CAAC,MAAM,MAAM,CAAC;;CAGrC,gBAAgB;AACd,GAAC,oBAAoB,YAAY,CAAC,SAAS,QAAQ;AACjD,QAAK,OAAO,iBAAiB,KAAK,aAAa,UAAU,EAAE,EAAE,EAAE,CAAC;IAChE;;CAGJ,eAAe,KAAK;AAClB,MAAI,CAAC,IACH;AAEF,OAAK,OAAO,eAAe,YAAY,IAAI,CAAC;;CAG9C,MAAM,OAAO,MAAM;AACjB,MAAI,SAAS,OACX;EAEF,MAAM,MAAM,KAAK,OAAO,aAAa;AACrC,OAAK,OAAO,YAAY,IAAIL,gDAAS,IAAI,YAAY,IAAI,SAAS,MAAM,CAAC;;CAG3E,eAAe,KAAK,KAAK,IAAI,QAAQ;EACnC,MAAM,EAAE,iBAAiB;EACzB,IAAI,OAAO,YAAY,IAAI;EAC3B,MAAM,QAAQ,KAAK,OAAO,UAAU;EAEpC,MAAM,cACJ,QAAQ,KAAK,MAAM,oBAAoB,MAAM,eAC7C,KAAK,MAAM;EACb,MAAM,QAAQ,EAAE;EAChB,IAAI,aAAa;AAEjB,SAAO,MAAM;AACX,OAAI,aAAa,GAEf;GAGF,MAAM,QAAQ,WACZ,aAAa,QACb,MACA,MACA,MACA,MACA,KACD;GACD,MAAM,cAAc,MAAM,QAAQ;AAElC,OAAI,UAAU,OACZ;GAGF,MAAM,kBAAkB,UAAU,iBAAiB;AAEnD,OAAI,mBAAoB,gBAAgB,OAAO,EAAE,KAAK,OAAQ,MAAM,EAClE,OAAM,KAAK,YAAY;YACd,MAAM,WAAW,EAG1B,QAAO,EACL,KAAK,QAHK,MAAM,MAAM,kBAAkB,CAGvB,EAClB;OAED,OAAM,KAAK;AAGb,UAAO,MAAM,cACX,MAAM,YAAY,MAAM,MAAM,kBAAkB,CAAC,GAAG,IACrD;AACD,iBAAc;;;CAIlB,aAAa,KAAK;AAChB,SAAO,KAAK,OAAO,UAAU,CAAC,YAAY,YAAY,IAAI,CAAC;;CAG7D,aAAa,QAAQ;AACnB,SAAO,QAAQ,KAAK,OAAO,UAAU,CAAC,cAAc,OAAO,CAAC;;CAG9D,WAAW,MAAM,cAAc,MAAM;EACnC,MAAM,EAAE,WAAW;EACnB,IAAI;AAEJ,MAAI,OAAO,cACT,gBAAe,OAAO,eAAe,CAAC;MAEtC,gBAAe,OAAO,aAAa,CAAC,QAAQ;EAE9C,MAAM,MAAM,IAAIA,gDAAS,OAAO,GAAG,EAAE;EACrC,MAAM,MAAMQ,iDAAU,cAAc,KAAK,IAAI;AAE7C,SAAO,eACL,OACA,IAAI,aAAa,KAAK;GACpB,WAAW,CAAC;GACZ,SAAS,aAAa;GACtB,YAAY,aAAa;GACzB,cAAc,aAAa;GAC3B,aAAa,aAAa;GAC1B,YAAY,aAAa;GAC1B,CAAC,CACH;;CAGH,aAAa,WAAW;AACtB,OAAK,YAAY;;CAGnB,WAAW,MAAM,UAAU,SAAS;AAClC,MAAI,CAAC,KAAK,UACR;AAGF,SAAO,KAAK,UAAU,OAAO,MAAM,UAAU,QAAQ;;CAGvD,iBAAiB,MAAM;AACrB,MAAI,CAAC,KAAK,UACR;AAGF,OAAK,UAAU,iBAAiB,KAAK;;CAGvC,cAAc;AAGZ,OAAK,OAAO,UAAU,gCAAgC,CAAC,KAAK;;CAG9D,aAAa,IAAI;EACf,MAAM,SAAS,KAAK,OAAO,aAAa;AACxC,MAAI,OAAO,QACT,QAAO,SAAS;WACP,OAAO,MAChB,QAAO,SAAS,KAAK,OAClB,UAAU,CACV,iBAAiB,OAAO,WAAW;AAExC,OAAK,OAAO,YAAY,OAAO;;CAGjC,YAAY,SAAS;AACnB,UAAQ,SAAR;GACE,KAAK;AACH,SAAK,aAAa,QAAQ;AAC1B;GACF,KAAK;AACH,SAAK,aAAa,MAAM;AACxB;GACF,KAAK;AACH,SAAK,aAAa;AAClB;;;;;UAzhCC,MAAMV;UACN,SAAS;UACT,KAAK,MAAM,KAAK;UAChB,MAAM,MAAM,MAAM;UAClB,WAAW,MAAM,WAAW;UAC5B,UAAU,MAAM,UAAU;UAC1B,eAAe,MAAM,eAAe;UACpC,SAAS,EACd,SAAS,SAAU,KAAK;AACtB,QAAO,SAAU,IAAI;AACnB,SAAO;;GAGZ;UACM,mBAAmB;CACxB,KAAK;CACL,KAAK;CACL,KAAK;CACL,KAAK;CACL,KAAK;CACL,KAAK;CACL,KAAK;CACL,KAAK;CACN;UACM,aAAa;UACb,UAAU;UACV,eAAe;UACf,SAAS,SAAU,GAAG;AAC3B,KAAI,EAAE,gBACJ,GAAE,iBAAiB;KAEnB,GAAE,eAAe;AAEnB,YAAU,iBAAiB,EAAE;AAC7B,QAAO;;UAGF,mBAAmB,SAAU,GAAG;AACrC,KAAI,EAAE,gBAAgB;AACpB,IAAE,gBAAgB;AAElB,MAAI,EAAE,aACJ,GAAE,aAAa,gBAAgB;OAGjC,GAAE,cAAc;AAGlB,QAAO;;UAGF,WAAW;CAChB,MAAM,SAAU,IAAI;AAClB,KAAG,OAAO,UAAU,CAAC,MAAM;;CAE7B,MAAM,SAAU,IAAI;AAClB,KAAG,OAAO,UAAU,CAAC,MAAM;;CAE7B,kBAAkB,SAAU,IAAI;AAC9B,KAAG,oBAAoB,gCAAgC;;CAE1D;UAEM,YAAY,SAAS,UAAU,KAAK,KAAK,QAAQ;AACtD,KAAI,OAAO,QAAQ,SACjB,OAAMY,WAAU,OAAO;CAEzB,MAAM,QAAQ,OAAO,OAAO,aAAa,IAAI,IAAI,GAAG,IAAI;AAExD,KAAI,UAAU,MAAO,QAAO;AAC5B,KAAI,UAAU,MAAO,QAAO;AAC5B,KAAI,SAAS,QAAQ,OAAO,MAAM,CAAE,QAAO;AAE3C,KAAI,IAAI,aAAa;AACnB,MAAI,CAAC,MAAM,QAAQ,IAAI,YAAY,CACjC,QAAO,UAAU,KAAK,IAAI,aAAa,OAAO;AAChD,OAAK,IAAI,IAAI,GAAG,IAAI,IAAI,YAAY,QAAQ,KAAK;GAC/C,IAAI,SAAS,UAAU,KAAK,IAAI,YAAY,IAAI,OAAO;AACvD,OAAI,OAAQ,QAAO;;;;UAKlB,kBAAkB,SAAU,MAAM,IAAI;AAC3C,YAAU,UAAU,QAAQ;;AA08BhC,yBAAe;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvwCf,IAAI,MAAMC,mBAAW;AAErB,SAAS,gBAAgB,IAAI,OAAO;CAClC,IAAI,MAAM,GAAG,MAAM;AACnB,KAAI,CAAC,OAAO,IAAI,WAAY,QAAO,MAAM;CACzC,IAAI,OAAO,IAAI,IAAI;AACnB,KAAI,CAAC,KAAM,QAAO,MAAM;AAExB,KAAI,IAAI,aACN;MAAI,MAAM,KAAK,QAAQ,KAAK,KAC1B;;AAGJ,KAAI,MAAM,MAAM,IAAI,MAAM,UAAU,CAAC,MAAM,OAAO,EAChD;MAAI,MAAM,KAAK,QAAQ,KAAK,QAAQ,MAAM,KAAK,MAAM,KAAK,GACxD,QAAO,IAAI,IAAI,MAAM,KAAK,MAAM,MAAM,KAAK,KAAK,EAAE;;AAGtD,QAAO,MAAM;;AAGf,IAAI,gBAAgB;CAGlB;EAAE,MAAM;EAAU,MAAM;EAAY,QAAQ;EAAK;CACjD;EAAE,MAAM;EAAW,MAAM;EAAY,QAAQ;EAAK;CAClD;EAAE,MAAM;EAAQ,MAAM;EAAY,QAAQ;EAAK;CAC/C;EAAE,MAAM;EAAU,MAAM;EAAY,QAAQ;EAAK;CACjD;EAAE,MAAM;EAAS,MAAM;EAAY,QAAQ;EAAM;CACjD;EAAE,MAAM;EAAW,MAAM;EAAY,QAAQ;EAAM;CACnD;EAAE,MAAM;EAAW,MAAM;EAAY,QAAQ;EAAK;CAClD;EAAE,MAAM;EAAQ,MAAM;EAAY,QAAQ;EAAK,SAAS;EAAU;CAClE;EAAE,MAAM;EAAS,MAAM;EAAY,QAAQ;EAAK,SAAS;EAAU;CACnE;EAAE,MAAM;EAAa,MAAM;EAAY,QAAQ;EAAK;CACpD;EAAE,MAAM;EAAU,MAAM;EAAY,QAAQ;EAAK,SAAS;EAAU;CACpE;EAAE,MAAM;EAAa,MAAM;EAAY,QAAQ;EAAK;CACpD;EAAE,MAAM;EAAU,MAAM;EAAY,QAAQ;EAAK,SAAS;EAAU;CACpE;EAAE,MAAM;EAAS,MAAM;EAAY,QAAQ;EAAK;CAChD;EAAE,MAAM;EAAS,MAAM;EAAY,QAAQ;EAAK;CAChD;EAAE,MAAM;EAAS,MAAM;EAAY,QAAQ;EAAS;CACpD;EAAE,MAAM;EAAS,MAAM;EAAY,QAAQ;EAAS;CACpD;EAAE,MAAM;EAAS,MAAM;EAAY,QAAQ;EAAS,SAAS;EAAU;CACvE;EAAE,MAAM;EAAS,MAAM;EAAY,QAAQ;EAAS,SAAS;EAAU;CACvE;EAAE,MAAM;EAAK,MAAM;EAAY,QAAQ;EAAM,SAAS;EAAU;CAChE;EAAE,MAAM;EAAK,MAAM;EAAY,QAAQ;EAAK,SAAS;EAAU;CAC/D;EAAE,MAAM;EAAK,MAAM;EAAY,QAAQ;EAAM,SAAS;EAAU;CAChE;EAAE,MAAM;EAAK,MAAM;EAAY,QAAQ;EAAO,SAAS;EAAU;CACjE;EAAE,MAAM;EAAU,MAAM;EAAY,QAAQ;EAAK;CACjD;EAAE,MAAM;EAAS,MAAM;EAAY,QAAQ;EAAK;CAChD;EAAE,MAAM;EAAY,MAAM;EAAY,QAAQ;EAAS;CACvD;EAAE,MAAM;EAAc,MAAM;EAAY,QAAQ;EAAS;CACzD;EAAE,MAAM;EAAQ,MAAM;EAAY,QAAQ;EAAM,SAAS;EAAU;CACnE;EAAE,MAAM;EAAS,MAAM;EAAY,QAAQ;EAAK,SAAS;EAAU;CACnE;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,SAAS;EACV;CAED;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,UAAU;GAAM,YAAY;GAAM;EACjD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,UAAU;GAAM,YAAY;GAAM;EACjD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,UAAU;GAAM,YAAY;GAAM;EACjD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,OAAO;EAC/B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,MAAM;EAC9B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,UAAU;GAAM;EAC9C;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,UAAU;GAAM;EAC/C;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,MAAM;EAC9B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,OAAO;EAC/B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,SAAS;GAAO;EAC9C;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,SAAS;GAAO,SAAS;GAAM;EAC7D;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,SAAS;GAAM,WAAW;GAAM;EAC9D;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GACV,SAAS;GACT,SAAS;GACT,SAAS;GACT,WAAW;GACZ;EACF;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,SAAS;GAAO;EAC/C;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,SAAS;GAAO,SAAS;GAAM;EAC9D;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,SAAS;GAAM,WAAW;GAAM;EAC/D;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GACV,SAAS;GACT,SAAS;GACT,SAAS;GACT,WAAW;GACZ;EACF;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,YAAY;GAAM;EACjD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,YAAY;GAAM;EAChD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,OAAO;EAC/B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,MAAM;EAC9B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,MAAM;EAC9B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,OAAO;EAC/B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,gBAAgB;GAAM;EACpD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,gBAAgB;GAAM;EACrD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GACV,SAAS;GACT,gBAAgB;GAChB,UAAU;GACV,YAAY;GACb;EACF;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GACV,SAAS;GACT,gBAAgB;GAChB,UAAU;GACV,YAAY;GACb;EACF;CACD;EAAE,MAAM;EAAM,MAAM;EAAU,QAAQ;EAA0B;CAChE;EAAE,MAAM;EAAM,MAAM;EAAU,QAAQ;EAA4B;CAClE;EAAE,MAAM;EAAM,MAAM;EAAU,QAAQ;EAA4B;CAClE;EAAE,MAAM;EAAK,MAAM;EAAU,QAAQ;EAAqB;CAC1D;EAAE,MAAM;EAAK,MAAM;EAAU,QAAQ;EAAqC;CAC1E;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,aAAa;GAAM;EACjD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,aAAa;GAAM;EAClD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,aAAa;GAAM,cAAc;GAAI;EACnE;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,WAAW,MAAM;EAChC;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,WAAW;GAAM,YAAY;GAAM;EAClD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,WAAW;GAAM;EAC/C;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,OAAO;EAC/B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,WAAW;GAAM;EAC/C;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,OAAO;EAC/B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,MAAM;EAC9B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,OAAO;EAC/B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,YAAY;GAAM,UAAU;GAAM;EACjD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,YAAY,MAAM;EACjC;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,MAAM;EAC9B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,OAAO;EAC/B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,UAAU;GAAM;EAC9C;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,UAAU;GAAM;EAC/C;CAED;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY;GAAE,OAAO;GAAM,QAAQ;GAAM,aAAa;GAAM;EAC7D;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY;GAAE,OAAO;GAAO,QAAQ;GAAM,aAAa;GAAM;EAC9D;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,YAAY;GAAM;EAChD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,YAAY;GAAM;EACjD;CACD;EAAE,MAAM;EAAK,MAAM;EAAU,QAAQ;EAAgB;CACrD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,UAAU,MAAM;EAC9B,SAAS;EACV;CAED;EAAE,MAAM;EAAK,MAAM;EAAY,UAAU;EAAU;CACnD;EAAE,MAAM;EAAK,MAAM;EAAY,UAAU;EAAQ;CACjD;EAAE,MAAM;EAAK,MAAM;EAAY,UAAU;EAAU;CACnD;EAAE,MAAM;EAAK,MAAM;EAAY,UAAU;EAAc;CACvD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,cAAc,EAAE,aAAa,MAAM;EACpC;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,cAAc,EAAE,aAAa,OAAO;EACrC;CACD;EAAE,MAAM;EAAM,MAAM;EAAY,UAAU;EAAc;CACxD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,cAAc,EAAE,SAAS,MAAM;EAC/B,QAAQ;EACT;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,cAAc,EAAE,SAAS,OAAO;EAChC,QAAQ;EACT;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,YAAY;GAAM;EAChD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,YAAY;GAAM;EACjD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,MAAM;EAC9B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,OAAO;EAC/B;CAED;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,QAAQ;EACR,YAAY,EAAE,SAAS,MAAM;EAC7B,oBAAoB,EAAE,YAAY,OAAO;EAC1C;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,QAAQ;EACR,YAAY,EAAE,SAAS,OAAO;EAC9B,oBAAoB,EAAE,YAAY,MAAM;EACzC;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,QAAQ;EACR,YAAY,EAAE,WAAW,MAAM;EAC/B,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,cAAc,EAAE,UAAU,MAAM;EAChC,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,QAAQ;EACR,YAAY,EAAE,UAAU,MAAM;EAC9B,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,cAAc,EAAE,UAAU,MAAM;EAChC,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,QAAQ;EACR,YAAY,EAAE,WAAW,MAAM;EAC/B,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,cAAc,EAAE,UAAU,MAAM;EAChC,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,QAAQ;EACR,YAAY,EAAE,SAAS,MAAM;EAC7B,cAAc,EAAE,kBAAkB,MAAM;EACxC,SAAS;EACV;CACD;EAAE,MAAM;EAAK,MAAM;EAAY,UAAU;EAAc,SAAS;EAAU;CAC1E;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,QAAQ;EACR,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,SAAS;GAAO;EAC9C,SAAS;EACV;CAED;EAAE,MAAM;EAAS,MAAM;EAAQ,SAAS;EAAU;CAElD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,MAAM;EAC9B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,SAAS,OAAO;EAC/B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAM,UAAU;GAAM;EAC9C;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY;GAAE,SAAS;GAAO,UAAU;GAAM;EAC/C;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY,EAAE,UAAU,aAAa;EACrC,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY,EAAE,UAAU,OAAO;EAC/B,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY,EAAE,UAAU,qBAAqB;EAC7C,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY,EAAE,UAAU,WAAW;EACnC,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY,EAAE,UAAU,YAAY;EACpC,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY,EAAE,UAAU,iBAAiB;EACzC,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY,EAAE,UAAU,OAAO;EAC/B,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY,EAAE,UAAU,uBAAuB;EAC/C,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,uBAAuB;EACvB,YAAY,EAAE,OAAO,MAAM;EAC3B,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,uBAAuB;EACvB,YAAY,EAAE,OAAO,OAAO;EAC5B,SAAS;EACV;CACD;EAAE,MAAM;EAAK,MAAM;EAAU,QAAQ;EAAoB;CACzD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,UAAU,MAAM;EAC/B;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,WAAW,MAAM;EAChC;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,WAAW,MAAM;EAChC;CACD;EAAE,MAAM;EAAM,MAAM;EAAU,QAAQ;EAAyB;CAC/D;EAAE,MAAM;EAAK,MAAM;EAAU,QAAQ;EAAa,QAAQ;EAAM;CAChE;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,YAAY,MAAM;EAChC,QAAQ;EACT;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY;GAAE,OAAO;GAAM,QAAQ;GAAM;EAC1C;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY;GAAE,OAAO;GAAO,QAAQ;GAAM;EAC3C;CACD;EAAE,MAAM;EAAgB,MAAM;EAAU,QAAQ;EAAW,QAAQ;EAAM;CACzE;EAAE,MAAM;EAAgB,MAAM;EAAU,QAAQ;EAAe;CAC/D;EAAE,MAAM;EAAgB,MAAM;EAAU,QAAQ;EAAwB;CAExE;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY,EAAE,SAAS,MAAM;EAC7B,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,cAAc;GAAE,UAAU;GAAM,UAAU;GAAM;EAChD,SAAS;EACT,iBAAiB;EAClB;CACD;EAAE,MAAM;EAAK,MAAM;EAAU,QAAQ;EAAQ,SAAS;EAAU;CAChE;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,cAAc,EAAE,SAAS,MAAM;EAC/B,SAAS;EACT,QAAQ;EACT;CACD;EACE,MAAM;EACN,MAAM;EACN,UAAU;EACV,cAAc,EAAE,SAAS,OAAO;EAChC,SAAS;EACT,QAAQ;EACT;CACD;EAAE,MAAM;EAAS,MAAM;EAAU,QAAQ;EAAQ;CACjD;EAAE,MAAM;EAAgB,MAAM;EAAU,QAAQ;EAAW;CAC3D;EAAE,MAAM;EAAgB,MAAM;EAAU,QAAQ;EAAe;CAC/D;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,UAAU,UAAU;EACnC;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,UAAU,UAAU;EAClC,QAAQ;EACT;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,UAAU,OAAO;EAChC;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,UAAU,OAAO;EAC/B,QAAQ;EACT;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,UAAU,UAAU;EACnC;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,UAAU,UAAU;EAClC,QAAQ;EACT;CACD;EAAE,MAAM;EAAK,MAAM;EAAU,QAAQ;EAAkB;CACvD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY;GAAE,UAAU;GAAM,WAAW;GAAO;EACjD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,QAAQ;EACR,YAAY;GAAE,UAAU;GAAO,WAAW;GAAO;EAClD;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,aAAa,MAAM;EACjC,SAAS;EACV;CACD;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,aAAa,OAAO;EAClC,SAAS;EACV;CAED;EAAE,MAAM;EAAgB,MAAM;EAAU,QAAQ;EAA0B;CAC1E;EACE,MAAM;EACN,MAAM;EACN,QAAQ;EACR,YAAY,EAAE,iBAAiB,MAAM;EACtC;CAED;EACE,MAAM;EACN,MAAM;EACN,YAAY;GAAE,SAAS;GAAM,UAAU;GAAU,YAAY;GAAM;EACpE;CACD;EACE,MAAM;EACN,MAAM;EACN,YAAY;GAAE,SAAS;GAAO,UAAU;GAAU,YAAY;GAAM;EACrE;CACD;EACE,MAAM;EACN,MAAM;EACN,YAAY;GACV,SAAS;GACT,UAAU;GACV,eAAe;GACf,YAAY;GACb;EACF;CACD;EACE,MAAM;EACN,MAAM;EACN,YAAY;GACV,SAAS;GACT,UAAU;GACV,eAAe;GACf,YAAY;GACb;EACF;CACD;EACE,MAAM;EACN,MAAM;EACN,YAAY;GACV,SAAS;GACT,UAAU;GACV,YAAY;GACb;EACF;CACD;EACE,MAAM;EACN,MAAM;EACN,YAAY;GACV,SAAS;GACT,UAAU;GACV,YAAY;GACb;EACF;CAED;EAAE,MAAM;EAAK,MAAM;EAAM;CAC1B;AACD,IAAI,sBAAsB,cAAc;;;;;;;AAQxC,IAAI,sBAAsB;CACxB;EAAE,MAAM;EAAe,WAAW;EAAQ;CAC1C,EAAE,MAAM,OAAO;CACf;EAAE,MAAM;EAAQ,WAAW;EAAM;CACjC;EAAE,MAAM;EAAQ,WAAW;EAAM;CACjC;EAAE,MAAM;EAAQ,WAAW;EAAM;CACjC,EAAE,MAAM,SAAS;CACjB;EAAE,MAAM;EAAS,WAAW;EAAK;CACjC;EAAE,MAAM;EAAQ,WAAW;EAAK;CAChC;EAAE,MAAM;EAAQ,WAAW;EAAO;CAClC;EAAE,MAAM;EAAO,WAAW;EAAM;CAChC;EAAE,MAAM;EAAY,WAAW;EAAQ;CACvC;EAAE,MAAM;EAAa,WAAW;EAAQ;CACxC;EAAE,MAAM;EAAQ,WAAW;EAAO;CAClC;EAAE,MAAM;EAAc,WAAW;EAAK,eAAe;EAAM;CAC3D;EAAE,MAAM;EAAc,WAAW;EAAO;CACxC;EAAE,MAAM;EAAQ,WAAW;EAAK;CAChC;EAAE,MAAM;EAAY,WAAW;EAAQ;CACvC;EAAE,MAAM;EAAa,WAAW;EAAO,2BAA2B;EAAM;CACxE;EAAE,MAAM;EAAW,WAAW;EAAK;CACnC;EAAE,MAAM;EAAU,WAAW;EAAK;CACnC;AAED,IAAI,MAAM,WAAY;CACpB,SAAS,aAAa,IAAI;AACxB,KAAG,UAAU,gBAAgB,KAAK;AAClC,KAAG,UAAU,2BAA2B,MAAM;AAC9C,qBAAW,OAAO,IAAI,mBAAmB,EAAE,MAAM,UAAU,CAAC;AAC5D,KAAG,GAAG,kBAAkB,iBAAiB;AACzC,oBAAkB,GAAG;AAErB,KAAG,cAAc;;CAGnB,SAAS,aAAa,IAAI;AACxB,KAAG,UAAU,gBAAgB,MAAM;AACnC,KAAG,IAAI,kBAAkB,iBAAiB;AAE1C,KAAG,MAAM,MAAM;AACf,MAAI,iBAAkB,cAAa,iBAAiB;AACpD,KAAG,cAAc;;CAGnB,SAAS,aAAa,IAAI,MAAM;AAC9B,KAAG,WAAW;AACd,MAAI,QAAQA,mBAAW,OAAO,IAC5B,IAAG,QAAQ,gBAAgB;AAI7B,MAAI,CAAC,QAAQ,KAAK,UAAU,aAAc,cAAa,GAAG;;CAE5D,SAAS,aAAa,IAAI,MAAM;AAC9B,MAAI,QAAQA,mBAAW,OAAO,KAAK;AACjC,MAAG,WAAW;AACd,OAAI,GAAG,MAAO,IAAG,MAAM,mBAAmB;AAC1C,MAAG,QAAQ,gBAAgB;;AAG7B,MAAI,CAAC,QAAQ,KAAK,UAAU,aAAc,cAAa,GAAG;;AAI5D,oBAAW,aAAa,WAAW,OAAO,SAAU,IAAI,KAAK,MAAM;AACjE,MAAI,OAAO,GAAG,UAAU,SAAS,IAAI,MAAO,IAAG,UAAU,UAAU,MAAM;WAEvE,CAAC,OACD,QAAQA,mBAAW,QACnB,OAAO,KAAK,GAAG,UAAU,SAAS,CAAC,CAEnC,IAAG,UAAU,UAAU,UAAU;GACnC;CAEF,SAAS,MAAM,KAAK,IAAI;AACtB,MAAI,CAAC,GACH;AAEF,MAAI,KAAK,KACP,QAAO,KAAK;EAEd,IAAI,SAAS,cAAc,IAAI;AAC/B,MAAI,CAAC,OACH,QAAO;EAET,IAAI,MAAM,OAAO,QAAQ,IAAI,OAAO;AACpC,MAAI,OAAO,OAAO,WAChB,oBAAW,OAAO,IAAI,gBAAgB,OAAO;AAE/C,SAAO;;CAGT,IAAI,YAAY;EACd,OAAO;EACP,MAAM;EACN,KAAK;EACL,KAAK;EACL,KAAK;EACL,UAAU;EACX;CACD,IAAI,cAAc;EAChB,OAAO;EACP,WAAW;EACX,QAAQ;EACR,QAAQ;EACT;CACD,SAAS,cAAc,KAAK;AAC1B,MAAI,IAAI,OAAO,EAAE,IAAI,IAEnB,QAAO,IAAI,OAAO,EAAE;AAEtB,MAAI,QAAQ,WACV,QAAO;EAET,IAAI,SAAS,IAAI,MAAM,SAAS;EAChC,IAAI,YAAY,OAAO,OAAO,SAAS;AACvC,MAAI,OAAO,UAAU,KAAK,OAAO,GAAG,UAAU,EAE5C,QAAO;WAEP,OAAO,UAAU,KACjB,OAAO,MAAM,WACb,UAAU,UAAU,EAGpB,QAAO;EAET,IAAI,eAAe;AACnB,OAAK,IAAI,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;GACtC,IAAI,QAAQ,OAAO;AACnB,OAAI,SAAS,UACX,QAAO,KAAK,UAAU;OAEtB,gBAAe;AAEjB,OAAI,SAAS,YACX,QAAO,KAAK,YAAY;;AAG5B,MAAI,CAAC,aAEH,QAAO;AAIT,MAAI,YAAY,UAAU,CACxB,QAAO,OAAO,SAAS,KAAK,UAAU,aAAa;AAErD,SAAO,MAAM,OAAO,KAAK,IAAI,GAAG;;CAgBlC,IAAI,cAAc;CAClB,IAAI,eAAe,CACfA,mBAAW,YACX,SAAU,IAAI;AACZ,SAAO,MAAM,CAACA,mBAAW,WAAW,GAAG,IAAI,CAAC,KAAK,KAAK,GAAG;GAE5D,EACD,kBAAkB,CAChB,SAAU,IAAI;AACZ,SAAO,KAAK,KAAK,GAAG;GAEvB;CACH,SAAS,aAAa,OAAO,MAAM;EACjC,IAAI,OAAO,EAAE;AACb,OAAK,IAAI,IAAI,OAAO,IAAI,QAAQ,MAAM,IACpC,MAAK,KAAK,OAAO,aAAa,EAAE,CAAC;AAEnC,SAAO;;CAET,IAAI,oBAAoB,aAAa,IAAI,GAAG;CAC5C,IAAI,oBAAoB,aAAa,IAAI,GAAG;CAC5C,IAAI,UAAU,aAAa,IAAI,GAAG;CAClC,IAAI,aAAa,EAAE,CAAC,OAAO,mBAAmB,mBAAmB,SAAS,CACxE,KACA,IACD,CAAC;CACF,IAAI,iBAAiB,EAAE,CAAC,OACtB,mBACA,mBACA,SACA;EAAC;EAAK;EAAK;EAAK;EAAK;EAAK;EAAI,CAC/B;CACD,IAAI;AACJ,KAAI;AACF,mBAAiB,IAAI,OAAO,eAAe,IAAI;UACxC,GAAG;AACV,mBAAiB;;CAGnB,SAAS,OAAO,IAAI,MAAM;AACxB,SAAO,QAAQ,GAAG,WAAW,IAAI,QAAQ,GAAG,UAAU;;CAExD,SAAS,YAAY,GAAG;AACtB,SAAO,UAAU,KAAK,EAAE;;CAK1B,SAAS,SAAS,GAAG;AACnB,SAAO,YAAY,KAAK,EAAE;;CAE5B,SAAS,YAAY,GAAG;AACtB,SAAO,eAAe,KAAK,EAAE;;CAE/B,SAAS,mBAAmB,GAAG;AAC7B,SAAO,QAAQ,KAAK,EAAE;;CAExB,SAAS,sBAAsB,GAAG;AAChC,SAAO,MAAM,QAAQ,EAAE,IAAI;;CAE7B,SAAS,QAAQ,KAAK,KAAK;AACzB,OAAK,IAAI,IAAI,GAAG,IAAI,IAAI,QAAQ,IAC9B,KAAI,IAAI,MAAM,IACZ,QAAO;AAGX,SAAO;;CAGT,IAAI,UAAU,EAAE;CAChB,SAAS,aAAa,MAAM,cAAc,MAAM,SAAS,UAAU;AACjE,MAAI,iBAAiB,UAAa,CAAC,SACjC,OAAM,MAAM,uDAAuD;AAErE,MAAI,CAAC,KACH,QAAO;AAET,UAAQ,QAAQ;GACR;GACQ;GACJ;GACX;AACD,MAAI,QACF,MAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,QAAQ,IAClC,SAAQ,QAAQ,MAAM,QAAQ;AAGlC,MAAI,aACF,WAAU,MAAM,aAAa;;CAIjC,SAAS,UAAU,MAAM,OAAO,IAAI,KAAK;EACvC,IAAI,SAAS,QAAQ;AACrB,QAAM,OAAO,EAAE;EACf,IAAI,QAAQ,IAAI;AAChB,MAAI,CAAC,OACH,wBAAO,IAAI,MAAM,qBAAqB,KAAK;AAE7C,MAAI,OAAO,QAAQ,WACjB;OAAI,SAAS,UAAU,KACrB,wBAAO,IAAI,MAAM,uBAAuB,OAAO,MAAM,MAAM;YAClD,UAAU,MAEnB,SAAQ;;AAGZ,MAAI,OAAO,UAAU;AACnB,OAAI,UAAU,QACZ,QAAO,SAAS,OAAO,OAAU;AAEnC,OAAI,UAAU,YAAY,GACxB,QAAO,SAAS,OAAO,GAAG;SAEvB;AACL,OAAI,UAAU,QACZ,QAAO,QAAQ,OAAO,QAAQ,YAAY,CAAC,CAAC,QAAQ;AAEtD,OAAI,UAAU,YAAY,GACxB,IAAG,MAAM,IAAI,QAAQ,QAAQ,EAAS,OAAO;;;CAKnD,SAAS,UAAU,MAAM,IAAI,KAAK;EAChC,IAAI,SAAS,QAAQ;AACrB,QAAM,OAAO,EAAE;EACf,IAAI,QAAQ,IAAI;AAChB,MAAI,CAAC,OACH,wBAAO,IAAI,MAAM,qBAAqB,KAAK;AAE7C,MAAI,OAAO,UAAU;GACnB,IAAI,QAAQ,MAAM,OAAO,SAAS,QAAW,GAAG;AAChD,OAAI,UAAU,YAAY,UAAU,OAClC,QAAO;AAET,OAAI,UAAU,QACZ,QAAO,OAAO,UAAU;AAE1B;SACK;GACL,IAAI,QAAQ,UAAU,YAAY,MAAM,GAAG,MAAM,IAAI,QAAQ;AAC7D,WAAQ,SAAU,UAAU,WAAW,UAAW,EAAE,EAAE;;;AAI1D,cAAa,YAAY,QAAW,UAAU,CAAC,KAAK,EAAE,SAAU,MAAM,IAAI;AAExE,MAAI,OAAO,OACT;AAGF,MAAI,SAAS,QAAW;GACtB,IAAI,OAAO,GAAG,UAAU,OAAO;AAC/B,UAAO,QAAQ,SAAS,KAAK;SACxB;GACL,IAAI,OAAO,QAAQ,KAAK,SAAS;AACjC,MAAG,UAAU,QAAQ,KAAK;;GAE5B;CAEF,IAAI,yBAAyB,WAAY;EACvC,IAAI,OAAO;EACX,IAAI,UAAU;EACd,IAAI,OAAO;EACX,IAAI,OAAO;EACX,IAAI,SAAS,IAAI,MAAM,KAAK;EAC5B,SAAS,IAAI,IAAI,QAAQ,QAAQ;GAE/B,IAAI,UAAU,OADA,UAAU;GAExB,SAAS,YAAY,QAAQ;IAC3B,IAAI,OAAO,EAAE,UAAU;IACvB,IAAI,YAAY,OAAO;AACvB,QAAI,UACF,WAAU,OAAO;AAEnB,WAAO,QAAQ,GAAG,YAAY,OAAO;;AAEvC,OAAI,SAAS;IACX,IAAI,UAAU,QAAQ,MAAM;AAE5B,QAAI,WAAW,CAAC,YAAY,SAAS,OAAO,CAC1C,aAAY,OAAO;SAGrB,aAAY,OAAO;AAErB,eAAY,OAAO;AACnB,UAAO;AACP,UAAO,UAAU,OAAO;AACxB,OAAI,OAAO,EACT,QAAO;;EAGX,SAAS,KAAK,IAAI,QAAQ;AACxB,cAAW;AACX,OAAI,UAAU,KACZ,WAAU;YACD,UAAU,KACnB,WAAU;GAEZ,IAAI,OAAO,QAAQ,OAAO,WAAW;AAErC,OAAI,QAAQ,CAAC,KAAK,MAAM,EAAE;IACxB,IAAI,MAAM,SAAS,IAAI,IAAI;IAC3B,IAAI;IACJ,IAAI,SAAS,GAAG,WAAW;AAC3B,OAAG;AACD,gBAAW;AACX,YAAO,QAAQ,OAAO,WAAW;AAEjC,SAAI,SAAS,SAAS,KAAK,MAAM,KAAK,CAAC,YAAY,QAAQ,OAAO,CAChE;aAEK,UAAU,QAAQ,UAAU;;AAEvC,UAAO;;EAET,SAAS,KAAK,IAAI,QAAQ;GACxB,IAAI,aAAa;GACjB,IAAI,OAAO,KAAK,IAAI,OAAO;AAC3B,aAAU;AACV,UAAO,QAAQ,KAAK,MAAM;;AAE5B,SAAO;GACL,cAAc;GACT;GACC;GACA;GACP;;CAMH,IAAI,0BAA0B,SAAU,GAAG;AACzC,MAAI,EAEF,QAAO;GACL,SAAS,EAAE;GACX,+BAA+B,EAAE;GAClC;AAEH,SAAO;GAEL,SAAS,EAAE;GAEX,+BAA+B;GAChC;;CAGH,SAAS,iBAAiB;AACxB,OAAK,iBAAiB;AACtB,OAAK,YAAY;AACjB,OAAK,cAAc;AACnB,OAAK,sBAAsB,EAAE;AAC7B,OAAK,kBAAkB;AACvB,OAAK,wBAAwB,yBAAyB;;AAExD,gBAAe,YAAY;EACzB,qBAAqB,WAAY;GAC/B,IAAI,iBAAiB,eAAe;AACpC,OAAI,eAAe,gBACjB,gBAAe,iBAAiB;AAElC,kBAAe,kBAAkB;AACjC,kBAAe,cAAc;;EAE/B,sBAAsB,SAAU,IAAI,cAAc;GAChD,IAAI,WACF,eAAe,mBAAmB,YAAY,aAAa;AAC7D,OAAI,UAAU;AACZ,aAAS,OAAO;AAChB,SAAK,iBAAiB;AACtB,QAAI,GAAG,WACL,MAAK,kBAAkB,GAAG,WACxB,SAAS,eAAe,iBAAiB,eAAe,IAAI,EAC5D,MACA,EAAE,QAAQ,MAAM,CACjB;AAEH,SAAK,cAAc;;;EAGxB;CAED,SAAS,kBAAkB,IAAI;AAC7B,MAAI,CAAC,GAAG,MAAM,IAEZ,IAAG,MAAM,MAAM;GACb,YAAY,IAAI,YAAY;GAG5B,oBAAoB;GAGpB,uBAAuB;GAMvB,UAAU;GAEV,WAAW;GAGX,YAAY;GACZ,OAAO,EAAE;GACT,YAAY;GAGZ,kBAAkB;GAClB,YAAY;GAEZ,YAAY;GACZ,aAAa;GACb,eAAe;GACf,gBAAgB;GAChB,KAAK,EAAE;GAEP,SAAS,EAAE;GACZ;AAEH,SAAO,GAAG,MAAM;;CAElB,IAAI;CACJ,SAAS,sBAAsB;AAC7B,mBAAiB;GAEf,aAAa;GAEb,kBAAkB;GAElB,2BAA2B;GAC3B,UAAU,wBAAwB;GAClC,gBAAgB,IAAI,gBAAgB;GAEpC,qBAAqB;IACnB,WAAW;IACX,SAAS;IACT,mBAAmB;IACpB;GACD,oBAAoB,IAAI,mBAAmB,EAAE,CAAC;GAE9C,yBAAyB,IAAI,mBAAmB;GAEhD,4BAA4B,IAAI,mBAAmB;GACpD;AACD,OAAK,IAAI,cAAc,SAAS;GAC9B,IAAI,SAAS,QAAQ;AACrB,UAAO,QAAQ,OAAO;;;CAI1B,IAAI;CACJ,IAAI,SAAS;EACX,aAAa,WAAY;EAKzB,uBAAuB,WAAY;AACjC,UAAO,eAAe;;EAGxB,sBAAsB;EAGtB,oBAAoB,WAAY;AAC9B,UAAO;;EAIT,oBAAoB;EAEpB,sBAAsB;EAEP;EACf,KAAK,SAAU,KAAK,KAAK,KAAK;AAE5B,uBAAoB,IAAI,KAAK,KAAK,IAAI;;EAExC,OAAO,SAAU,KAAK,KAAK;AACzB,UAAO,oBAAoB,MAAM,KAAK,IAAI;;EAK5C,SAAS,SAAU,KAAK,KAAK,KAAK;GAChC,SAAS,WAAW,OAAK;AACvB,WAAOC,QAAM,CAACA,MAAI,GAAG;KAAC;KAAU;KAAU;KAAS;;GAErD,IAAI,YAAY,WAAW,IAAI;GAE/B,IAAI,eAAe,cAAc;AAEjC,QACE,IAAI,IAAI,eAFK,qBAGb,IAAI,gBAAgB,UAAU,QAC9B,KACA;IACA,IAAI,UAAU,cAAc;AAE5B,QACE,QAAQ,QAAQ,QACf,CAAC,OAAO,CAAC,QAAQ,WAAW,QAAQ,YAAY,QACjD,QAAQ,KAAK,OAAO,GAAG,EAAE,KAAK,QAC9B,QAAQ,KAAK,OAAO,GAAG,EAAE,KAAK,OAC9B;KAEA,IAAI,aAAa,EAAE;AACnB,UAAK,IAAI,OAAO,QACd,YAAW,OAAO,QAAQ;AAG5B,gBAAW,OAAO;AAClB,SAAI,OAAO,CAAC,WAAW,QACrB,YAAW,UAAU;AAGvB,UAAK,YAAY,WAAW;KAE5B,IAAI,aAAa,WAAW,QAAQ,QAAQ;AAC5C,iBAAY,UAAU,OAAO,SAAU,IAAI;AACzC,aAAO,WAAW,QAAQ,GAAG,KAAK;OAClC;;;;EAMR,UAAU,SAAU,KAAK;GAEvB,IAAI,eAAe,cAAc,QAC/B,aAAa;GACf,IAAI,aAAa,cAAc,MAAM,GAAG,eAAe,WAAW;AAClE,mBAAgB,cAAc,MAAM,eAAe,WAAW;AAC9D,OAAI,IAGF,MAAK,IAAI,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,KAAK;IAC/C,IAAI,UAAU,WAAW;AACzB,QAAI,QAAQ,QAAQ,QAClB,KAAI,QAAQ,QACV,MAAK,YAAY,QAAQ;SACpB;KAGL,IAAI,WAAW;MAAC;MAAU;MAAU;MAAS;AAC7C,UAAK,IAAI,KAAK,SACZ,KAAI,SAAS,OAAO,KAAK;MACvB,IAAI,aAAa,EAAE;AACnB,WAAK,IAAI,OAAO,QACd,YAAW,OAAO,QAAQ;AAE5B,iBAAW,UAAU,SAAS;AAC9B,WAAK,YAAY,WAAW;;;;;EAU/B;EACA;EACG;EACd,UAAU,SAAU,MAAM,QAAQ,MAAM;AACtC,OAAI,CAAC,OACH,UAAS;YACA,KAAK,QAAQ,OAAO,KAAK,EAClC,OAAM,IAAI,MACR,sBACE,SACA,6BACA,OACA,6BACH;AAEH,cAAW,QAAQ;AACnB,uBAAoB,YAAY,UAAU;IAClC;IACN,WAAW;IACX,MAAM;IACP;;EAEH,WAAW,SAAU,IAAI,KAAK,QAAQ;GACpC,IAAI,UAAU,KAAK,QAAQ,IAAI,KAAK,OAAO;AAC3C,OAAI,OAAO,YAAY,WACrB,QAAO,SAAS;;EAapB,SAAS,SAAU,IAAI,KAAK,QAAQ;GAClC,IAAI,MAAM,kBAAkB,GAAG;GAC/B,SAAS,uBAAuB;IAC9B,IAAI,iBAAiB,eAAe;AACpC,QAAI,eAAe,aAAa;AAC9B,SAAI,OAAO,KAAK;AACd,qBAAe,qBAAqB;AACpC,sBAAgB,GAAG;AACnB,aAAO;;AAET,SAAI,UAAU,UACZ,QAAO,gBAAgB,IAAI;;;GAIjC,SAAS,YAAY;AACnB,QAAI,OAAO,SAAS;AAClB,SAAI,IAAI,WAEN,gBAAe,GAAG;cACT,IAAI,WAEb,gBAAe,GAAG;SAGlB;AAEF,qBAAgB,GAAG;AACnB,YAAO;;;GAGX,SAAS,WAAW,MAAM;IAExB,IAAI;AACJ,WAAO,MAAM;AAGX,aAAQ,oBAAoB,KAAK,KAAK;AACtC,WAAM,MAAM;AACZ,YAAO,KAAK,UAAU,MAAM,QAAQ,IAAI,OAAO;AAC/C,YAAO,UAAU,IAAI,KAAK,UAAU;;;GAIxC,SAAS,sBAAsB;AAC7B,QAAI,WAAW,CACb,QAAO;IAET,IAAI,OAAQ,IAAI,WAAW,YAAY,IAAI,WAAW,YAAY;IAClE,IAAI,eAAe,IAAI,UAAU;IACjC,IAAI,QAAQ,kBAAkB,aAC5B,MACA,eACA,IAAI,YACJ,SACD;AAED,WAAO,KAAK,SAAS,KAAK,MAAM,QAAQ,QAAQ;KAC9C,IAAI,OAAQ,IAAI,WAAW,YAAY,KAAK,MAAM,EAAE;KACpD,IAAI,YAAY,kBAAkB,aAChC,MACA,eACA,IAAI,YACJ,SACD;AACD,SAAI,UAAU,QAAQ,OACpB,SAAQ;;AAGZ,QAAI,MAAM,QAAQ,QAAQ;AACxB,qBAAgB,GAAG;AACnB,YAAO;eACE,MAAM,QAAQ,WAAW;AAClC,SAAI,uBACF,QAAO,aAAa,uBAAuB;AAE7C,8BAAyB,OAAO,WAAW,WAAY;AACrD,UAAI,IAAI,cAAc,IAAI,WAAW,UACnC,iBAAgB,GAAG;QAEpB,UAAU,2BAA2B,CAAC;AACzC,YAAO,CAAC;;AAGV,QAAI,uBACF,QAAO,aAAa,uBAAuB;AAE7C,QAAI,cAAc;KAChB,IAAI,aAAa,GAAG,gBAAgB;AACpC,UAAK,IAAI,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;MAC1C,IAAI,OAAO,WAAW,GAAG;AACzB,SAAG,aACD,IACA,aAAa,MAAM,GAAG,EAAE,KAAK,SAAS,GAAG,EACzC,MACA,SACD;;AAEH,oBAAe,eAAe,sBAAsB,QAAQ,KAAK;;AAEnE,oBAAgB,GAAG;AACnB,WAAO,MAAM;;GAGf,SAAS,yBAAyB;AAChC,QAAI,sBAAsB,IAAI,WAAW,CACvC,QAAO;IAGT,IAAI,OAAQ,IAAI,WAAW,YAAY,IAAI,WAAW,YAAY;AAClE,QAAI,aAAa,KAAK,KAAK,CACzB,QAAO;IAGT,IAAI,cAAc,cAAc,KAAK,KAAK;AAC1C,QAAI,CAAC,aAAa;AAChB,qBAAgB,GAAG;AACnB,YAAO;;IAET,IAAI,UAAU,IAAI,aAAa,WAAW;IAC1C,IAAI,UAAU,YAAY,MAAM,YAAY;AAC5C,QACE,IAAI,WAAW,oBACf,IAAI,WAAW,iBAAiB,MAAM,GAAG,IAAI,QAG7C,WAAU,IAAI,WAAW;IAE3B,IAAI,QAAQ,kBAAkB,aAC5B,SACA,eACA,IAAI,YACJ,QACD;AACD,QAAI,MAAM,QAAQ,QAAQ;AACxB,qBAAgB,GAAG;AACnB,YAAO;eACE,MAAM,QAAQ,UACvB,QAAO;AAGT,QAAI,WAAW,YAAY;IAC3B,IAAI,cAAc,cAAc,KAAK,KAAK;AAC1C,QAAI,YAAY,MAAM,YAAY,MAAM,IACtC,KAAI,WAAW,gBAAgB,YAAY,GAAG;AAEhD,WAAO,MAAM;;GAGf,IAAI;AACJ,OAAI,IAAI,WACN,WAAU,qBAAqB;OAE/B,WAAU,wBAAwB;AAEpC,OAAI,YAAY,MACd,QAAO,CAAC,IAAI,cAAc,IAAI,WAAW,IACrC,WAAY;AACV,WAAO;OAET;YACK,YAAY,KAIrB,QAAO,WAAY;AACjB,WAAO;;OAGT,QAAO,WAAY;AACjB,WAAO,GAAG,UAAU,WAAY;AAC9B,QAAG,MAAM,UAAU;AACnB,SAAI;AACF,UAAI,QAAQ,QAAQ,WAClB,YAAW,QAAQ,OAAO;UAE1B,mBAAkB,eAAe,IAAI,KAAK,QAAQ;cAE7C,GAAG;AAEV,SAAG,MAAM,MAAM;AACf,wBAAkB,GAAG;AACrB,UAAI,CAAC,OAAO,qBACV,SAAQ,OAAO,EAAE;AAEnB,YAAM;;AAER,YAAO;MACP;;;EAIR,UAAU,SAAU,IAAI,OAAO;AAC7B,uBAAoB,eAAe,IAAI,MAAM;;EAGjC;EACA;EACE;EACJ;EACC;EAEG;EAEA;EACA;EACjB;CAGD,SAAS,aAAa;AACpB,OAAK,eAAe,EAAE;AACtB,OAAK,eAAe,EAAE;AAEtB,OAAK,WAAW;AAChB,OAAK,eAAe;AACpB,OAAK,SAAS;AACd,OAAK,aAAa;AAClB,OAAK,YAAY,EAAE;AACnB,OAAK,eAAe;;AAEtB,YAAW,UAAU,kBAAkB,SAAU,GAAG;AAClD,MAAI,CAAC,KAAK,SACR,MAAK,eAAe,KAAK,aAAa,OAAO,EAAE;MAE/C,MAAK,eAAe,KAAK,aAAa,OAAO,EAAE;;AAGnD,YAAW,UAAU,YAAY,WAAY;EAC3C,IAAI,SAAS;AACb,MAAI,KAAK,aAAa,SAAS,KAAK,KAAK,aAAa,SAAS,GAAG;AAChE,YAAS;AACT,OAAI,KAAK,aAAa,SAAS,EAC7B,WAAU,SAAS,KAAK,aAAa,KAAK,GAAG,EAAE,GAAG;AAEpD,OAAI,KAAK,aAAa,SAAS,EAC7B,WAAU,SAAS,KAAK,aAAa,KAAK,GAAG,EAAE,GAAG;;AAGtD,SAAO;;CAGT,SAAS,gBAAgB,IAAI,QAAQ;AACnC,KAAG,MAAM,IAAI,aAAa,IAAI,YAAY;AAC1C,qBAAW,OAAO,IAAI,oBAAoB,OAAO;;CASnD,SAAS,SAAS,MAAM,UAAU,WAAW;AAC3C,OAAK,OAAO;AACZ,OAAK,YAAY,CAAC,QAAQ,GAAG;AAC7B,OAAK,oBAAoB,EAAE;AAC3B,OAAK,gBAAgB,EAAE;AACvB,OAAK,WAAW,CAAC,CAAC;AAClB,OAAK,YAAY,CAAC,CAAC;;AAErB,UAAS,YAAY;EACnB,SAAS,SAAU,MAAM,UAAU,WAAW;AAC5C,QAAK,YAAY,CAAC,QAAQ,GAAG;AAC7B,QAAK,WAAW,CAAC,CAAC;AAClB,QAAK,YAAY,CAAC,CAAC;;EAErB,UAAU,SAAU,MAAM,UAAU;AAElC,OAAI,UAAU;AACZ,QAAI,CAAC,KAAK,SACR,MAAK,UAAU,KAAK,KAAK;AAE3B,SAAK,WAAW;;AAElB,QAAK,UAAU,KAAK,KAAK;;EAE3B,uBAAuB,SAAU,SAAS;AACxC,QAAK,kBAAkB,KAAK,wBAAwB,QAAQ,CAAC;;EAE/D,iBAAiB,SAAU,OAAO;AAChC,QAAK,cAAc,KAAK,MAAM;;EAEhC,OAAO,WAAY;AACjB,QAAK,YAAY,EAAE;AACnB,QAAK,oBAAoB,EAAE;AAC3B,QAAK,gBAAgB,EAAE;AACvB,QAAK,WAAW;;EAElB,UAAU,WAAY;AACpB,UAAO,KAAK,UAAU,KAAK,GAAG;;EAEjC;;;;;;;;CASD,SAAS,eAAe,MAAM,UAAU;EACtC,IAAI,YAAY,eAAe,mBAAmB;AAClD,MAAI,CAAC,QAAQ,KAAK,UAAU,EAC1B,OAAM,MAAM,oCAAoC;AAElD,MAAI,UAAU,MACZ,OAAM,MAAM,8BAA8B,KAAK;AAEjD,YAAU,QAAQ;AAClB,iBAAe,KAAK,KAAK;;CAW3B,SAAS,mBAAmB,WAAW;AACrC,OAAK,YAAY;AACjB,OAAK,kBAAkB,UAAU,QAAO,IAAI,UAAU;AACtD,YAAU,OAAO,IAAI,UAAU;AAC/B,YAAU,OAAO,IAAI,UAAU;AAC/B,YAAU,OAAO,IAAI,UAAU;;AAEjC,oBAAmB,YAAY;EAC7B,UAAU,SAAU,cAAc,UAAU,MAAM,UAAU,WAAW;AAErE,OAAI,iBAAiB,IAAK;AAC1B,OAAI,YAAY,KAAK,OAAO,KAAK,SAAS,EAAE,KAAK,KAC/C,SAAQ;GAIV,IAAI,WAAW,KAAK,gBAAgB,aAAa,GAC7C,KAAK,YAAY,aAAa,GAC9B;AAGJ,OAAI,CAAC,UAAU;AACb,YAAQ,UAAR;KACE,KAAK;AAEH,WAAK,UAAU,OAAO,IAAI,SAAS,MAAM,UAAU,UAAU;AAC7D;KACF,KAAK;KACL,KAAK;AACH,UAAI,KAAK,QAAQ,KAAK,IAAI,GAExB,MAAK,UAAU,OAAO,IAAI,SAAS,MAAM,SAAS;WAC7C;AAGL,YAAK,wBAAwB;AAC7B,YAAK,UAAU,OAAO,IAAI,SAAS,MAAM,SAAS;;AAEpD;;AAGJ,SAAK,gBAAgB,QAAQ,MAAM,UAAU,UAAU;AACvD;;AAKF,OADa,YAAY,aAAa,CAEpC,UAAS,SAAS,MAAM,SAAS;OAEjC,UAAS,QAAQ,MAAM,UAAU,UAAU;AAI7C,QAAK,gBAAgB,QAAQ,SAAS,UAAU,EAAE,SAAS;;EAI7D,aAAa,SAAU,MAAM;AAC3B,OAAI,CAAC,KAAK,gBAAgB,KAAK,CAC7B,QAAO,KAAK;AAEd,UAAO,KAAK,aAAa;AACzB,OAAI,CAAC,KAAK,UAAU,MAClB,MAAK,UAAU,QAAQ,IAAI,UAAU;AAEvC,UAAO,KAAK,UAAU;;EAExB,iBAAiB,SAAU,MAAM;AAC/B,UAAO,QAAQ,QAAQ,MAAM,eAAe;;EAE9C,wBAAwB,WAAY;AAClC,QAAK,IAAI,IAAI,GAAG,KAAK,GAAG,IACtB,MAAK,UAAU,KAAK,KAAK,YAAY,MAAM,IAAI,GAAG;;EAGvD;CACD,SAAS,oBAAoB;AAC3B,OAAK,gBAAgB,EAAE;AACvB,OAAK,WAAW;AAChB,OAAK,gBAAgB;;AAEvB,mBAAkB,YAAY;EAG5B,WAAW,SAAU,OAAO,IAAI;GAC9B,IAAI,gBAAgB,KAAK;GACzB,IAAI,MAAM,KAAK,KAAK;AACpB,OAAI,KAAK,kBAAkB,KAAM,MAAK,gBAAgB;AACtD,QACE,IAAI,IAAI,KAAK,WAAW,KACxB,KAAK,KAAK,IAAI,IAAI,cAAc,QAChC,KAAK,KACL;IACA,IAAI,UAAU,cAAc;AAC5B,SAAK,IAAI,IAAI,GAAG,KAAK,QAAQ,QAAQ,IACnC,KAAI,KAAK,iBAAiB,QAAQ,UAAU,GAAG,EAAE,EAAE;AACjD,UAAK,WAAW;AAChB,YAAO;;;AAKb,OAAI,KAAK,cAAc,QAAQ;AAC7B,SAAK,WAAW,cAAc;AAC9B,WAAO,KAAK;;AAGd,OAAI,IAAI,EAAG,QAAO;;EAEpB,WAAW,SAAU,OAAO;GAC1B,IAAI,QAAQ,KAAK,cAAc,QAAQ,MAAM;AAC7C,OAAI,QAAQ,GAAI,MAAK,cAAc,OAAO,OAAO,EAAE;AACnD,OAAI,MAAM,OAAQ,MAAK,cAAc,KAAK,MAAM;;EAElD,OAAO,WAAY;AACjB,QAAK,gBAAgB;AACrB,QAAK,WAAW,KAAK,cAAc;;EAEtC;CACD,IAAI,oBAAoB;EACtB,cAAc,SAAU,MAAM,QAAQ,YAAY,SAAS;GACzD,IAAI,UAAU,eAAe,MAAM,QAAQ,SAAS,WAAW;AAC/D,OAAI,CAAC,QAAQ,QAAQ,CAAC,QAAQ,QAC5B,QAAO,EAAE,MAAM,QAAQ;YACd,CAAC,QAAQ,QAAQ,QAAQ,QAClC,QAAO,EAAE,MAAM,WAAW;GAG5B,IAAI;AACJ,QAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK,QAAQ,KAAK;IAC5C,IAAI,QAAQ,QAAQ,KAAK;AACzB,QAAI,CAAC,UACH,aAAY;;AAGhB,OAAI,UAAU,KAAK,MAAM,IAAI,IAAI,eAAe;IAC9C,IAAI,YAAY,SAAS,KAAK;AAC9B,QAAI,CAAC,UAAW,QAAO,EAAE,MAAM,QAAQ;AACvC,eAAW,oBAAoB;;AAEjC,UAAO;IAAE,MAAM;IAAQ,SAAS;IAAW;;EAE7C,gBAAgB,SAAU,IAAI,KAAK,SAAS;AAC1C,OAAI,WAAW,iBAAiB,QAAQ;AACxC,WAAQ,QAAQ,MAAhB;IACE,KAAK;AACH,UAAK,cAAc,IAAI,KAAK,QAAQ;AACpC;IACF,KAAK;AACH,UAAK,gBAAgB,IAAI,KAAK,QAAQ;AACtC;IACF,KAAK;AACH,UAAK,sBAAsB,IAAI,KAAK,QAAQ;AAC5C;IACF,KAAK;AACH,UAAK,cAAc,IAAI,KAAK,QAAQ;AACpC;IACF,KAAK;AACH,UAAK,cAAc,IAAI,KAAK,QAAQ;AACpC;IACF,KAAK;IACL,KAAK;AACH,UAAK,UAAU,IAAI,KAAK,QAAQ;AAChC;IACF,QACE;;;EAGN,eAAe,SAAU,IAAI,KAAK,SAAS;AACzC,OAAI,WAAW,SAAS,QAAQ;AAChC,OAAI,WAAW,aAAa,SAAS,QAAQ,WAAW;AACxD,QAAK,UAAU,IAAI,IAAI;;EAEzB,iBAAiB,SAAU,IAAI,KAAK,SAAS;GAC3C,IAAI,aAAa,IAAI;AACrB,OAAI,WAAW,SACb,KAAI,WAAW,YAAY,QAAQ,UAAU;AAG3C,eAAW,SAAS;AACpB,eAAW,aAAa,EAAE,UAAU,MAAM;AAC1C,SAAK,UAAU,IAAI,IAAI;AACvB;SAGA,iBAAgB,GAAG;AAGvB,cAAW,WAAW,QAAQ;AAC9B,cAAW,eAAe,SAAS,QAAQ,aAAa;AACxD,OAAI,QAAQ,KAAK,SAAS,EACxB,YAAW,mBAAmB,QAAQ;AAExC,OAAI,QAAQ,iBAAiB;AAC3B,QAAI,cAAc;AAClB,sBAAkB,GAAG;;AAEvB,OAAI,IAAI,WAEN,MAAK,UAAU,IAAI,IAAI;;EAG3B,uBAAuB,SAAU,IAAI,KAAK,SAAS;GACjD,IAAI,aAAa,IAAI;GACrB,IAAI,qBAAqB,SAAS,QAAQ,mBAAmB;AAC7D,OAAI,oBAEF;QAAI,cAAc,mBAAmB,WACnC,KAAI,aAAa;;AAGrB,QAAK,gBAAgB,IAAI,KAAK,QAAQ;AACtC,OAAI,CAAC,WACH,MAAK,cAAc,IAAI,KAAK,QAAQ;;EAGxC,eAAe,SAAU,IAAI,KAAK,SAAS;GACzC,IAAI,aAAa,IAAI;GACrB,IAAI,SAAS,WAAW,WAAW;GACnC,IAAI,mBAAmB,CAAC,CAAC;GACzB,IAAI,aAAa,SAAS,QAAQ,WAAW,IAAI,EAAE;AACnD,OAAI,WAAW,kBACb,YAAW,oBAAoB,WAAW;AAG5C,OAAI,QAAQ,SACV,MAAK,gBAAgB,IAAI,KAAK,QAAQ;AAExC,OAAI,QAAQ,OACV,MAAK,cAAc,IAAI,KAAK,QAAQ;AAEtC,OAAI,QAAQ,UAAU,QAAQ,SAC5B,MAAK,UAAU,IAAI,IAAI;AAEzB,cAAW,SAAS,UAAU;AAC9B,cAAW,mBAAmB;AAC9B,cAAW,eAAe,WAAW;AACrC,mBAAgB,GAAG;AACnB,OAAI,aAAa;AACjB,OAAI,QAAQ,OACV,MAAK,eAAe,KAAK,YAAY,QAAQ;AAE/C,WAAQ,QAAQ,QAAQ,IAAI,YAAY,IAAI;;EAE9C,eAAe,SAAU,IAAI,KAAK,SAAS;AACzC,OAAI,CAAC,GAAG,gBAEN;GAEF,IAAI,UAAU,QAAQ,WAAW;GACjC,IAAI,gBAAgB,QAAQ,WAAW;AACvC,kBAAe,GAAG,CAAC,YAAY,CAAC,QAAQ;GACxC,IAAI,eAAe,UAAU,MAAM;GACnC,IAAI,gBAAgB,eAAe,GAAG,CAAC,UAAU;GACjD,IAAI,oBAAoB,GAAG,eAAe;GAC1C,SAAS,YAAY,SAAO,YAAY,WAAW;AACjD,mBAAe,wBAAwB,UAAUC,QAAM;AACvD,mBAAe,wBAAwB,OAAO;AAC9C,QAAI;AACF,uBAAkB,IAAIA,SAAO,YAAY,UAAU;aAC5C,GAAG;AACV,iBAAY,IAAI,oBAAoBA,QAAM;AAC1C,qBAAgB,GAAG;AACnB;;AAEF,sBAAkB,cAAc,IAAI,KAAK;KACvC,MAAM;KACN,QAAQ;KACR,YAAY;MACV,SAAS;MACT,YAAY,QAAQ,WAAW;MAChC;KACF,CAAC;;GAEJ,SAAS,cAAc,SAAO;AAC5B,OAAG,SAAS,kBAAkB,MAAM,kBAAkB,IAAI;AAC1D;KAAYA;KAAO;KAAwB;;KAAsB;IACjE,IAAIC,mBAAiB,eAAe;AACpC,QAAIA,iBAAe,YACjB,gBAAeA,kBAAgBD,QAAM;;GAGzC,SAAS,cAAc,GAAG,SAAO,OAAO;IACtC,IAAI,UAAUF,mBAAW,QAAQ,EAAE,EACjC,IACA;AACF,QAAI,WAAW,QAAQ,WAAW,QAAQ;AACxC,UAAK,WAAW,OAAO,OAAO;AAC9B,cAAS,EAAE,SAAS,EAAE,OAAO,eAAe;AAC5C,eACE,eAAe,wBAAwB,UAAUE,SAAO,GAAG,IAAI;AACjE,WAAMA,QAAM;AACZ,SAAI,UAAU,EAAE,OACd,GAAE,OAAO,eAAe,EAAE,OAAO,iBAAiB,KAAK,IACrD,QACA,EAAE,OAAO,MAAM,OAChB;eAGD,WAAW,UACX,WAAW,WACX,WAAW,UACX,WAAW,SACX,WAAW,QAEX,gBAAe,wBAAwB,OAAO;IAElD,IAAI;AACJ,QAAI;AACF,mBAAc,kBACZ,IACAA,SACA,MACA,KACD;aACME,KAAG;AAGZ,QAAI,YACF,IAAG,eAAe,SAAS,IAAI,CAAC,SAAS,YAAY,EAAE,GAAG;SACrD;AACL,0BAAqB,GAAG;AACxB,QAAG,SAAS,kBAAkB,MAAM,kBAAkB,IAAI;;;GAG9D,SAAS,gBAAgB,GAAG,SAAO,OAAO;IACxC,IAAI,UAAUJ,mBAAW,QAAQ,EAAE;AACnC,QACE,WAAW,SACX,WAAW,YACX,WAAW,YACV,WAAW,eAAeE,WAAS,IACpC;AACA,oBAAe,wBAAwB,UAAUA,QAAM;AACvD,oBAAe,wBAAwB,OAAO;AAC9C,uBAAkB,IAAI,cAAc;AACpC,0BAAqB,GAAG;AACxB,QAAG,SAAS,kBAAkB,MAAM,kBAAkB,IAAI;AAC1D,wBAAW,OAAO,EAAE;AACpB,qBAAgB,GAAG;AACnB,YAAO;AACP,QAAG,OAAO;eACD,WAAW,QAAQ,WAAW,OACvC,oBAAW,OAAO,EAAE;aACX,WAAW,UAAU;AAE9B,wBAAW,OAAO,EAAE;AACpB,WAAM,GAAG;;;AAGb,WAAQ,QAAQ,WAAW,UAA3B;IACE,KAAK;KACH,IAAI,iBAAiB,eAAe;AACpC,SAAI,eAAe,WAAW;MAC5B,IAAI,QAAQ,eAAe,oBAAoB,OAAO;AACtD;OAAY;OAAO;OAAwB;;OAAuB;WAElE,YAAW,IAAI;MACb,SAAS;MACT,QAAQ;MACR,MAAM;MACN,SAAS;MACT,WAAW;MACZ,CAAC;AAEJ;IACF,KAAK;KACH,IAAI,OAAO,sBACT,IACA,OACA,MACA,OACA,KACD;KACD,IAAI,YAAY;AAChB,SAAI,CAAC,MAAM;AACT,aAAO,sBACL,IACA,OACA,MACA,OACA,MACD;AACD,kBAAY;;AAEd,SAAI,CAAC,KACH;KAEF,IAAI,QAAQ,GACT,QAAQ,KAAK,MAAM,KAAK,CACxB,UAAU,KAAK,MAAM,IAAI,KAAK,IAAI,GAAG;AACxC,SAAI,aAAa,cACf,SAAQ,QAAQ,QAAQ;SAExB,SAAQ,YAAY,MAAM;AAM5B,oBAAe,SAAS,eAAe,GAAG,WAAW;AACrD,QAAG,UAAU,KAAK,MAAM;AAExB;MAAY;MAAO;MAAwB;;MAAuB;AAClE;;;EAGN,WAAW,SAAU,IAAI,KAAK,SAAS;GACrC,SAAS,cAAc,OAAO;AAG5B,mBAAe,2BAA2B,UAAU,MAAM;AAC1D,mBAAe,2BAA2B,OAAO;AACjD,wBAAoB,eAAe,IAAI,MAAM;;GAE/C,SAAS,gBAAgB,GAAG,OAAO,OAAO;IACxC,IAAI,UAAUF,mBAAW,QAAQ,EAAE,EACjC,IACA;AACF,QACE,WAAW,SACX,WAAW,YACX,WAAW,YACV,WAAW,eAAe,SAAS,IACpC;AACA,oBAAe,2BAA2B,UAAU,MAAM;AAC1D,oBAAe,2BAA2B,OAAO;AACjD,wBAAW,OAAO,EAAE;AACpB,qBAAgB,GAAG;AACnB,YAAO;AACP,QAAG,OAAO;;AAEZ,QAAI,WAAW,QAAQ,WAAW,QAAQ;AACxC,wBAAW,OAAO,EAAE;AACpB,UAAK,WAAW,OAAO,OAAO;AAC9B,cAAS,EAAE,SAAS,EAAE,OAAO,eAAe;AAC5C,aACE,eAAe,2BAA2B,UAAU,OAAO,GAAG,IAC9D;AACF,WAAM,MAAM;AACZ,SAAI,UAAU,EAAE,OACd,GAAE,OAAO,eAAe,EAAE,OAAO,iBAAiB,KAAK,IACrD,QACA,EAAE,OAAO,MAAM,OAChB;eACM,WAAW,UAAU;AAE9B,wBAAW,OAAO,EAAE;AACpB,WAAM,GAAG;eAGP,WAAW,UACX,WAAW,WACX,WAAW,UACX,WAAW,SACX,WAAW,QAEX,gBAAe,2BAA2B,OAAO;;AAGvD,OAAI,QAAQ,QAAQ,UAElB,qBAAoB,eAAe,IAAI,QAAQ,OAAO,MAAM;YAExD,IAAI,WACN,YAAW,IAAI;IACb,SAAS;IACT,QAAQ;IACR,OAAO;IACP,WAAW;IACX,mBAAmB;IACpB,CAAC;OAEF,YAAW,IAAI;IACb,SAAS;IACT,QAAQ;IACR,WAAW;IACZ,CAAC;;EAIR,WAAW,SAAU,IAAI,KAAK;GAG5B,IAAI,aAAa,IAAI;GACrB,IAAI,SAAS,WAAW;GACxB,IAAI,aAAa,WAAW,cAAc,EAAE;GAC5C,IAAI,WAAW,WAAW;GAC1B,IAAI,eAAe,WAAW,gBAAgB,EAAE;GAChD,IAAI,eAAe,WAAW;GAC9B,IAAI,MAAM,IAAI;GAEd,IAAI,WAAW,WACb,IAAI,aACA,oBAAoB,IAAI,IAAI,KAAK,GACjC,GAAG,UAAU,OAAO,CACzB;GACD,IAAI,aAAa,WACf,IAAI,aACA,oBAAoB,IAAI,IAAI,OAAO,GACnC,GAAG,UAAU,SAAS,CAC3B;GACD,IAAI,UAAU,WAAW,SAAS;GAClC,IAAI,YAAY,WAAW,WAAW;GACtC,IAAI,SAAS;GACb,IAAI;AACJ,OAAI,SACF,MAAK,eAAe,KAAK,WAAW;AAEtC,OAAI,WAAW,mBAAmB,OAGhC,UAAS,WAAW;OAEpB,UAAS,WAAW,WAAW;AAEjC,OAAI,SAAS,KAAK,WAAW,eAC3B,YAAW,mBAAmB;YAE9B,WAAW,YACV,CAAC,WAAW,kBAAkB,WAAW,GAC1C;AACA,aAAS;AACT,eAAW,mBAAmB;;AAEhC,OAAI,WAAW,kBAEb,YAAW,oBAAoB,aAAa,oBAC1C,WAAW;AAEf,cAAW,SAAS;AACpB,mBAAgB,GAAG;AACnB,OAAI,QAAQ;IACV,IAAI,eAAe,QAAQ,QACzB,IACA,UACA,YACA,KACA,WACD;AACD,QAAI,aAAa,QAAQ;AACzB,QAAI,CAAC,aACH;AAEF,QAAI,WAAW,YAAY;KACzB,IAAI,WAAW,eAAe;KAE9B,IAAI,eAAe,SAAS;AAC5B,SAAI,cAAc;AAChB,yBAAmB,IAAI,cAAc,aAAa;AAClD,aAAO,SAAS;WAEhB,oBAAmB,IAAI,UAAU,aAAa;;AAGlD,QAAI,wBAAwB,OAAO;AACjC,iBAAY,aAAa;AACzB,eAAU,aAAa;UAEvB,WAAU;AAGZ,QAAI,CAAC,QACH,WAAU,WAAW,SAAS;AAEhC,QAAI,IAAI,YAAY;AAClB,SAAI,EAAE,IAAI,eAAe,QAAQ,OAAO,UACtC,WAAU,oBAAoB,IAAI,QAAQ;AAE5C,SAAI,UACF,aAAY,oBAAoB,IAAI,UAAU;AAEhD,iBAAY,aAAa;AACzB,SAAI,SAAS;AACb,SAAI,OAAO;AACX,uBAAkB,GAAG;AACrB,gBACE,IACA,KACA,KACA,eAAe,WAAW,QAAQ,GAAG,YAAY,QAClD;AACD,gBACE,IACA,KACA,KACA,eAAe,WAAW,QAAQ,GAAG,UAAU,UAChD;eACQ,CAAC,UAAU;AACpB,eAAU,oBAAoB,IAAI,QAAQ;AAC1C,QAAG,UAAU,QAAQ,MAAM,QAAQ,GAAG;;;AAG1C,OAAI,UAAU;AACZ,QAAI,aAAa,SAAS;AAExB,iBAAY;KACZ,IAAI,UAAU,aAAa;KAC3B,IAAI,aAAa,KAAK,IAAI,QAAQ,KAAK,OAAO,QAAQ,OAAO,KAAK;KAClE,IAAI,WAAW,KAAK,IAAI,QAAQ,KAAK,KAAK,QAAQ,OAAO,GAAG;AAC5D,SAAI,QAAQ,WAEV,WAAU,IAAI,IAAI,UAAU,OAAO,YAAY,UAAU,GAAG;cACnD,QAAQ,YAEjB,WAAU,IAAI,IACZ,UAAU,OAAO,YACjB,UAAU,KAAK,SAChB;cACQ,QAAQ,KAAK,QAAQ,QAAQ,OAAO,KAE7C,WAAU,IAAI,IAAI,UAAU,MAAM,UAAU,KAAK,SAAS;SAI1D,WAAU,IAAI,IAAI,UAAU,OAAO,YAAY,UAAU,GAAG;AAE9D,SAAI,aAAa;AACjB,SAAI,aAAa,QAAQ;AACzB,SAAI,cAAc,QAAQ;AAC1B,WAAM,IAAI,MAAM;MACd,QAAQ;MACR,MAAM;MACP;AACD,uBAAkB,GAAG;eACZ,IAAI,WACb,cAAa,UAAU;KACrB,QAAQ,WAAW,IAAI,OAAO;KAC9B,MAAM,WAAW,IAAI,KAAK;KAC1B,aAAa,IAAI;KACjB,YAAY,IAAI;KACjB;IAEH,IAAI,UAAU,QAAQ,UAAU;IAChC,IAAI;AACJ,QAAI,IAAI,YAAY;AAElB,gBAAW,UAAU,IAAI,MAAM,IAAI,OAAO;AAC1C,cAAS,UAAU,IAAI,MAAM,IAAI,OAAO;AACxC,gBAAW,IAAI,cAAc,aAAa;AAC1C,YAAO,IAAI,cAAc,UAAU,WAAW,SAAS;AACvD,aAAQ,gBACN,IACA;MACE,QAAQ;MACR,MAAM;MACP,EACD,KACD;AACD,SAAI,UAAU;MACZ,IAAI,SAAS,MAAM;AACnB,UAAI,QAAQ,QAEV,MAAK,IAAI,IAAI,GAAG,IAAI,OAAO,QAAQ,IACjC,QAAO,GAAG,KAAK,KAAK,WAAW,IAAI,OAAO,GAAG,KAAK,KAAK;eAEhD,QAAQ,OACjB,QAAO,GAAG,OAAO,IAAI,IAAI,OAAO,GAAG,KAAK,OAAO,GAAG,EAAE;;WAGnD;AAEL,gBAAW,WAAW,aAAa,UAAU;AAC7C,cAAS,WAAW,WAAW,QAAQ;AACvC,SAAI,eAAe,QAAQ,SAAS,EAAE;MACpC,IAAI,MAAM;AACV,iBAAW;AACX,eAAS;;AAEX,gBAAW,WAAW,YAAY,aAAa;AAC/C,SAAI,SAEF,uBAAsB,IAAI,UAAU,OAAO;cAClC,WAAW,QAEpB,YAAW,IAAI,UAAU,OAAO;AAElC,YAAO;KACP,IAAI,YAAY,CAAC,WAAW,aAAa;AACzC,aAAQ,gBACN,IACA;MACE,QAAQ;MACR,MAAM;MACP,EACD,MACA,UACD;;AAEH,OAAG,cAAc,MAAM,QAAQ,MAAM,QAAQ;AAC7C,QAAI,aAAa;AACjB,iBAAa,SAAS;AACtB,iBAAa,eAAe;AAE5B,iBAAa,WAAW;IACxB,IAAI,iBAAiB,UAAU,UAC7B,IACA,cACA,MAAM,QACN,WACA,QACD;AACD,QAAI,IAAI,WACN,gBAAe,IAAI,kBAAkB,KAAK;AAE5C,QAAI,eACF,IAAG,UAAU,eAAe;;;EAIlC,gBAAgB,SAAU,KAAK,YAAY,eAAe;GACxD,IAAI,iBAAiB,eAAe;AACpC,OAAI,eAAe,UACjB;AAEF,OAAI,qBAAqB;AACzB,OAAI,wBAAwB;AAC5B,kBAAe,sBAAsB,UAAU,EAAE;AACjD,kBAAe,sBAAsB,gCAAgC;AACrE,kBAAe,sBAAsB,cAAc,IAAI,cACnD,IAAI,IAAI,KAAK,OAAO,IAAI,IAAI,OAAO,OACnC;;EAEP;;;;;CAOD,IAAI,UAAU;EACZ,eAAe,SAAU,IAAI,OAAO,YAAY;GAC9C,IAAI,OAAO,oBAAoB,GAAG,CAAC,MAAM,WAAW,SAAS;AAC7D,UAAO,IAAI,IAAI,MAAM,gCAAgC,GAAG,QAAQ,KAAK,CAAC,CAAC;;EAEzE,kBAAkB,SAAU,IAAI;GAC9B,IAAI,QAAQ,oBAAoB,GAAG;GACnC,IAAI,OAAO,KAAK,OAAO,MAAM,MAAM,MAAM,UAAU,GAAI;AACvD,UAAO,IAAI,IAAI,MAAM,gCAAgC,GAAG,QAAQ,KAAK,CAAC,CAAC;;EAEzE,kBAAkB,SAAU,IAAI,OAAO,YAAY;GACjD,IAAI,OAAO,oBAAoB,GAAG,CAAC,SAAS,WAAW,SAAS;AAChE,UAAO,IAAI,IAAI,MAAM,gCAAgC,GAAG,QAAQ,KAAK,CAAC,CAAC;;EAEzE,cAAc,SAAU,KAAK,MAAM,YAAY;AAI7C,UAAO,IAAI,IADD,KACS,OAAO,WAAW,SAAS,GAAG,SAAS;;EAE5D,UAAU,SAAU,IAAI,OAAO,YAAY;GACzC,IAAI,QAAQ,eAAe,GAAG;GAC9B,IAAI,QAAQ,MAAM,UAAU;AAC5B,OAAI,CAAC,MACH;GAEF,IAAI,OAAO,CAAC,WAAW;AAEvB,UAAO,MAAM,YAAY,GAAG,CAAC,OAAO;AACpC,0BAAuB,IAAI,MAAM;AACjC,UAAO,SAAS,IAAI,MAAkB,OAAO,WAAW,OAAO;;EAcjE,4BAA4B,SAC1B,IACA,OACA,YACA,KACA,gBACA;GACA,IAAI,QAAQ,eAAe,GAAG;GAC9B,IAAI,QAAQ,MAAM,UAAU;AAE5B,OAAI,CAAC,MACH;GAGF,IAAI,OAAO,CAAC,WAAW;AACvB,UAAO,MAAM,YAAY,GAAG,CAAC,OAAO;GAGpC,IAAI,OAAO,2BACT,IACA,MACA,OACA,WAAW,QACX,IACD;AAGD,OAAI,CAAC,KACH;AAIF,OAAI,eAAe,SACjB,QAAO;GAMT,IAAI,OAAO,KAAK;GAIhB,IAAI,KAAK,IAAI,IAAI,KAAK,GAAG,MAAM,KAAK,GAAG,KAAK,EAAE;AAE9C,OAAI,IAAI,YAAY;AAElB,QAAI,IAAI,cAAc,IAAI,aAAa;AACrC,SAAI,aAAa;AACjB,SAAI,cAAc;AAClB,wBAAW,OAAO,IAAI,mBAAmB;MACvC,MAAM;MACN,SAAS;MACV,CAAC;;IAKJ,IAAI,SAAS,IAAI,IAAI;AACrB,QAAI,OACF,KAAI,MAAM,YAAY,EAAE;AACtB,SAAI,WAAW,QACb,QAAO,CAAC,QAAQ,KAAK;AAGvB,YAAO,CAAC,QAAQ,GAAG;WACd;AACL,SAAI,WAAW,QACb,QAAO,CAAC,QAAQ,GAAG;AAGrB,YAAO,CAAC,QAAQ,KAAK;;UAGpB;AAEL,QAAI,aAAa;AACjB,QAAI,aAAa;AACjB,QAAI,cAAc;AAClB,uBAAW,OAAO,IAAI,mBAAmB;KACvC,MAAM;KACN,SAAS;KACV,CAAC;;AAGJ,UAAO,OAAO,CAAC,IAAI,KAAK,GAAG,CAAC,MAAM,GAAG;;EAEvC,UAAU,SAAU,IAAI,OAAO,YAAY,KAAK;GAC9C,IAAI,MAAM,WAAW,IAAI,KAAK,WAAW,kBAAkB;AAC3D,OAAI,IACF,QAAO,WAAW,WACd;IACE,MAAM,IAAI;IACV,IAAI,gCAAgC,GAAG,QAAQ,IAAI,KAAK,CAAC;IAC1D,GACD;AAEN,UAAO;;EAET,2BAA2B,SAAU,IAAI,OAAO,YAAY,KAAK;AAC/D,OAAI,IAAI,eAAe,WAAW,UAAU;IAC1C,IAAI,MAAM,IAAI;AACd,WAAO,CACL,oBAAoB,IAAI,IAAI,IAAI,IAAI,OAAO,MAAM,IAAI,KAAK,GAAG,CAAC,EAC9D,oBAAoB,IAAI,IAAI,IAAI,IAAI,KAAK,MAAM,IAAI,OAAO,GAAG,CAAC,CAC/D;SAED,QAAO,CAAC,IAAI,IAAI,MAAM,IAAI,IAAI,OAAO;;EAGzC,YAAY,SAAU,IAAI,MAAM,YAAY,KAAK;GAC/C,IAAI,OAAO;AACX,QAAK,IAAI,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;IAC1C,IAAI,SAAS;AACb,SAAK,IAAI,OAAO,IAAI,OAAO;AACzB,SAAI,CAAC,YAAY,IAAI,CACnB;KAEF,IAAI,OAAO,IAAI,MAAM,KAAK,MAAM;AAKhC,SAJuB,WAAW,UAC9B,eAAe,MAAM,OAAO,GAC5B,eAAe,QAAQ,KAAK,CAG9B;AAEF,SAAI,WAAW,YAAY,KAAK,QAAQ,OAAO,KAC7C;KAGF,IAAI,QAAQ,YAAY,QAAQ,KAAK;KACrC,IAAI,UAAU,WAAW,UACrB,gBAAgB,QAAQ,MAAM,KAAK,GACnC,gBAAgB,MAAM,MAAM,OAAO;AAEvC,SAAI,SAAS,QACX,QAAO;;;AAKb,OAAI,WAAW,SAIb,QAAO,IAAI,IACT,KAAK,MACL,gCAAgC,GAAG,QAAQ,KAAK,KAAK,CAAC,CACvD;AAEH,UAAO;;EAET,kBAAkB,SAAU,KAAK,MAAM,YAAY;GACjD,IAAI,MAAM;GACV,IAAI,SAAS,WAAW;GACxB,IAAI,KAAK,WAAW,UAAU,IAAI,KAAK,SAAS,IAAI,KAAK;AACzD,UAAO,IAAI,IAAI,IAAI,MAAM,GAAG;;EAE9B,aAAa,SAAU,IAAI,MAAM,YAAY,KAAK;GAChD,IAAI,MAAM;GACV,IAAI,QAAQ,IAAI;AAMhB,WAAQ,IAAI,YAAZ;IACE,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,KAAK;AACR,aAAQ,IAAI;AACZ;IACF,QACE,KAAI,WAAW;;GAEnB,IAAI,SAAS,WAAW,UAAU,WAAW,gBAAgB;GAC7D,IAAI,OAAO,WAAW,UAAU,IAAI,OAAO,SAAS,IAAI,OAAO;GAC/D,IAAI,QAAQ,GAAG,WAAW;GAC1B,IAAI,OAAO,GAAG,UAAU;GACxB,IAAI,OAAO,GAAG,SACZ,KACA,WAAW,UAAU,SAAS,CAAC,QAC/B,QACA,IAAI,UACL;AAID,OAHoB,WAAW,UAC3B,KAAK,OAAO,OACZ,KAAK,OAAO,MACG;AACjB,WAAO,KAAK;AACZ,YAAQ,KAAK;;AAIf,OAAI,OAAO,SAAS,IAAI,QAAQ,MAC9B,QAAO,KAAK,kBAAkB,IAAI,MAAM,YAAY,IAAI;YAC/C,OAAO,QAAQ,IAAI,QAAQ,KACpC,QAAO,UAAU,IAAI,MAAM,YAAY,KAAK,KAAK;AAEnD,OAAI,WAAW,aAAa;AAC1B,YAAQ,gCAAgC,GAAG,QAAQ,KAAK,CAAC;AACzD,QAAI,WAAW;;AAEjB,OAAI,YAAY,GAAG,WAAW,IAAI,IAAI,MAAM,MAAM,EAAE,MAAM,CAAC;AAC3D,UAAO,IAAI,IAAI,MAAM,MAAM;;EAE7B,oBAAoB,SAAU,IAAI,MAAM,YAAY,KAAK;GACvD,IAAI,MAAM;AACV,WAAQ,IAAI,YAAZ;IACE,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,KAAK;IACV,KAAK,KAAK,UACR;IACF,QACE,KAAI,YAAY,GAAG,WAAW,KAAK,MAAM,CAAC;;GAE9C,IAAI,SAAS,WAAW;GACxB,IAAI,MAAM,GAAG,SACX,KACA,WAAW,UAAU,SAAS,CAAC,QAC/B,QACA,IAAI,UACL;AACD,OAAI,IAAI,QACN,KAAI,WAAW,SAAS;IAEtB,IAAI,aAAa;KAAE,KADE,GAAG,WAAW,KAAK,MAAM,CACP,MAAM;KAAG,MAAM,IAAI;KAAW;IACrE,IAAI,MAAM,GAAG,WAAW,YAAY,MAAM;UACrC;IACL,IAAI,YAAY,GAAG,WAAW,IAAI,IAAI,GAAG,WAAW,EAAE,EAAE,EAAE,MAAM;AAChE,cAAU,OAAO,IAAI;AACrB,UAAM,GAAG,WAAW,WAAW,MAAM;;AAGzC,OAAI,WAAW,IAAI;AACnB,UAAO;;EAET,YAAY,SAAU,IAAI,MAAM,YAAY;GAI1C,IAAI,WAAW;GACf,IAAI,SAAS,WAAW;AACxB,UAAO,GAAG,SACR,UACA,WAAW,UAAU,SAAS,CAAC,QAC/B,OACD;;EAEH,iBAAiB,SAAU,IAAI,MAAM,YAAY;GAC/C,IAAI,MAAM,WAAW,UAAU,IAAI;AACnC,UAAO,cAAc,IAAI,MAAM,WAAW,QAAQ,IAAI;;EAExD,gBAAgB,SAAU,IAAI,MAAM,YAAY;GAC9C,IAAI,MAAM,WAAW,UAAU,IAAI;AACnC,UAAO,aAAa,IAAI,MAAM,WAAW,QAAQ,IAAI;;EAEvD,cAAc,SAAU,IAAI,MAAM,YAAY,KAAK;GACjD,IAAI,YAAY,GAAG,eAAe;GAClC,IAAI,SAAS;GACb,IAAI,SAAS,WAAW;AACxB,OAAI,CAAC,OACH,UAAS,UAAU,gBAAgB,IAAI,GAAG,mBAAmB;GAE/D,IAAI,OAAO,GAAG,WAAW,MAAM,QAAQ;AACvC,cAAW,SAAS;GACpB,IAAI,SAAS,QAAQ,mBAAmB,IAAI,MAAM,YAAY,IAAI;AAClE,OAAI,CAAC,OACH,QAAO;GAET,IAAI,OAAO,GAAG,WAAW,QAAQ,QAAQ;AACzC,MAAG,SAAS,MAAM,UAAU,MAAM,KAAK,MAAM,KAAK,IAAI;AACtD,UAAO;;EAET,aAAa,SAAU,IAAI,MAAM,YAAY;AAC3C,UAAO,WACL,IACA,MACA,WAAW,QACX,CAAC,CAAC,WAAW,SACb,CAAC,CAAC,WAAW,SACb,CAAC,CAAC,WAAW,QACd;;EAEH,mBAAmB,SAAU,IAAI,OAAO,YAAY;GAClD,IAAI,SAAS,WAAW;GACxB,IAAI,SAAS,gBACX,IACA,QACA,WAAW,SACX,WAAW,kBACZ;GACD,IAAI,YAAY,WAAW,UAAU,KAAK;AAC1C,6BAA0B,WAAW,WAAW;AAChD,OAAI,CAAC,OAAQ,QAAO;AACpB,UAAO,MAAM;AACb,UAAO;;EAET,iBAAiB,SAAU,IAAI,MAAM,YAAY;GAC/C,IAAI,SAAS,WAAW;AACxB,6BAA0B,GAAG,WAAW;AACxC,UACE,gBACE,IACA,QACA,WAAW,SACX,WAAW,kBACZ,IAAI;;EAGT,cAAc,SAAU,IAAI,MAAM,YAAY;GAC5C,IAAI,SAAS,WAAW;AACxB,UACE,WACE,IACA,QACA,WAAW,SACX,WAAW,kBACZ,IAAI;;EAGT,cAAc,SAAU,IAAI,MAAM,YAAY,KAAK;GACjD,IAAI,SAAS,WAAW;AAExB,OAAI,WAAW,SAAS;AACxB,OAAI,YAAY,GAAG,WAAW,MAAM,MAAM,CAAC;AAC3C,UAAO,aAAa,IAAI,OAAO;;EAEjC,WAAW,SAAU,IAAI,MAAM,YAAY,KAAK;AAC9C,UAAO,UAAU,IAAI,MAAM,YAAY,KAAK,MAAM;;EAEpD,mCAAmC,SAAU,IAAI,MAAM;GAGrD,IAAI,SAAS;AACb,UAAO,IAAI,IACT,OAAO,MACP,gCAAgC,GAAG,QAAQ,OAAO,KAAK,CAAC,CACzD;;EAEH,qBAAqB,SAAU,IAAI,MAAM;GACvC,IAAI,SAAS;GACb,IAAI,OAAO,OAAO;GAClB,IAAI,KAAK,OAAO;AAYhB,OAAI,KAXW,GAAG,QAAQ,KAAK,CAWb,QAAQ;IAExB,IAAI,KAAK,OAAO,OAAO,OAAO,MAAM,gBAAgB;AAIpD,WAHc,GAAG,oBAAoB,IAAI,IAAI,MAAM,GAAG,EAAE,EACtD,cAAc,IACf,CAAC,CACa;SAEf,QAAO;;EAGX,mBAAmB,SAAU,KAAK,MAAM;AACtC,UAAO,IAAI,IAAI,KAAK,MAAM,EAAE;;EAE9B,4BAA4B,SAAU,IAAI,OAAO,YAAY;GAC3D,IAAI,UAAU,WAAW,UAAU,GAAG,UAAU,GAAG,GAAG,WAAW;AACjE,OAAI,WAAW,iBACb,WAAU,WAAW,SAAS,GAAG,UAAU,kBAAkB;AAE/D,UAAO,IAAI,IACT,SACA,gCAAgC,GAAG,QAAQ,QAAQ,CAAC,CACrD;;EAEH,0BAA0B,SAAU,IAAI;AACtC,MAAG,YAAY,aAAa;AAC5B,UAAO,GAAG,WAAW;;EAEvB,wBAAwB,SAAU,IAAI;AACpC,MAAG,YAAY,cAAc;GAC7B,IAAI,OAAO,GAAG,WAAW;AACzB,OAAI,KAAK,UAAU,SAAU,MAAK;AAClC,UAAO;;EAET,wBAAwB,SAAU,IAAI,MAAM,YAAY,KAAK;GAG3D,IAAI,gBAAgB;IAClB,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;IACN;GACD,IAAI,aAAa;IAAE,KAAK;IAAM,MAAK;IAAM,KAAK;IAAM;GAEpD,IAAI,YAAY,WAAW;AAG3B,OAAI,aAAa,IACf,aAAY;YACH,aAAa,IACtB,aAAY;GAQd,IAAI,YAAY,CAAC,WAAW;GAE5B,IAAI;AACJ,OAAI,cAAc,WAChB,OAAM,sBAAsB,IAAI,MAAM,WAAW,UAAU;YAClD,WAAW,WACpB,OAAM,oBAAoB,IAAI,MAAM,WAAW,UAAU;YAChD,cAAc,IACvB,OAAM,sBACJ,IACA,WACA,MACA,KACD;YACQ,cAAc,IACvB,OAAM,sBACJ,IACA,WACA,MACA,MACD;YACQ,cAAc,KAAK;AAC5B,UAAM,cAAc,IAAI,MAAM,WAAW,QAAQ,GAAG,UAAU;AAC9D,eAAW,WAAW;AACtB,QAAI,IAAI,YACN;SAAI,CAAC,IAAI,WACP,KAAI,aAAa;WAEd;KACL,IAAI,eAAe,IAAI,WAAW;AAClC,SAAI,aACF,cAAa,WAAW;AAE1B,SAAI,IAAI;;cAED,cAAc,IACvB,OAAM,qBAAqB,IAAI,MAAM,UAAU;OAG/C,QAAO;AAGT,OAAI,CAAC,GAAG,MAAM,IAAI,WAChB,QAAO,CAAC,IAAI,OAAO,IAAI,IAAI;OAE3B,QAAO,gBAAgB,IAAI,IAAI,OAAO,IAAI,IAAI;;EAIlD,2BAA2B,SAAU,IAAI,MAAM,YAAY;GACzD,IAAI,aAAa,eAAe;GAChC,IAAI,SAAS,WAAW;GACxB,IAAI,UAAU,WAAW,YAAY,WAAW;GAChD,IAAI,aAAa,WAAW,YAAY,IAAI,MAAM,UAAU,KAAK;AACjE,MAAG,MAAM,CAAC,WAAW,OAAO;AAC5B,cAAW,YAAY,UAAU,OAAO;GACxC,IAAI,SAAS,gBACX,IACA,QACA,SACA,WAAW,kBACZ;AACD,OAAI,CAAC,QAAQ;AACX,OAAG,MAAM,WAAW,OAAO;AAC3B,WAAO;;AAET,UAAO,MAAM;AACb,UAAO;;EAEV;CAED,SAAS,aAAa,MAAM,IAAI;AAC9B,UAAQ,QAAQ;;CAGlB,SAAS,UAAU,KAAK,OAAO;EAC7B,IAAI,MAAM,EAAE;AACZ,OAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IACzB,KAAI,KAAK,IAAI;AAEf,SAAO;;;;;;;CAOT,IAAI,YAAY;EACd,QAAQ,SAAU,IAAI,MAAM,QAAQ;GAClC,IAAI,WAAW;GACf,IAAI,MAAM,GAAG,MAAM;GACnB,IAAI,SAAS,OAAO,GAAG,QACrB,OAAO,OAAO,GAAG;AACnB,OAAI,CAAC,IAAI,YAAY;AACnB,WAAO,GAAG,SAAS,QAAQ,KAAK;IAChC,IAAI,YAAY,IAAI,sBAAsB,EAAE;AAC5C,QAAI,UAAU,UAAU,iBAAiB,CAAC,mBAAmB,KAAK,EAAE;KAElE,IAAI,QAAQ,OAAO,KAAK,KAAK;AAC7B,SAAI,SAAS,UAAU,cAAc,UAAU,WAAW,SAAS;AACjE,aAAO,aAAa,MAAM,GAAG,CAAC,MAAM,GAAG,OAAO;AAC9C,aAAO,KAAK,MAAM,GAAG,CAAC,MAAM,GAAG,OAAO;;;IAG1C,IAAI,cAAc,IAAI,IAAI,OAAO,OAAO,GAAG,OAAO,UAAU;IAC5D,IAAI,cAAc,GAAG,WAAW,IAAI,GAAG,UAAU;AACjD,QAAI,KAAK,OAAO,GAAG,UAAU,IAAI,KAAK,YAAY,CAAC,YACjD,IAAG,aAAa,IAAI,aAAa,KAAK;QAEtC,IAAG,aAAa,IAAI,QAAQ,KAAK;AAEnC,QAAI,KAAK,UAAU;AAEjB,SAAI,CAAC,aAAa;AAChB,SAAG,UAAU,YAAY;AACzB,yBAAW,SAAS,iBAAiB,GAAG;;AAG1C,YAAO,KAAK,OAAO;;AAErB,gBAAY;cACH,KAAK,UAAU;AACxB,SAAK,KAAK,OAAO;AACjB,SAAK;AACL,OAAG,aAAa,QAAQ,KAAK;AAC7B,WAAO,GAAG,cAAc;AACxB,OAAG,kBAAkB,GAAG;AACxB,gBAAY;UACP;AACL,WAAO,GAAG,cAAc;IACxB,IAAI,cAAc,UAAU,IAAI,OAAO,OAAO;AAC9C,OAAG,kBAAkB,YAAY;AACjC,gBAAY,UAAU,OAAO,GAAG,MAAM,OAAO,GAAG,OAAO;;AAEzD,kBAAe,mBAAmB,SAChC,KAAK,cACL,UACA,MACA,KAAK,UACL,OAAO,SAAS,EACjB;AACD,WAAQ,gBAAgB,IAAI,EAAE,MAAM,WAAW,EAAE,GAAG,MAAM,IAAI;;EAGhE,QAAQ,SAAU,IAAI,MAAM,QAAQ;AAGlC,MAAG,cAAc;GACjB,IAAI,WAAW;GACf,IAAI,MAAM,GAAG,MAAM;AACnB,OAAI,CAAC,IAAI,aAAa;IACpB,IAAI,SAAS,OAAO,GAAG,QACrB,OAAO,OAAO,GAAG;AACnB,QACE,KAAK,YACL,KAAK,QAAQ,GAAG,WAAW,IAC3B,OAAO,QAAQ,GAAG,UAAU,IAC5B,OAAO,QAAQ,KAAK,OAAO,EAG3B,KAAI,OAAO,QAAQ,GAAG,WAAW,CAC/B,QAAO,KAAK;QAEZ,UAAS,IAAI,IAAI,OAAO,OAAO,GAAG,WAAW,IAAI,OAAO,OAAO,EAAE,CAAC;AAGtE,WAAO,GAAG,SAAS,QAAQ,KAAK;AAChC,OAAG,aAAa,IAAI,QAAQ,KAAK;AACjC,gBAAY;AACZ,QAAI,KAAK,SACP,aAAY,QAAQ,kCAAkC,IAAI,OAAO;UAE9D;AACL,WAAO,GAAG,cAAc;IACxB,IAAI,cAAc,UAAU,IAAI,OAAO,OAAO;AAC9C,OAAG,kBAAkB,YAAY;AACjC,gBAAY,UAAU,OAAO,GAAG,MAAM,OAAO,GAAG,OAAO;;AAEzD,kBAAe,mBAAmB,SAChC,KAAK,cACL,UACA,MACA,KAAK,UACL,IAAI,YACL;AACD,UAAO,oBAAoB,IAAI,UAAU;;EAE3C,QAAQ,SAAU,IAAI,MAAM,QAAQ;GAClC,IAAI,MAAM,GAAG,MAAM;GACnB,IAAI,YAAY,OAAO,GAAG,OAAO;GACjC,IAAI,UAAU,IAAI,cACd,OAAO,OAAO,SAAS,GAAG,OAAO,OACjC,OAAO,GAAG,KAAK;GAGnB,IAAI,SAAS,IAAI,aAAa,KAAK,SAAS;AAC5C,OAAI,KAAK,SAIP;AAEF,MAAG,cAAc;AACjB,QAAK,IAAI,IAAI,WAAW,KAAK,SAAS,IACpC,MAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAC1B,IAAG,WAAW,GAAG,KAAK,YAAY;AAGtC,MAAG,cAAc;AACjB,UAAO,QAAQ,kCAAkC,IAAI,OAAO,GAAG,OAAO;;EAExE,YAAY,SAAU,IAAI,OAAO,QAAQ;AACvC,MAAG,YAAY,aAAa;AAC5B,UAAO,QAAQ,kCAAkC,IAAI,OAAO,GAAG,OAAO;;EAExE,YAAY,SAAU,IAAI,MAAM,QAAQ,WAAW,SAAS;GAC1D,IAAI,aAAa,GAAG,eAAe;GACnC,IAAI,UAAU,EAAE;GAChB,IAAI,UAAU,KAAK;AACnB,QAAK,IAAI,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK;IAC1C,IAAI,SAAS,WAAW;IACxB,IAAI,OAAO;AACX,QAAI,YAAY,KACd,QAAO,OAAO,aAAa;aAClB,YAAY,MACrB,QAAO,OAAO,aAAa;QAE3B,MAAK,IAAI,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;KACtC,IAAI,YAAY,OAAO,OAAO,EAAE;AAChC,aAAQ,YAAY,UAAU,GAC1B,UAAU,aAAa,GACvB,UAAU,aAAa;;AAG/B,YAAQ,KAAK,KAAK;;AAEpB,MAAG,kBAAkB,QAAQ;AAC7B,OAAI,KAAK,iBACP,QAAO;YAEP,CAAC,GAAG,MAAM,IAAI,cACd,KAAK,YACL,OAAO,GAAG,OAAO,OAAO,KAAK,OAAO,GAAG,KAAK,KAE5C,QAAO,QAAQ,kCAAkC,IAAI,UAAU;YACtD,KAAK,SACd,QAAO;OAEP,QAAO,UAAU,OAAO,GAAG,QAAQ,OAAO,GAAG,KAAK;;EAGtD,MAAM,SAAU,IAAI,MAAM,QAAQ,WAAW;GAC3C,IAAI,MAAM,GAAG,MAAM;GACnB,IAAI,OAAO,GAAG,cAAc;GAC5B,IAAI,SAAS,IAAI,aACb,UACE,IAAI,IAAI,QACR,IAAI,IAAI,MACR,OAAO,GAAG,MACV,OAAO,GAAG,OACX,GACD;AACJ,kBAAe,mBAAmB,SAChC,KAAK,cACL,QACA,MACA,KAAK,UACL,IAAI,YACL;AACD,UAAO;;EAEV;CAED,SAAS,eAAe,MAAM,IAAI;AAChC,YAAU,QAAQ;;CAGpB,IAAI,UAAU;EACZ,cAAc,SAAU,IAAI,YAAY,KAAK;AAC3C,OAAI,IAAI,WACN;GAEF,IAAI,SAAS,WAAW;GACxB,IAAI,UAAU,WAAW;GAGzB,IAAI,OAFW,eAAe,SAEV,KAAK,IAAI,UAAU,SAAS,CAAC,OAAO;GACxD,IAAI,UAAU,OAAO,KAAK,MAAM,GAAG;AACnC,aAAU,UAAU,UAAU,GAAG,WAAW;AAC5C,MAAG,UAAU,QAAQ;;EAEvB,QAAQ,SAAU,IAAI,YAAY,KAAK;AACrC,OAAI,IAAI,WACN;GAEF,IAAI,SAAS,WAAW,UAAU;GAClC,IAAI,aAAa,GAAG,mBAAmB;GACvC,IAAI,MAAM,GAAG,eAAe,CAAC;GAC7B,IAAI,QAAQ,aAAa;GACzB,IAAI,SAAS,WAAW,UAAU,MAAM,QAAQ,MAAM;GACtD,IAAI,SAAS,WAAW,GAAG,WAAW,CAAC;GACvC,IAAI,eAAe,GAAG,WAAW,QAAQ,QAAQ;AACjD,OAAI,WAAW,QACb,KAAI,SAAS,aAAa,KAAK;AAC7B,WAAO,SAAS,SAAS,aAAa,OAAO;AAC7C,WAAO,OAAO,KAAK,KAAK,OAAO,KAAK;AACpC,OAAG,UAAU,OAAO;AACpB,mBAAe,GAAG,WAAW,QAAQ,QAAQ;AAC7C,OAAG,SAAS,MAAM,aAAa,IAAI;SAGnC,IAAG,SAAS,MAAM,OAAO;QAEtB;IACL,IAAI,YAAY,SAAS,GAAG,eAAe,CAAC;AAC5C,QAAI,YAAY,aAAa,QAAQ;AACnC,YAAO,SAAS,aAAa,SAAS,aAAa;AACnD,YAAO,OAAO,KAAK,MAAM,OAAO,KAAK;AACrC,QAAG,UAAU,OAAO;AACpB,oBAAe,GAAG,WAAW,QAAQ,QAAQ;AAC7C,QAAG,SACD,MACA,aAAa,SAAS,GAAG,eAAe,CAAC,aAC1C;UAGD,IAAG,SAAS,MAAM,OAAO;;;EAI/B,gBAAgB,SAAU,IAAI,YAAY;GACxC,IAAI,UAAU,GAAG,WAAW,CAAC;GAC7B,IAAI,aAAa,GAAG,WAAW,IAAI,IAAI,SAAS,EAAE,EAAE,QAAQ;GAC5D,IAAI,SAAS,GAAG,eAAe,CAAC;GAChC,IAAI,IAAI,WAAW;GACnB,IAAI,aAAa,WAAW,SAAS;AACrC,WAAQ,WAAW,UAAnB;IACE,KAAK;AACH,SAAI,IAAI,SAAS,IAAI;AACrB;IACF,KAAK;AACH,SAAI,IAAI,SAAS;AACjB;;AAGJ,MAAG,kBAAkB,EAAE;;EAEzB,aAAa,SAAU,IAAI,YAAY,KAAK;GAC1C,IAAI,eAAe,WAAW;GAC9B,IAAI,SAAS,WAAW;GACxB,IAAI,iBAAiB,eAAe;AACpC,OAAI,gBAAgB,IAClB,gBAAe,eAAe;OAE9B,gBAAe,iBAAiB;AAElC,UAAO,SACL,sBAAqB,IAAI,KAAK,gBAAgB,aAAa;;EAG/D,sBAAsB,SAAU,IAAI,YAAY;GAC9C,IAAI,iBAAiB,eAAe;GACpC,IAAI,eAAe,WAAW;AAC9B,OAAI,eAAe,mBAAmB,gBAAgB,aAAa,CACjE,gBAAe,qBAAqB,IAAI,aAAa;;EAGzD,iBAAiB,SAAU,IAAI;AAC7B,OAAI,CAAC,GAAG,MAAM,WAAW;AACvB,OAAG,gBAAgB,KAAK;AACxB,OAAG,UAAU,UAAU,cAAc;AACrC,uBAAW,OAAO,IAAI,mBAAmB,EAAE,MAAM,WAAW,CAAC;UACxD;AACL,OAAG,gBAAgB,MAAM;AACzB,OAAG,UAAU,UAAU,aAAa;AACpC,uBAAW,OAAO,IAAI,mBAAmB,EAAE,MAAM,UAAU,CAAC;;;EAGhE,iBAAiB,SAAU,IAAI,YAAY,KAAK;AAC9C,OAAI,GAAG,UAAU,WAAW,CAC1B;AAEF,OAAI,aAAa;AACjB,OAAI,mBAAoB,cAAc,WAAW,UAAW;GAC5D,IAAI,WAAW,aAAa,WAAW,WAAW;GAClD,IAAI,MAAM,IAAI;GACd,IAAI,OAAO,WAAW,QAAQ,GAAG,UAAU,OAAO;GAClD,IAAI,SAAS,GAAG,gBAAgB,CAAC;AACjC,OAAI,YAAY,MACd,QAAO,IAAI,IAAI,KAAK,MAAM,WAAW,IAAI,KAAK,KAAK,CAAC;YAC3C,YAAY,MACrB,QAAO,IAAI,IAAI,KAAK,MAAM,EAAE;YACnB,YAAY,YACrB,QAAO,aAAa,MAAM,GAAG,EAAE;YACtB,YAAY,gBACrB,QAAO,QAAQ,kCAAkC,IAAI,KAAK;YACjD,YAAY,uBAAuB;AAC5C,QAAI,CAAC,IAAI,WAAY;AACrB,QAAI,CAAC,IAAI,YACP,KAAI,IAAI,KAAK,OAAO,IAAI,OAAO,KAC7B,QAAO,IAAI;QAEX,QAAO,IAAI,IAAI,IAAI,OAAO,MAAM,EAAE;SAE/B;AACL,YAAO,IAAI,IACT,KAAK,IAAI,IAAI,KAAK,MAAM,IAAI,OAAO,KAAK,EACxC,KAAK,IAAI,IAAI,KAAK,IAAI,IAAI,OAAO,GAAG,CACrC;AACD,cAAS,KAAK,IAAI,IAAI,KAAK,OAAO,IAAI,OAAO,KAAK,GAAG;;cAE9C,YAAY,qBAAqB;AAC1C,QAAI,CAAC,IAAI,WAAY;AACrB,QAAI,CAAC,IAAI,YACP,KAAI,IAAI,KAAK,QAAQ,IAAI,OAAO,KAC9B,QAAO,aAAa,IAAI,MAAM,GAAG,EAAE;QAEnC,QAAO,IAAI,IAAI,IAAI,OAAO,MAAM,EAAE;SAE/B;AACL,YAAO,IAAI,IACT,KAAK,IAAI,IAAI,KAAK,MAAM,IAAI,OAAO,KAAK,EACxC,KAAK,IAAI,IAAI,KAAK,IAAI,IAAI,OAAO,GAAG,GAAG,EACxC;AACD,cAAS,KAAK,IAAI,IAAI,KAAK,OAAO,IAAI,OAAO,KAAK,GAAG;;cAE9C,YAAY,WACrB;QAAI,IAAI,WACN;cAEO,YAAY,WACrB,QAAO,eAAe,GAAG,IAAI;AAE/B,MAAG,UAAU,gBAAgB,MAAM;AACnC,OAAI,cAAc,WAAW,SAAS;AAEpC,OAAG,gBAAgB,KAAK;AACxB,OAAG,UAAU,UAAU,cAAc;AACrC,uBAAW,OAAO,IAAI,mBAAmB,EAAE,MAAM,WAAW,CAAC;UACxD;AACL,OAAG,gBAAgB,MAAM;AACzB,OAAG,UAAU,UAAU,aAAa;AACpC,uBAAW,OAAO,IAAI,mBAAmB,EAAE,MAAM,UAAU,CAAC;;AAE9D,OAAI,CAAC,eAAe,eAAe,WAAW;AAE5C,OAAG,GAAG,UAAU,SAAS;AACzB,uBAAW,GAAG,GAAG,eAAe,EAAE,WAAW,wBAAwB;;AAEvE,OAAI,IAAI,WACN,gBAAe,GAAG;AAEpB,mBAAgB,IAAI,MAAM,OAAO;;EAEnC,kBAAkB,SAAU,IAAI,YAAY,KAAK;GAC/C,IAAI,SAAS,WAAW;GACxB,IAAI,SAAS,GAAG,WAAW;GAC3B,IAAI;AAIJ,OAAI,CAAC,IAAI,YAAY;AAEnB,QAAI,aAAa;AACjB,QAAI,aAAa,CAAC,CAAC,WAAW;AAC9B,QAAI,cAAc,CAAC,CAAC,WAAW;AAC/B,WAAO,oBACL,IACA,IAAI,IAAI,OAAO,MAAM,OAAO,KAAK,SAAS,EAAE,CAC7C;AACD,QAAI,MAAM;KACA;KACF;KACP;AACD,uBAAW,OAAO,IAAI,mBAAmB;KACvC,MAAM;KACN,SAAS,IAAI,aACT,aACA,IAAI,cACJ,cACA;KACL,CAAC;AACF,sBAAkB,GAAG;AACrB,eAAW,IAAI,KAAK,KAAK,UAAU,QAAQ,KAAK,CAAC;AACjD,eAAW,IAAI,KAAK,KAAK,UAAU,QAAQ,KAAK,CAAC;cAEjD,IAAI,aAAa,WAAW,YAC5B,IAAI,cAAc,WAAW,WAC7B;AAEA,QAAI,aAAa,CAAC,CAAC,WAAW;AAC9B,QAAI,cAAc,CAAC,CAAC,WAAW;AAC/B,uBAAW,OAAO,IAAI,mBAAmB;KACvC,MAAM;KACN,SAAS,IAAI,aACT,aACA,IAAI,cACJ,cACA;KACL,CAAC;AACF,sBAAkB,GAAG;SAErB,gBAAe,GAAG;;EAGtB,uBAAuB,SAAU,IAAI,aAAa,KAAK;GACrD,IAAI,gBAAgB,IAAI;AACxB,OAAI,IAAI,WACN,qBAAoB,IAAI,IAAI;AAE9B,OAAI,eAAe;IACjB,IAAI,SAAS,cAAc,WAAW,MAAM;IAC5C,IAAI,OAAO,cAAc,SAAS,MAAM;AACxC,QAAI,CAAC,UAAU,CAAC,KAEd;AAEF,QAAI,MAAM;KACA;KACF;KACP;AACD,QAAI,aAAa;AACjB,QAAI,aAAa,cAAc;AAC/B,QAAI,cAAc,cAAc;AAChC,sBAAkB,GAAG;AACrB,eAAW,IAAI,KAAK,KAAK,UAAU,QAAQ,KAAK,CAAC;AACjD,eAAW,IAAI,KAAK,KAAK,UAAU,QAAQ,KAAK,CAAC;AACjD,uBAAW,OAAO,IAAI,mBAAmB;KACvC,MAAM;KACN,SAAS,IAAI,aACT,aACA,IAAI,cACJ,cACA;KACL,CAAC;;;EAGN,WAAW,SAAU,IAAI,YAAY,KAAK;GACxC,IAAI,UAAU;AACd,OAAI,IAAI,YAAY;AAClB,eAAW,GAAG,UAAU,SAAS;AACjC,aAAS,GAAG,UAAU,OAAO;AAC7B,QAAI,eAAe,QAAQ,SAAS,EAAE;KACpC,IAAI,MAAM;AACV,cAAS;AACT,gBAAW;;AAEb,WAAO,KAAK,WAAW,IAAI,OAAO,KAAK,GAAG;UACrC;IAEL,IAAI,SAAS,KAAK,IAAI,WAAW,QAAQ,EAAE;AAC3C,eAAW,GAAG,WAAW;AACzB,aAAS,oBACP,IACA,IAAI,IAAI,SAAS,OAAO,SAAS,GAAG,SAAS,CAC9C;;GAEH,IAAI,UAAU;AACd,QAAK,IAAI,IAAI,SAAS,MAAM,IAAI,OAAO,MAAM,KAAK;AAChD,cAAU,WAAW,IAAI,SAAS,KAAK;IACvC,IAAI,MAAM,IAAI,IAAI,SAAS,OAAO,GAAG,WAAW,IAAI,SAAS,OAAO,EAAE,CAAC;IACvE,IAAI,OAAO,GAAG,SAAS,UAAU,IAAI;AACrC,WAAO,WAAW,aACd,KAAK,QAAQ,UAAU,GAAG,GAC1B,KAAK,QAAQ,UAAU,IAAI;AAC/B,OAAG,aAAa,MAAM,UAAU,IAAI;;GAEtC,IAAI,cAAc,IAAI,IAAI,SAAS,MAAM,QAAQ;AACjD,OAAI,IAAI,WACN,gBAAe,IAAI,MAAM;AAE3B,MAAG,UAAU,YAAY;;EAE3B,2BAA2B,SAAU,IAAI,YAAY,KAAK;AACxD,OAAI,GAAG,UAAU,WAAW,CAC1B;AAEF,OAAI,aAAa;GACjB,IAAI,WAAW,WAAW,GAAG,WAAW,CAAC;AACzC,OAAI,SAAS,SAAS,GAAG,WAAW,IAAI,CAAC,WAAW,OAAO;AAEzD,OAAG,aAAa,MAAM,IAAI,IAAI,GAAG,WAAW,EAAE,EAAE,CAAC;AACjD,OAAG,UAAU,GAAG,WAAW,EAAE,EAAE;UAC1B;AACL,aAAS,OAAO,WAAW,QAAQ,SAAS,OAAO,SAAS,OAAO;AACnE,aAAS,KAAK,WAAW,IAAI,SAAS,KAAK;AAC3C,OAAG,UAAU,SAAS;AAItB,KAFEA,mBAAW,SAAS,mCACpBA,mBAAW,SAAS,kBACZ,GAAG;;AAEf,QAAK,gBAAgB,IAAI,EAAE,QAAQ,WAAW,QAAQ,EAAE,IAAI;;EAE9D,OAAO,SAAU,IAAI,YAAY,KAAK;GACpC,IAAI,MAAM,WAAW,GAAG,WAAW,CAAC;GACpC,IAAI,WAAW,eAAe,mBAAmB,YAC/C,WAAW,aACZ;GACD,IAAI,OAAO,SAAS,UAAU;AAC9B,OAAI,CAAC,KACH;AAEF,OAAI,WAAW,aAAa;IAC1B,IAAI,UAAU,GAAG,UAAU,UAAU;IAErC,IAAI,mBAAmB,SAAU,KAAK;KACpC,IAAI,OAAO,IAAI,MAAM,IAAK,CAAC,SAAS;KACpC,IAAI,SAAS,IAAI,MAAM,IAAI,CAAC,SAAS;AACrC,YAAO,OAAO,UAAU,SAAS;;IAGnC,IAAI,SAAS,iBADK,GAAG,QAAQ,GAAG,WAAW,CAAC,KAAK,CACP,MAAM,OAAO,CAAC,GAAG;IAE3D,IAAI,cAAc,KAAK,QAAQ,OAAO,GAAG;IACzC,IAAI,aAAa,SAAS;IAC1B,IAAI,cAAc,iBAAiB,KAAK,MAAM,OAAO,CAAC,GAAG;IACzD,IAAI,OAAO,YAAY,QAAQ,UAAU,SAAU,QAAQ;KACzD,IAAI,YAAY,UAAU,iBAAiB,OAAO,GAAG;AACrD,SAAI,YAAY,EACd,QAAO;cACE,GAAG,UAAU,iBAAiB,EAAE;MACzC,IAAI,WAAW,KAAK,MAAM,YAAY,QAAQ;AAC9C,aAAO,MAAM,WAAW,EAAE,CAAC,KAAK,IAAK;WAErC,QAAO,MAAM,YAAY,EAAE,CAAC,KAAK,IAAI;MAEvC;AACF,YAAQ,aAAa,OAAO;;AAE9B,OAAI,WAAW,SAAS,GACtB,IAAI,OAAO,MAAM,WAAW,SAAS,EAAE,CAAC,KAAK,KAAK;GAEpD,IAAI,WAAW,SAAS;GACxB,IAAI,YAAY,SAAS;AACzB,OAAI,WAAW;AACb,WAAO,KAAK,MAAM,KAAK;AACvB,QAAI,SACF,MAAK,KAAK;AAEZ,SAAK,IAAI,IAAI,GAAG,IAAI,KAAK,QAAQ,IAC/B,MAAK,KAAK,KAAK,MAAM,KAAK,MAAM,KAAK;AAEvC,QAAI,MAAM,WAAW,QAAQ,IAAI;AACjC,QAAI,KAAK,KAAK,IAAI,WAAW,IAAI,IAAI,KAAK,EAAE,IAAI,GAAG;cAC1C,SACT,KAAI,IAAI,WACN,QAAO,IAAI,aACP,KAAK,MAAM,GAAG,GAAG,GACjB,OAAO,KAAK,MAAM,GAAG,KAAK,SAAS,EAAE,GAAG;YACnC,WAAW,OAAO;AAG3B,WAAO,OAAO,KAAK,MAAM,GAAG,KAAK,SAAS,EAAE;AAC5C,QAAI,KAAK,WAAW,IAAI,IAAI,KAAK;SAEjC,KAAI,KAAK;OAGX,KAAI,MAAM,WAAW,QAAQ,IAAI;GAEnC,IAAI;GACJ,IAAI;AACJ,OAAI,IAAI,YAAY;AAElB,QAAI,iBAAiB;IACrB,IAAI;IACJ,IAAI,eAAe,qBAAqB,IAAI,IAAI;IAChD,IAAI,iBAAiB,aAAa;IAClC,IAAI,eAAe,aAAa;IAChC,IAAI,eAAe,GAAG,cAAc;IACpC,IAAI,aAAa,GAAG,gBAAgB;IACpC,IAAI,eAAe,IAAI,MAAM,WAAW,OAAO,CAAC,KAAK,IAAI,CAAC,MAAM,IAAI;AAEpE,QAAI,IAAI,cACN,uBAAsB,IAAI,cAAc,SAAS,MAAM;AAGzD,mBAAe,mBAAmB,gBAAgB,QAAQ,aAAa;AACvE,QAAI,WAAW;AAEb,QAAG,kBAAkB,aAAa;AAElC,oBAAe,IAAI,IACjB,eAAe,OAAO,KAAK,SAAS,GACpC,eAAe,GAChB;AACD,QAAG,UAAU,eAAe;AAC5B,iBAAY,IAAI,aAAa;AAC7B,QAAG,kBAAkB,KAAK;AAC1B,mBAAc;eACL,IAAI,aAAa;AAC1B,QAAG,kBAAkB,aAAa;AAClC,QAAG,UAAU,eAAe;AAC5B,QAAG,aAAa,MAAM,gBAAgB,eAAe;AACrD,mBAAc;WACT;AACL,QAAG,aAAa,MAAM,gBAAgB,aAAa;AACnD,mBAAc,GAAG,aACf,GAAG,aAAa,eAAe,GAAG,KAAK,SAAS,EACjD;;AAGH,QAAI,oBACF,KAAI,cAAc,WAAW,GAAG,YAAY,oBAAoB;AAElE,QAAI,SACF,aAAY,KAAK;cAGf,WAAW;AACb,OAAG,UAAU,IAAI;AACjB,SAAK,IAAI,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;KACpC,IAAI,OAAO,IAAI,OAAO;AACtB,SAAI,OAAO,GAAG,UAAU,CACtB,IAAG,aAAa,MAAM,IAAI,IAAI,MAAM,EAAE,CAAC;AAGzC,SADa,WAAW,IAAI,KAAK,GACpB,IAAI,GACf,oBAAmB,IAAI,MAAM,IAAI,GAAG;;AAGxC,OAAG,UAAU,IAAI;AACjB,gBAAY,IAAI,IAAI,IAAI,IAAI,OAAO,KAAK,SAAS,GAAG,IAAI,GAAG,CAAC;AAC5D,OAAG,kBAAkB,KAAK;AAC1B,kBAAc;UACT;AACL,OAAG,aAAa,MAAM,IAAI;AAE1B,QAAI,YAAY,WAAW,MACzB,eAAc,IAAI,IAChB,IAAI,OAAO,GACX,gCAAgC,GAAG,QAAQ,IAAI,OAAO,EAAE,CAAC,CAC1D;aACQ,YAAY,CAAC,WAAW,MACjC,eAAc,IAAI,IAChB,IAAI,MACJ,gCAAgC,GAAG,QAAQ,IAAI,KAAK,CAAC,CACtD;aACQ,CAAC,YAAY,WAAW,OAAO;AACxC,WAAM,GAAG,aAAa,IAAI;AAC1B,mBAAc,GAAG,aAAa,MAAM,KAAK,SAAS,EAAE;WAC/C;AACL,WAAM,GAAG,aAAa,IAAI;AAC1B,mBAAc,GAAG,aAAa,MAAM,KAAK,OAAO;;;AAItD,OAAI,IAAI,WACN,gBAAe,IAAI,MAAM;AAE3B,MAAG,UAAU,YAAY;;EAE3B,MAAM,SAAU,IAAI,YAAY;AAC9B,MAAG,UAAU,WAAY;AACvB,aAAS,IAAIA,mBAAW,SAAS,MAAM,WAAW,OAAO,EAAE;AAC3D,OAAG,UAAU,GAAG,UAAU,SAAS,CAAC;KACpC;;EAEJ,MAAM,SAAU,IAAI,YAAY;AAC9B,YAAS,IAAIA,mBAAW,SAAS,MAAM,WAAW,OAAO,EAAE;;EAE7D,aAAa,SAAU,KAAK,YAAY,KAAK;AAC3C,OAAI,WAAW,eAAe,WAAW;;EAE3C,SAAS,SAAU,IAAI,YAAY,KAAK;GACtC,IAAI,WAAW,WAAW;AAC1B,cAAW,IAAI,KAAK,UAAU,GAAG,WAAW,CAAC;;EAE/C,SAAS,SAAU,IAAI,YAAY,KAAK;GACtC,IAAI,cAAc,WAAW;GAC7B,IAAI,WAAW,GAAG,WAAW;GAC7B,IAAI;GACJ,IAAI;GACJ,IAAI,aAAa,GAAG,gBAAgB;AACpC,OAAI,IAAI,YAAY;AAClB,eAAW,GAAG,UAAU,QAAQ;AAChC,aAAS,GAAG,UAAU,MAAM;UACvB;IACL,IAAI,OAAO,GAAG,QAAQ,SAAS,KAAK;AACpC,gBAAY,SAAS,KAAK,WAAW;AACrC,QAAI,YAAY,KAAK,OACnB,aAAY,KAAK;AAEnB,aAAS,IAAI,IAAI,SAAS,MAAM,UAAU;;AAE5C,OAAI,eAAe,MAAM;AACvB,QAAI,CAAC,IAAI,WAAY,IAAG,aAAa,IAAI,UAAU,OAAO;AAE1D,KACEA,mBAAW,SAAS,mCACpBA,mBAAW,SAAS,kBACpB,GAAG;UACA;IACL,IAAI,iBAAiB,GAAG,SAAS,UAAU,OAAO;AAElD,qBAAiB,eAAe,QAAQ,UAAU,YAAY;AAC9D,QAAI,IAAI,aAAa;KAEnB,IAAI,SAAS,IAAI,MAAM,GAAG,UAAU,UAAU,GAAG,EAAE,CAAC,KAAK,IAAI;AAC7D,sBAAiB,GAAG,cAAc;AAClC,sBAAiB,eACd,QAAQ,OAAO,OAAO,CACtB,QAAQ,UAAU,YAAY,CAC9B,MAAM,KAAK;AACd,QAAG,kBAAkB,eAAe;UAEpC,IAAG,aAAa,gBAAgB,UAAU,OAAO;AAEnD,QAAI,IAAI,YAAY;AAClB,gBAAW,eAAe,WAAW,GAAG,QAAQ,WAAW,GAAG,KAAK,GAC/D,WAAW,GAAG,SACd,WAAW,GAAG;AAClB,QAAG,UAAU,SAAS;AACtB,oBAAe,IAAI,MAAM;UAEzB,IAAG,UAAU,aAAa,QAAQ,GAAG,GAAG,CAAC;;;EAI/C,sBAAsB,SAAU,IAAI,YAAY;GAC9C,IAAI,MAAM,GAAG,WAAW;GACxB,IAAI,UAAU,GAAG,QAAQ,IAAI,KAAK;GAClC,IAAI,KAAK;GACT,IAAI;GACJ,IAAI;GACJ,IAAI;GACJ,IAAI;AACJ,WAAQ,QAAQ,GAAG,KAAK,QAAQ,MAAM,MAAM;AAC1C,YAAQ,MAAM;AACd,UAAM,QAAQ,MAAM,GAAG;AACvB,QAAI,IAAI,KAAK,IAAK;;AAEpB,OAAI,CAAC,WAAW,aAAa,OAAO,IAAI,GAAI;AAC5C,OAAI,OAAO;IACT,IAAI,UAAU,MAAM,MAAM,MAAM;IAChC,IAAI,SAAS,MAAM,MAAM,MAAM;IAC/B,IAAI,YAAY,WAAW,WAAW,IAAI;IAC1C,IAAI,OAAO;KAAE,MAAM;KAAG,GAAG;KAAG,IAAI;KAAI,MAAM;KAAI,CAAC,QAAQ,aAAa;AAGpE,iBADE,SAAS,MAAM,KAAK,QAAQ,KAAK,GAAG,YAAY,WAAW,QAC1C,SAAS,KAAK;IACjC,IAAI,cAAc,UACd,IAAI,MACF,OAAO,SAAS,UAAU,SAAS,IAAI,MAAM,GAAG,OACjD,CAAC,KAAK,IAAI,GACX;AACJ,QAAI,UAAU,OAAO,EAAE,KAAK,IAC1B,aAAY,MAAM,UAAU,cAAc,UAAU,OAAO,EAAE;QAE7D,aAAY,UAAU,cAAc;IAEtC,IAAI,OAAO,IAAI,IAAI,IAAI,MAAM,MAAM;IACnC,IAAI,KAAK,IAAI,IAAI,IAAI,MAAM,IAAI;AAC/B,OAAG,aAAa,WAAW,MAAM,GAAG;SAEpC;AAEF,MAAG,UAAU,IAAI,IAAI,IAAI,MAAM,QAAQ,UAAU,SAAS,EAAE,CAAC;;EAE/D,gBAAgB,SAAU,IAAI,YAAY,KAAK;AAE7C,OAAI,CADqB,IAAI,mBAE3B;GAEF,IAAI,SAAS,WAAW;AACxB,OAAI,UAAU,WAAW,iBACvB,KAAI,mBAAmB,iBAAiB;OAExC,UAAS,IAAI,mBAAmB,kBAAkB;AAEpD;IAAe;IAAI;IAAK;IAAQ;;IAA6B;;EAE/D,QAAQ,SAAU,IAAI,YAAY;AAChC,MAAG,WAAW,GAAG,WAAW,CAAC,MAAM,WAAW,YAAY;;EAE5C;EACjB;CAED,SAAS,aAAa,MAAM,IAAI;AAC9B,UAAQ,QAAQ;;;;;;CAWlB,SAAS,oBAAoB,IAAI,KAAK;EACpC,IAAI,MAAM,GAAG,MAAM;EACnB,IAAI,mBAAmB,IAAI,cAAc,IAAI;EAC7C,IAAI,OAAO,KAAK,IAAI,KAAK,IAAI,GAAG,WAAW,EAAE,IAAI,KAAK,EAAE,GAAG,UAAU,CAAC;EACtE,IAAI,QAAQ,WAAW,IAAI,KAAK,GAAG,IAAI,CAAC,CAAC;AAEzC,SAAO,IAAI,IAAI,MADN,KAAK,IAAI,KAAK,IAAI,GAAG,IAAI,GAAG,EAAE,MAAM,CACrB;;CAE1B,SAAS,SAAS,MAAM;EACtB,IAAI,MAAM,EAAE;AACZ,OAAK,IAAI,QAAQ,KACf,KAAI,KAAK,eAAe,KAAK,CAC3B,KAAI,QAAQ,KAAK;AAGrB,SAAO;;CAET,SAAS,aAAa,KAAK,YAAY,UAAU;AAC/C,MAAI,OAAO,eAAe,UAAU;AAClC,cAAW,WAAW;AACtB,gBAAa,WAAW;;AAE1B,SAAO,IAAI,IAAI,IAAI,OAAO,YAAY,IAAI,KAAK,SAAS;;CAE1D,SAAS,eAAe,MAAM,QAAQ,SAAS,YAAY;EAIzD,IAAI,OACF,UAAU,EAAE,EACZ,OAAO,EAAE;AACX,OAAK,IAAI,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;GACtC,IAAI,UAAU,OAAO;AACrB,OACG,WAAW,YAAY,QAAQ,WAAW,YAC1C,QAAQ,WAAW,QAAQ,WAAW,WACtC,WAAW,YAAY,QAAQ,QAAQ,YACxC,EAAE,QAAQ,aAAa,MAAM,QAAQ,KAAK,EAE1C;AAEF,OAAI,SAAS,UACX,SAAQ,KAAK,QAAQ;AAEvB,OAAI,SAAS,OACX,MAAK,KAAK,QAAQ;;AAGtB,SAAO;GACL,SAAS,QAAQ,UAAU;GAC3B,MAAM,KAAK,UAAU;GACtB;;CAEH,SAAS,aAAa,SAAS,QAAQ;AACrC,MAAI,OAAO,MAAM,IAAI,IAAI,eAAe;GAEtC,IAAI,YAAY,OAAO,SAAS;GAChC,IAAI,gBAAgB,QAAQ,MAAM,GAAG,UAAU;GAC/C,IAAI,eAAe,OAAO,MAAM,GAAG,UAAU;AAC7C,UAAO,iBAAiB,gBAAgB,QAAQ,SAAS,YACrD,SACA,aAAa,QAAQ,cAAc,IAAI,IACvC,YACA;QAEJ,QAAO,WAAW,SACd,SACA,OAAO,QAAQ,QAAQ,IAAI,IAC3B,YACA;;CAGR,SAAS,SAAS,MAAM;EACtB,IAAI,QAAQ,gBAAgB,KAAK,KAAK;EACtC,IAAI,oBAAoB,QAAQ,MAAM,KAAK,KAAK,MAAM,GAAG;AACzD,MAAI,kBAAkB,SAAS,EAC7B,SAAQ,mBAAR;GACE,KAAK;AACH,wBAAoB;AACpB;GACF,KAAK;AACH,wBAAoB;AACpB;GACF;AACE,wBAAoB;AACpB;;AAGN,SAAO;;CAET,SAAS,SAAS,IAAI,IAAI,QAAQ;AAChC,SAAO,WAAY;AACjB,QAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAC1B,IAAG,GAAG;;;CAIZ,SAAS,WAAW,KAAK;AACvB,SAAO,IAAI,IAAI,IAAI,MAAM,IAAI,GAAG;;CAElC,SAAS,YAAY,MAAM,MAAM;AAC/B,SAAO,KAAK,MAAM,KAAK,MAAM,KAAK,QAAQ,KAAK;;CAEjD,SAAS,eAAe,MAAM,MAAM;AAClC,MAAI,KAAK,OAAO,KAAK,KACnB,QAAO;AAET,MAAI,KAAK,QAAQ,KAAK,QAAQ,KAAK,KAAK,KAAK,GAC3C,QAAO;AAET,SAAO;;CAET,SAAS,UAAU,MAAM,MAAM;AAC7B,MAAI,UAAU,SAAS,EACrB,QAAO,UAAU,MACf,QACA,MAAM,UAAU,MAAM,KAAK,WAAW,EAAE,CACzC;AAEH,SAAO,eAAe,MAAM,KAAK,GAAG,OAAO;;CAE7C,SAAS,UAAU,MAAM,MAAM;AAC7B,MAAI,UAAU,SAAS,EACrB,QAAO,UAAU,MACf,QACA,MAAM,UAAU,MAAM,KAAK,WAAW,EAAE,CACzC;AAEH,SAAO,eAAe,MAAM,KAAK,GAAG,OAAO;;CAE7C,SAAS,gBAAgB,MAAM,MAAM,MAAM;EAEzC,IAAI,cAAc,eAAe,MAAM,KAAK;EAC5C,IAAI,cAAc,eAAe,MAAM,KAAK;AAC5C,SAAO,eAAe;;CAExB,SAAS,WAAW,IAAI,SAAS;AAC/B,SAAO,GAAG,QAAQ,QAAQ,CAAC;;CAE7B,SAAS,KAAK,GAAG;AACf,MAAI,EAAE,KACJ,QAAO,EAAE,MAAM;AAEjB,SAAO,EAAE,QAAQ,cAAc,GAAG;;CAEpC,SAAS,YAAY,GAAG;AACtB,SAAO,EAAE,QAAQ,6BAA6B,OAAO;;CAEvD,SAAS,mBAAmB,IAAI,SAAS,QAAQ;EAC/C,IAAI,QAAQ,WAAW,IAAI,QAAQ;EACnC,IAAI,SAAS,IAAI,MAAM,SAAS,QAAQ,EAAE,CAAC,KAAK,IAAI;AACpD,KAAG,UAAU,IAAI,IAAI,SAAS,MAAM,CAAC;AACrC,KAAG,aAAa,QAAQ,GAAG,WAAW,CAAC;;CAQzC,SAAS,YAAY,IAAI,cAAc;EACrC,IAAI,aAAa,EAAE,EACjB,SAAS,GAAG,gBAAgB;EAC9B,IAAI,OAAO,WAAW,GAAG,QAAQ,aAAa,CAAC;EAC/C,IAAI,YAAY,CAAC,YAAY,cAAc,KAAK;EAEhD,IAAI,YAAY,SAAS,QADX,GAAG,UAAU,OAAO,CACO;EACzC,IAAI,aAAa,YACf,OAAO,WAAW,MAClB,OAAO,WAAW,OACnB;EACD,IAAI,MAAM,OAAO,SAAS;EAC1B,IAAI,QAAQ,MAAM,YAAY,YAAY,MAAM;EAChD,IAAI,OAAO,OAAO,OAAO;EAEzB,IAAI,YAAY,KAAK,IAAI,KAAK,MAAM,KAAK,KAAK;EAC9C,IAAI,WAAW,KAAK,IAAI,KAAK,MAAM,KAAK,KAAK;EAC7C,IAAI,SAAS,KAAK,IAChB,SAAS,KAAK;EAEhB,IAAI,MAAM,OAAO,OAAO,KAAK,KAAK;EAClC,IAAI,SAAS,SAAS;AACtB,MAAI,MAAM,KAAK,UAAU,GAAG;AAC1B;AACA,OAAI,CAAC,UACH;aAEO,MAAM,KAAK,UAAU,GAAG;AACjC;AACA,OAAI,CAAC,WACH;aAEO,MAAM,KAAK,UAAU,IAAI;AAClC;AACA;;AAEF,OAAK,IAAI,OAAO,WAAW,QAAQ,UAAU,QAAQ;GACnD,IAAI,QAAQ;IACV,QAAQ,IAAI,IAAI,MAAM,OAAO;IAC7B,MAAM,IAAI,IAAI,MAAM,OAAO;IAC5B;AACD,cAAW,KAAK,MAAM;;AAExB,KAAG,cAAc,WAAW;AAC5B,eAAa,KAAK;AAClB,OAAK,KAAK;AACV,SAAO;;CAET,SAAS,gBAAgB,IAAI,MAAM,QAAQ;EACzC,IAAI,MAAM,EAAE;AACZ,OAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK;GAC/B,IAAI,WAAW,aAAa,MAAM,GAAG,EAAE;AACvC,OAAI,KAAK;IAAE,QAAQ;IAAU,MAAM;IAAU,CAAC;;AAEhD,KAAG,cAAc,KAAK,EAAE;;CAG1B,SAAS,SAAS,QAAQ,QAAQ,KAAK;AACrC,OAAK,IAAI,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;GACtC,IAAI,WAAW,OAAO,UAAU,YAAY,OAAO,GAAG,QAAQ,OAAO;GACrE,IAAI,SAAS,OAAO,YAAY,YAAY,OAAO,GAAG,MAAM,OAAO;AACnE,OAAI,YAAY,OACd,QAAO;;AAGX,SAAO;;CAET,SAAS,qBAAqB,IAAI,KAAK;EACrC,IAAI,gBAAgB,IAAI;EACxB,IAAI,8BAA8B,WAAY;GAC5C,IAAI,aAAa,GAAG,gBAAgB;GACpC,IAAI,QAAQ,WAAW;GACvB,IAAI,MAAM,WAAW,WAAW,SAAS;AAOzC,UAAO,CANc,eAAe,MAAM,QAAQ,MAAM,KAAK,GACzD,MAAM,SACN,MAAM,MACS,eAAe,IAAI,QAAQ,IAAI,KAAK,GACnD,IAAI,OACJ,IAAI,OAC6B;;EAEvC,IAAI,2BAA2B,WAAY;GACzC,IAAI,iBAAiB,GAAG,WAAW;GACnC,IAAI,eAAe,GAAG,WAAW;GACjC,IAAI,QAAQ,cAAc;AAC1B,OAAI,OAAO;IACT,IAAI,QAAQ,MAAM;IAClB,IAAI,SAAS,MAAM;AACnB,mBAAe,IAAI,IACjB,eAAe,OAAO,QACtB,eAAe,KAAK,MACrB;IACD,IAAI,aAAa,EAAE;AAGnB,SAAK,IAAI,IAAI,eAAe,MAAM,IAAI,aAAa,MAAM,KAAK;KAG5D,IAAI,QAAQ;MAAE,QAFD,IAAI,IAAI,GAAG,eAAe,GAAG;MAEZ,MADnB,IAAI,IAAI,GAAG,aAAa,GAAG;MACI;AAC1C,gBAAW,KAAK,MAAM;;AAExB,OAAG,cAAc,WAAW;UACvB;IACL,IAAI,QAAQ,cAAc,WAAW,MAAM;IAC3C,IAAI,MAAM,cAAc,SAAS,MAAM;IACvC,IAAI,OAAO,IAAI,OAAO,MAAM;IAC5B,IAAI,KAAK,IAAI,KAAK,MAAM;AACxB,mBAAe;KACb,MAAM,aAAa,OAAO;KAC1B,IAAI,OAAO,aAAa,KAAK,KAAK,aAAa;KAChD;AACD,QAAI,cAAc,YAAY;AAC5B,sBAAiB,IAAI,IAAI,eAAe,MAAM,EAAE;AAChD,oBAAe,IAAI,IACjB,aAAa,MACb,WAAW,IAAI,aAAa,KAAK,CAClC;;AAEH,OAAG,aAAa,gBAAgB,aAAa;;AAE/C,UAAO,CAAC,gBAAgB,aAAa;;AAEvC,MAAI,CAAC,IAAI,WAEP,QAAO,0BAA0B;MAEjC,QAAO,6BAA6B;;CAKxC,SAAS,oBAAoB,IAAI,KAAK;EACpC,IAAI,SAAS,IAAI,IAAI;EACrB,IAAI,OAAO,IAAI,IAAI;AAEnB,MAAI,IAAI,gBAAgB;AACtB,UAAO,GAAG,aACR,GAAG,aAAa,OAAO,GAAG,IAAI,eAAe,OAC9C;AACD,OAAI,iBAAiB;;AAEvB,MAAI,gBAAgB;GAClB,YAAY,GAAG,YAAY,OAAO;GAClC,UAAU,GAAG,YAAY,KAAK;GAC9B,QAAQ,WAAW,OAAO;GAC1B,MAAM,WAAW,KAAK;GACtB,YAAY,IAAI;GAChB,YAAY,IAAI;GAChB,aAAa,IAAI;GAClB;;CAEH,SAAS,gBAAgB,IAAI,OAAO,KAAK;EACvC,IAAI,MAAM,GAAG,MAAM,IAAI;EACvB,IAAI,OAAO,IAAI;EACf,IAAI,SAAS,IAAI;EACjB,IAAI;AACJ,MAAI,eAAe,KAAK,MAAM,EAAE;AAC9B,SAAM;AACN,SAAM;AACN,WAAQ;;AAEV,MAAI,eAAe,MAAM,OAAO,EAAE;AAChC,UAAO,UAAU,OAAO,KAAK;AAC7B,YAAS,UAAU,QAAQ,IAAI;SAC1B;AACL,YAAS,UAAU,OAAO,OAAO;AACjC,UAAO,UAAU,MAAM,IAAI;AAC3B,UAAO,aAAa,MAAM,GAAG,GAAG;AAChC,OAAI,KAAK,MAAM,MAAM,KAAK,QAAQ,GAAG,WAAW,CAC9C,QAAO,IAAI,IAAI,KAAK,OAAO,GAAG,WAAW,IAAI,KAAK,OAAO,EAAE,CAAC;;AAGhE,SAAO,CAAC,QAAQ,KAAK;;;;;;CAMvB,SAAS,kBAAkB,IAAI,KAAK,MAAM;EACxC,IAAI,MAAM,GAAG,MAAM;AACnB,QAAM,OAAO,IAAI;EACjB,IAAI,OACF,QAAQ,IAAI,aAAa,SAAS,IAAI,cAAc,UAAU;EAChE,IAAI,QAAQ,gBAAgB,IAAI,KAAK,KAAK;AAC1C,KAAG,cAAc,MAAM,QAAQ,MAAM,QAAQ;;CAE/C,SAAS,gBAAgB,IAAI,KAAK,MAAM,WAAW;EACjD,IAAI,OAAO,WAAW,IAAI,KAAK;EAC/B,IAAI,SAAS,WAAW,IAAI,OAAO;AACnC,MAAI,QAAQ,QAAQ;GAClB,IAAI,aACF,CAAC,aAAa,CAAC,eAAe,IAAI,MAAM,IAAI,OAAO,GAAG,IAAI;GAC5D,IAAI,eAAe,eAAe,IAAI,MAAM,IAAI,OAAO,GAAG,IAAI;AAC9D,UAAO,aAAa,IAAI,MAAM,GAAG,WAAW;AAC5C,YAAS,aAAa,IAAI,QAAQ,GAAG,aAAa;AAClD,UAAO;IACL,QAAQ,CAAC;KAAU;KAAc;KAAM,CAAC;IACxC,SAAS;IACV;aACQ,QAAQ,QAAQ;AACzB,OAAI,CAAC,eAAe,IAAI,MAAM,IAAI,OAAO,EAAE;AACzC,WAAO,KAAK;IAEZ,IAAI,WAAW,GAAG,UAAU;AAC5B,QAAI,KAAK,OAAO,SACd,MAAK,OAAO;AAEd,SAAK,KAAK,WAAW,IAAI,KAAK,KAAK;UAC9B;AACL,SAAK,KAAK;AACV,WAAO,KAAK,WAAW,IAAI,OAAO,KAAK;;AAEzC,UAAO;IACL,QAAQ,CAAC;KAAU;KAAc;KAAM,CAAC;IACxC,SAAS;IACV;aACQ,QAAQ,SAAS;GAC1B,IAAI,MAAM,KAAK,IAAI,OAAO,MAAM,KAAK,KAAK,EACxC,SAAS,OAAO,IAChB,SAAS,KAAK,IAAI,OAAO,MAAM,KAAK,KAAK,EACzC,OAAO,KAAK;AACd,OAAI,SAAS,KACX,SAAQ;OAER,WAAU;GAEZ,IAAI,SAAS,SAAS,MAAM;GAC5B,IAAI,UAAU,KAAK,QAAQ,MAAM,IAAI,SAAS;GAC9C,IAAI,SAAS,EAAE;AACf,QAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAC1B,QAAO,KAAK;IACV,QAAQ,IAAI,IAAI,MAAM,GAAG,OAAO;IAChC,MAAM,IAAI,IAAI,MAAM,GAAG,KAAK;IAC7B,CAAC;AAEJ,UAAO;IACG;IACC;IACV;;;CAGL,SAAS,QAAQ,IAAI;EACnB,IAAI,MAAM,GAAG,UAAU,OAAO;AAC9B,MAAI,GAAG,cAAc,CAAC,UAAU,EAG9B,OAAM,UAAU,KAAK,GAAG,UAAU,SAAS,CAAC;AAE9C,SAAO;;;;;;;CAQT,SAAS,eAAe,IAAI,UAAU;EACpC,IAAI,MAAM,GAAG,MAAM;AACnB,MAAI,aAAa,MACf,IAAG,UAAU,oBAAoB,IAAI,IAAI,IAAI,KAAK,CAAC;AAErD,sBAAoB,IAAI,IAAI;AAC5B,MAAI,aAAa;AACjB,MAAI,aAAa;AACjB,MAAI,cAAc;AAClB,MAAI,CAAC,IAAI,WACP,oBAAW,OAAO,IAAI,mBAAmB,EAAE,MAAM,UAAU,CAAC;;CAOhE,SAAS,WAAW,IAAI,UAAU,QAAQ;EACxC,IAAI,YAAY,GAAG,SAAS,UAAU,OAAO;AAE7C,MAAI,SAAS,KAAK,UAAU,EAAE;GAC5B,IAAI,QAAQ,UAAU,MAAM,KAAK;AAEjC,SAAM,KAAK;GAKX,IAAI;AAGJ,QACE,IAAI,OAAO,MAAM,KAAK,EACtB,MAAM,SAAS,KAAK,QAAQ,mBAAmB,KAAK,EACpD,OAAO,MAAM,KAAK,EAClB;AACA,WAAO;AACP,WAAO,KAAK;;AAGd,OAAI,MAAM;AACR,WAAO;AACP,WAAO,KAAK,WAAW,IAAI,OAAO,KAAK;SAEvC,QAAO,KAAK;;;CAMlB,SAAS,sBAAsB,KAAK,UAAU,QAAQ;AACpD,WAAS,KAAK;AACd,SAAO,KAAK;AACZ,SAAO;;CAGT,SAAS,gCAAgC,MAAM;AAC7C,MAAI,CAAC,KACH,QAAO;EAET,IAAI,aAAa,KAAK,OAAO,KAAK;AAClC,SAAO,cAAc,KAAK,KAAK,SAAS;;CAG1C,SAAS,sBAAsB,IAAI,WAAW,UAAU,SAAS,UAAU;EACzE,IAAI,MAAM,QAAQ,GAAG;EACrB,IAAI,OAAO,GAAG,QAAQ,IAAI,KAAK;EAC/B,IAAI,MAAM,IAAI;EAId,IAAI,OAAO,WAAW,aAAa,KAAK,gBAAgB;AACxD,SAAO,CAAC,KAAK,KAAK,OAAO,IAAI,CAAC,EAAE;AAC9B;AACA,OAAI,OAAO,KAAK,OACd,QAAO;;AAIX,MAAI,QACF,QAAO,gBAAgB;OAClB;AACL,UAAO,aAAa;AACpB,OAAI,CAAC,KAAK,KAAK,OAAO,IAAI,CAAC,CACzB,QAAO,aAAa;;EAIxB,IAAI,MAAM,KACR,QAAQ;AACV,SAAO,KAAK,KAAK,OAAO,IAAI,CAAC,IAAI,MAAM,KAAK,OAC1C;AAEF,SAAO,KAAK,KAAK,OAAO,MAAM,CAAC,IAAI,SAAS,EAC1C;AAEF;AAEA,MAAI,WAAW;GAGb,IAAI,UAAU;AACd,UAAO,KAAK,KAAK,KAAK,OAAO,IAAI,CAAC,IAAI,MAAM,KAAK,OAC/C;AAEF,OAAI,WAAW,KAAK;IAClB,IAAI,YAAY;AAChB,WAAO,KAAK,KAAK,KAAK,OAAO,QAAQ,EAAE,CAAC,IAAI,QAAQ,EAClD;AAEF,QAAI,CAAC,MACH,SAAQ;;;AAId,SAAO;GAAE,OAAO,IAAI,IAAI,IAAI,MAAM,MAAM;GAAE,KAAK,IAAI,IAAI,IAAI,MAAM,IAAI;GAAE;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA6BzE,SAAS,qBAAqB,IAAI,MAAM,WAAW;EACjD,IAAI,MAAM;AACV,MAAI,CAACA,mBAAW,mBAAmB,CAACA,mBAAW,iBAC7C,QAAO;GAAE,OAAO;GAAK,KAAK;GAAK;EAGjC,IAAI,OACFA,mBAAW,gBAAgB,IAAI,KAAK,IACpCA,mBAAW,iBAAiB,IAAI,KAAK;AACvC,MAAI,CAAC,QAAQ,CAAC,KAAK,QAAQ,CAAC,KAAK,MAC/B,QAAO;GAAE,OAAO;GAAK,KAAK;GAAK;AAGjC,MAAI,UACF,QAAO;GAAE,OAAO,KAAK,KAAK;GAAM,KAAK,KAAK,MAAM;GAAI;AAEtD,SAAO;GAAE,OAAO,KAAK,KAAK;GAAI,KAAK,KAAK,MAAM;GAAM;;CAGtD,SAAS,mBAAmB,IAAI,QAAQ,QAAQ;AAC9C,MAAI,CAAC,YAAY,QAAQ,OAAO,CAC9B,gBAAe,SAAS,IAAI,IAAI,QAAQ,OAAO;;CAInD,SAAS,0BAA0B,WAAW,MAAM;AAClD,iBAAe,oBAAoB,YAAY;AAC/C,iBAAe,oBAAoB,UAAU,KAAK;AAClD,iBAAe,oBAAoB,oBACjC,KAAK;;CAGT,IAAI,eAAe;EACjB,KAAK;EACL,KAAK;EACL,KAAK;EACL,KAAK;EACL,KAAK;EACL,KAAK;EACL,KAAK;EACL,KAAK;EACL,GAAG;EACH,GAAG;EACH,KAAK;EACN;CACD,IAAI,kBAAkB;EACpB,SAAS,EACP,YAAY,SAAU,OAAO;AAC3B,OAAI,MAAM,WAAW,MAAM,MAAM;AAC/B,UAAM;AACN,QAAI,MAAM,SAAS,EAAG,QAAO;cACpB,MAAM,WAAW,MAAM,YAChC,OAAM;AAER,UAAO;KAEV;EACD,SAAS;GACP,MAAM,SAAU,OAAO;AACrB,UAAM,iBAAiB;AACvB,UAAM,QAAQ,MAAM,UAAU,MAAM,SAAS,MAAM,OAAO,MAAM;;GAElE,YAAY,SAAU,OAAO;AAC3B,WAAO,MAAM,UAAU,KAAK,MAAM,WAAW,MAAM;;GAEtD;EACD,SAAS,EACP,YAAY,SAAU,OAAO;GAC3B,IAAI,QAAQ,MAAM,WAAW,OAAO,MAAM,WAAW;AACrD,SAAM,SAAS,MAAM;AACrB,UAAO;KAEV;EAID,QAAQ;GACN,MAAM,SAAU,OAAO;AACrB,UAAM,OAAO,MAAM,SAAS,MAAM,MAAM;AACxC,UAAM,cAAc,MAAM,SAAS,MAAM,MAAM;;GAEjD,YAAY,SAAU,OAAO;AAC3B,QAAI,MAAM,WAAW,MAAM,KAAM,QAAO;AACxC,WAAO;;GAEV;EACD,YAAY;GACV,MAAM,SAAU,OAAO;AACrB,UAAM,QAAQ;;GAEhB,YAAY,SAAU,OAAO;AAC3B,QAAI,MAAM,WAAW,KAAK;KACxB,IAAI,QAAQ,MAAM,SAAS,MAAM,UAAU,CAAC;AAC5C,SAAI,UAAU,SAAS;AACrB,UAAI,MAAM,WAAW,MAAM,UAAU,EACnC,QAAO;AAET,YAAM;gBACG,UAAU,MAAM;AACzB,UAAI,CAAC,MAAM,WAAW,MAAM,UAAU,EACpC,QAAO;AAET,YAAM;;AAER,SAAI,UAAU,UAAU,MAAM,UAAU,EAAG,QAAO;;AAEpD,WAAO;;GAEV;EACF;CACD,SAAS,WAAW,IAAI,QAAQ,SAAS,MAAM;EAC7C,IAAI,MAAM,WAAW,GAAG,WAAW,CAAC;EACpC,IAAI,YAAY,UAAU,IAAI;EAC9B,IAAI,UAAU,UAAU,GAAG,WAAW,GAAG;EACzC,IAAI,QAAQ,IAAI;EAChB,IAAI,OAAO,IAAI;EACf,IAAI,WAAW,GAAG,QAAQ,KAAK;EAC/B,IAAI,QAAQ;GACA;GACV,QAAQ,SAAS,OAAO,MAAM;GAC9B,QAAQ;GACR,OAAO;GACD;GACN,cAAc,UAAU;IAAE,KAAK;IAAK,KAAK;IAAK,GAAG;IAAE,KAAK;IAAK,KAAK;IAAK,EACrE;GAEO;GACT,OAAO;GACP,gBAAgB;GACjB;EACD,IAAI,OAAO,aAAa;AACxB,MAAI,CAAC,KAAM,QAAO;EAClB,IAAI,OAAO,gBAAgB,MAAM;EACjC,IAAI,aAAa,gBAAgB,MAAM;AACvC,MAAI,KACF,MAAK,MAAM;AAEb,SAAO,SAAS,WAAW,QAAQ;AACjC,SAAM,SAAS;AACf,SAAM,SAAS,MAAM,SAAS,OAAO,MAAM,MAAM;AACjD,OAAI,CAAC,MAAM,QAAQ;AACjB,YAAQ;AACR,UAAM,WAAW,GAAG,QAAQ,KAAK,IAAI;AACrC,QAAI,YAAY,EACd,OAAM,QAAQ;SACT;KACL,IAAI,UAAU,MAAM,SAAS;AAC7B,WAAM,QAAQ,UAAU,IAAI,UAAU,IAAI;;AAE5C,UAAM,SAAS,MAAM,SAAS,OAAO,MAAM,MAAM;;AAEnD,OAAI,WAAW,MAAM,EAAE;AACrB,QAAI,OAAO;AACX,QAAI,KAAK,MAAM;AACf;;;AAGJ,MAAI,MAAM,UAAU,MAAM,eACxB,QAAO,IAAI,IAAI,MAAM,MAAM,MAAM;AAEnC,SAAO;;CAoBT,SAAS,SAAS,IAAI,KAAK,SAAS,SAAS,iBAAiB;EAC5D,IAAI,UAAU,IAAI;EAClB,IAAI,MAAM,IAAI;EACd,IAAI,OAAO,GAAG,QAAQ,QAAQ;EAC9B,IAAI,MAAM,UAAU,IAAI;EACxB,IAAI,YAAY,UAAU,kBAAkB;AAE5C,MAAI,mBAAmB,QAAQ,IAAI;AACjC,cAAW;AACX,UAAO,GAAG,QAAQ,QAAQ;AAC1B,OAAI,CAAC,OAAO,IAAI,QAAQ,CACtB,QAAO;AAET,SAAM,UAAU,IAAI,KAAK;;AAG3B,SAAO,MAAM;AACX,OAAI,mBAAmB,QAAQ,GAC7B,QAAO;IAAE,MAAM;IAAG,IAAI;IAAG,MAAM;IAAS;GAE1C,IAAI,OAAO,MAAM,IAAI,KAAK,SAAS;GACnC,IAAI,YAAY,MACd,UAAU;AAEZ,UAAO,OAAO,MAAM;IAClB,IAAI,YAAY;AAChB,SAAK,IAAI,IAAI,GAAG,IAAI,UAAU,UAAU,CAAC,WAAW,EAAE,EACpD,KAAI,UAAU,GAAG,KAAK,OAAO,IAAI,CAAC,EAAE;AAClC,iBAAY;AAEZ,YAAO,OAAO,QAAQ,UAAU,GAAG,KAAK,OAAO,IAAI,CAAC,CAClD,QAAO;AAET,eAAU;AACV,iBAAY,aAAa;AACzB,SACE,aAAa,IAAI,MACjB,WAAW,IAAI,QACf,WAAW,YAAY,IAGvB;SAEA,QAAO;MACL,MAAM,KAAK,IAAI,WAAW,UAAU,EAAE;MACtC,IAAI,KAAK,IAAI,WAAW,QAAQ;MAChC,MAAM;MACP;;AAIP,QAAI,CAAC,UACH,QAAO;;AAIX,cAAW;AACX,OAAI,CAAC,OAAO,IAAI,QAAQ,CACtB,QAAO;AAET,UAAO,GAAG,QAAQ,QAAQ;AAC1B,SAAM,MAAM,IAAI,IAAI,KAAK;;;;;;;;;;;;;;;CAgB7B,SAAS,WAAW,IAAI,KAAK,QAAQ,SAAS,SAAS,SAAS;EAC9D,IAAI,WAAW,WAAW,IAAI;EAC9B,IAAI,QAAQ,EAAE;AACd,MAAK,WAAW,CAAC,WAAa,CAAC,WAAW,QACxC;EAGF,IAAI,kBAAkB,EAAE,WAAW;AACnC,OAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK;GAC/B,IAAI,OAAO,SAAS,IAAI,KAAK,SAAS,SAAS,gBAAgB;AAC/D,OAAI,CAAC,MAAM;IACT,IAAI,QAAQ,WAAW,IAAI,GAAG,UAAU,CAAC;AACzC,UAAM,KACJ,UACI;KAAE,MAAM,GAAG,UAAU;KAAE,MAAM;KAAO,IAAI;KAAO,GAC/C;KAAE,MAAM;KAAG,MAAM;KAAG,IAAI;KAAG,CAChC;AACD;;AAEF,SAAM,KAAK,KAAK;AAChB,SAAM,IAAI,IAAI,KAAK,MAAM,UAAU,KAAK,KAAK,IAAI,KAAK,KAAK;;EAE7D,IAAI,eAAe,MAAM,UAAU;EACnC,IAAI,YAAY,MAAM;EACtB,IAAI,WAAW,MAAM,KAAK;AAC1B,MAAI,WAAW,CAAC,SAAS;AAEvB,OACE,CAAC,iBACA,UAAU,QAAQ,SAAS,MAAM,UAAU,QAAQ,SAAS,MAG7D,YAAW,MAAM,KAAK;AAExB,UAAO,IAAI,IAAI,SAAS,MAAM,SAAS,KAAK;aACnC,WAAW,QACpB,QAAO,IAAI,IAAI,SAAS,MAAM,SAAS,KAAK,EAAE;WACrC,CAAC,WAAW,SAAS;AAE9B,OACE,CAAC,iBACA,UAAU,MAAM,SAAS,MAAM,UAAU,QAAQ,SAAS,MAG3D,YAAW,MAAM,KAAK;AAExB,UAAO,IAAI,IAAI,SAAS,MAAM,SAAS,GAAG;QAG1C,QAAO,IAAI,IAAI,SAAS,MAAM,SAAS,KAAK;;CAIhD,SAAS,UAAU,IAAI,MAAM,YAAY,KAAK,UAAU;EAEtD,IAAI,SAAS,IAAI,IADP,KACe,OAAO,WAAW,SAAS,GAAG,SAAS;EAChE,IAAI,MAAM,GAAG,QAAQ,OAAO;AAC5B,MAAI;AACJ,MAAI,CAAC,UAAU;AACb,OAAI,WAAW;AACf,OAAI,YAAY,GAAG,WAAW,KAAK,MAAM,CAAC;;AAE5C,SAAO;;CAGT,SAAS,gBAAgB,IAAI,QAAQ,SAAS,WAAW;EACvD,IAAI,MAAM,GAAG,WAAW;EACxB,IAAI,QAAQ,IAAI;EAChB,IAAI;AACJ,OAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK;GAC/B,IAAI,OAAO,GAAG,QAAQ,IAAI,KAAK;AAC/B,SAAM,cAAc,OAAO,MAAM,WAAW,SAAS,KAAK;AAC1D,OAAI,OAAO,GACT,QAAO;AAET,WAAQ;;AAEV,SAAO,IAAI,IAAI,GAAG,WAAW,CAAC,MAAM,IAAI;;CAG1C,SAAS,aAAa,IAAI,QAAQ;EAGhC,IAAI,OAAO,GAAG,WAAW,CAAC;AAC1B,SAAO,oBAAoB,IAAI,IAAI,IAAI,MAAM,SAAS,EAAE,CAAC;;CAG3D,SAAS,WAAW,IAAI,KAAK,UAAU,KAAK;AAC1C,MAAI,CAAC,QAAQ,UAAU,WAAW,CAChC;AAEF,MAAI,IAAI,MAAM,UACZ,KAAI,MAAM,UAAU,OAAO;AAE7B,MAAI,MAAM,YAAY,GAAG,YAAY,IAAI;;CAG3C,SAAS,cAAc,OAAO,MAAM,WAAW,SAAS,aAAa;EAMnE,IAAI;AACJ,MAAI,SAAS;AACX,SAAM,KAAK,QAAQ,WAAW,QAAQ,EAAE;AACxC,OAAI,OAAO,MAAM,CAAC,YAChB,QAAO;SAEJ;AACL,SAAM,KAAK,YAAY,WAAW,QAAQ,EAAE;AAC5C,OAAI,OAAO,MAAM,CAAC,YAChB,QAAO;;AAGX,SAAO;;CAGT,SAAS,cAAc,IAAI,MAAM,QAAQ,KAAK,WAAW;EACvD,IAAI,OAAO,KAAK;EAChB,IAAI,MAAM,GAAG,WAAW;EACxB,IAAI,MAAM,GAAG,UAAU;EACvB,IAAI,OACF,KACA,IAAI;EACN,SAAS,QAAQ,KAAG;AAClB,UAAO,CAAC,GAAG,QAAQK,IAAE;;EAEvB,SAAS,WAAW,KAAG,OAAK,KAAK;AAC/B,OAAI,IACF,QAAO,QAAQA,IAAE,IAAI,QAAQA,MAAIC,MAAI;AAEvC,UAAO,CAAC,QAAQD,IAAE,IAAI,QAAQA,MAAIC,MAAI;;AAExC,MAAI,KAAK;AACP,UAAO,OAAO,KAAK,KAAK,OAAO,SAAS,GAAG;AACzC,QAAI,WAAW,GAAG,IAAI,CACpB;AAEF,SAAK;;AAEP,UAAO,IAAI,IAAI,GAAG,EAAE;;EAGtB,IAAI,MAAM,GAAG,MAAM;AACnB,MAAI,IAAI,cAAc,WAAW,MAAM,GAAG,KAAK,EAAE;GAC/C,IAAI,SAAS,IAAI,IAAI;AACrB,OAAI,WAAW,OAAO,MAAM,IAAI,KAAK,EACnC;QAAI,CAAC,aAAa,OAAO,QAAQ,KAC/B,SAAQ;;;EAId,IAAI,aAAa,QAAQ,KAAK;AAC9B,OAAK,IAAI,MAAM,KAAK,OAAO,QAAQ,IACjC,KAAI,WAAW,GAAG,GAAG,KAAK,EACxB;OAAI,CAAC,aAAa,QAAQ,EAAE,IAAI,WAC9B;;AAIN,QAAM,IAAI,IAAI,GAAG,EAAE;AAEnB,MAAI,IAAI,OAAO,CAAC,WACd,cAAa;MAEb,aAAY;AAEd,OAAK,IAAI,MAAM,IAAI,KAAK,IACtB,KAAI,CAAC,aAAa,QAAQ,EAAE,IAAI,cAAc,KAAK,MACjD;OAAI,WAAW,GAAG,IAAI,KAAK,CACzB;;AAIN,UAAQ,IAAI,IAAI,GAAG,EAAE;AACrB,SAAO;GAAS;GAAY;GAAK;;CAGnC,SAAS,aAAa,IAAI,KAAK,QAAQ,KAAK;EAa1C,SAAS,SAAS,MAAI,KAAK;AACzB,OAAI,IAAI,MAAM,IAAI,MAAM,KAAK,IAAI,MAAM,IAAI,OAAO,IAAI,KAAK,QAAQ;AACjE,QAAI,MAAM,IAAI;AACd,QAAI,CAAC,OAAOC,MAAI,IAAI,GAAG,EAAE;AACvB,SAAI,OAAO;AACX,SAAI,KAAK;AACT,SAAI,MAAM;AACV;;AAEF,QAAI,OAAOA,KAAG,QAAQ,IAAI,GAAG;AAC7B,QAAI,MAAM,IAAI,MAAM,IAAI,IAAI,IAAI,KAAK,SAAS;SAE9C,KAAI,OAAO,IAAI;;EAQnB,SAAS,QAAQ,MAAI,IAAI,KAAK,OAAK;GACjC,IAAI,OAAOA,KAAG,QAAQ,GAAG;GACzB,IAAI,OAAO,SAAS;GAEpB,IAAI,OAAO;IACH;IACF;IACC;IACL,KAAKD;IACN;GAED,IAAI,aAAa;IACf,IAAI,KAAK;IACT,KAAK,KAAK;IACX;GAED,IAAI,mBAAmB,KAAK,SAAS;AAGrC,YAASC,MAAI,KAAK;AAElB,UAAO,KAAK,SAAS,MAAM;AACzB,eAAW,KAAK,KAAK;AACrB,eAAW,MAAM,KAAK;AAEtB,QAAI,KAAK,SAAS,MAAM,CAAC,iBACvB,QAAO;KAAE,IAAI,KAAK;KAAI,KAAK,KAAK;KAAK;aAErC,QACA,KAAK,SAAS,MACd,CAAC,mBAAmB,KAAK,KAAK,KAAK,KAAK,CAExC,QAAO;KAAE,IAAI,KAAK;KAAI,KAAK,KAAK;KAAK;aAErC,sBAAsB,KAAK,KAAK,KAAK,KAAK,IAC1C,CAAC,SACA,KAAK,QAAQ,KAAK,KAAK,SAAS,KAC/B,mBAAmB,KAAK,KAAK,KAAK,MAAM,GAAG,EAE7C,QAAO;AAGT,aAASA,MAAI,KAAK;;GAOpB,IAAI,OAAOA,KAAG,QAAQ,WAAW,GAAG;AACpC,cAAW,MAAM;AACjB,QAAK,IAAI,IAAI,KAAK,SAAS,GAAG,KAAK,GAAG,EAAE,EACtC,KAAI,CAAC,mBAAmB,KAAK,GAAG,EAAE;AAChC,eAAW,MAAM;AACjB;;AAIJ,UAAO;;EAOT,SAAS,QAAQ,MAAI,IAAI,KAAK,OAAK;GACjC,IAAI,OAAOA,KAAG,QAAQ,GAAG;GAEzB,IAAI,OAAO;IACH;IACF;IACC;IACL,KAAKD;IACN;GAED,IAAI,aAAa;IACf,IAAI,KAAK;IACT,KAAK;IACN;GAED,IAAI,mBAAmB,KAAK,SAAS;AAGrC,YAASC,MAAI,KAAK;AAElB,UAAO,KAAK,SAAS,MAAM;AACzB,QAAI,KAAK,SAAS,MAAM,CAAC,iBACvB,KAAI,WAAW,QAAQ,KACrB,QAAO;QAEP,QAAO;KAAE,IAAI,KAAK;KAAI,KAAK,KAAK;KAAK;aAGvC,sBAAsB,KAAK,KAAK,KAAK,KAAK,IAC1C,WAAW,QAAQ,QACnB,EAAE,KAAK,OAAO,WAAW,MAAM,KAAK,MAAM,MAAM,WAAW,KAE3D,QAAO;aAEP,KAAK,SAAS,MACd,CAAC,mBAAmB,KAAK,KAAK,KAAK,KAAK,EACxC;AACA,wBAAmB;AACnB,kBAAa;MAAE,IAAI,KAAK;MAAI,KAAK,KAAK;MAAK;;AAG7C,aAASA,MAAI,KAAK;;GAOpB,IAAI,OAAOA,KAAG,QAAQ,WAAW,GAAG;AACpC,cAAW,MAAM;AACjB,QAAK,IAAI,IAAI,GAAG,IAAI,KAAK,QAAQ,EAAE,EACjC,KAAI,CAAC,mBAAmB,KAAK,GAAG,EAAE;AAChC,eAAW,MAAM;AACjB;;AAGJ,UAAO;;EAGT,IAAI,aAAa;GACf,IAAI,IAAI;GACR,KAAK,IAAI;GACV;AAED,SAAO,SAAS,GAAG;AACjB,OAAI,MAAM,EACR,cAAa,QAAQ,IAAI,WAAW,IAAI,WAAW,KAAK,IAAI;OAE5D,cAAa,QAAQ,IAAI,WAAW,IAAI,WAAW,KAAK,IAAI;AAE9D;;AAGF,SAAO,IAAI,IAAI,WAAW,IAAI,WAAW,IAAI;;CAK/C,SAAS,sBAAsB,IAAI,MAAM,MAAM,WAAW;EACxD,IAAI,MAAM,MACR,OACA;EAEF,IAAI,gBAAgB;GAClB,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACN,CAAC;EACF,IAAI,UAAU;GACZ,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACL,KAAK;GACN,CAAC;EAIF,IAAI,SAHU,GAAG,QAAQ,IAAI,KAAK,CAAC,OAAO,IAAI,GAAG,KAGxB,UAAU,IAAI;AAEvC,UAAQ,GAAG,eACT,IAAI,IAAI,IAAI,MAAM,IAAI,KAAK,OAAO,EAClC,IACA,QACA,EAAE,cAAc,eAAe,CAChC;AACD,QAAM,GAAG,eAAe,IAAI,IAAI,IAAI,MAAM,IAAI,KAAK,OAAO,EAAE,GAAG,QAAW,EACxE,cAAc,eACf,CAAC;AAEF,MAAI,CAAC,SAAS,CAAC,IACb,QAAO;GAAE,OAAO;GAAK,KAAK;GAAK;AAGjC,UAAQ,MAAM;AACd,QAAM,IAAI;AAEV,MACG,MAAM,QAAQ,IAAI,QAAQ,MAAM,KAAK,IAAI,MAC1C,MAAM,OAAO,IAAI,MACjB;GACA,IAAI,MAAM;AACV,WAAQ;AACR,SAAM;;AAGR,MAAI,UACF,KAAI,MAAM;MAEV,OAAM,MAAM;AAGd,SAAO;GAAS;GAAY;GAAK;;CAMnC,SAAS,oBAAoB,IAAI,MAAM,MAAM,WAAW;EACtD,IAAI,MAAM,WAAW,KAAK;EAE1B,IAAI,QADO,GAAG,QAAQ,IAAI,KAAK,CACd,MAAM,GAAG;EAC1B,IAAI,OAAO,KAAK,GAAG;EACnB,IAAI,aAAa,MAAM,QAAQ,KAAK;AAKpC,MAAI,IAAI,KAAK,WACX,KAAI,KAAK;WAKF,aAAa,IAAI,MAAM,MAAM,IAAI,OAAO,MAAM;AACrD,SAAM,IAAI;AACV,KAAE,IAAI;;AAIR,MAAI,MAAM,IAAI,OAAO,QAAQ,CAAC,IAC5B,SAAQ,IAAI,KAAK;MAGjB,MAAK,IAAI,IAAI,IAAI,IAAI,MAAM,CAAC,OAAO,IACjC,KAAI,MAAM,MAAM,KACd,SAAQ,IAAI;AAMlB,MAAI,SAAS,CAAC,KACZ;QAAK,IAAI,OAAO,MAAM,MAAM,QAAQ,IAAI,OAAO,CAAC,KAAK,IACnD,KAAI,MAAM,MAAM,KACd,OAAM;;AAMZ,MAAI,CAAC,SAAS,CAAC,IACb,QAAO;GAAE,OAAO;GAAK,KAAK;GAAK;AAIjC,MAAI,WAAW;AACb,KAAE;AACF,KAAE;;AAGJ,SAAO;GACL,OAAO,IAAI,IAAI,IAAI,MAAM,MAAM;GAC/B,KAAK,IAAI,IAAI,IAAI,MAAM,IAAI;GAC5B;;AAIH,cAAa,QAAQ,MAAM,UAAU;CACrC,SAAS,cAAc;AACvB,aAAY,YAAY;EACtB,UAAU,WAAY;AACpB,UAAO,eAAe;;EAExB,UAAU,SAAU,OAAO;AACzB,kBAAe,QAAQ;;EAEzB,YAAY,WAAY;AACtB,UAAO,KAAK;;EAEd,YAAY,SAAU,SAAS;AAC7B,QAAK,gBAAgB;;EAEvB,YAAY,WAAY;AACtB,UAAO,eAAe;;EAExB,aAAa,SAAU,UAAU;AAC/B,kBAAe,aAAa;;EAE9B,sBAAsB,WAAY;AAChC,UAAO,KAAK;;EAEd,sBAAsB,SAAU,UAAU;AACxC,QAAK,WAAW;;EAEnB;CACD,SAAS,eAAe,IAAI;EAC1B,IAAI,MAAM,GAAG,MAAM;AACnB,SAAO,IAAI,iBAAiB,IAAI,eAAe,IAAI,aAAa;;CAElE,SAAS,aAAa,WAAW;AAC/B,SAAO,iBAAiB,WAAW,IAAI;;CAGzC,SAAS,qBAAqB,WAAW;AACvC,SAAO,wBAAwB,WAAW,IAAI;;CAGhD,SAAS,iBAAiB,WAAW,WAAW;EAC9C,IAAI,UAAU,wBAAwB,WAAW,UAAU,IAAI,EAAE;AACjE,MAAI,CAAC,QAAQ,OAAQ,QAAO,EAAE;EAC9B,IAAI,SAAS,EAAE;AAEf,MAAI,QAAQ,OAAO,EAAG;AACtB,OAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,QAAQ,IAClC,KAAI,OAAO,QAAQ,MAAM,SACvB,QAAO,KAAK,UAAU,UAAU,QAAQ,KAAK,GAAG,QAAQ,IAAI,GAAG,CAAC;AAEpE,SAAO;;CAGT,SAAS,wBAAwB,KAAK,WAAW;AAC/C,MAAI,CAAC,UAAW,aAAY;EAE5B,IAAI,iBAAiB;EACrB,IAAI,UAAU,EAAE;AAChB,OAAK,IAAI,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;GACnC,IAAI,IAAI,IAAI,OAAO,EAAE;AACrB,OAAI,CAAC,kBAAkB,KAAK,UAC1B,SAAQ,KAAK,EAAE;AAEjB,oBAAiB,CAAC,kBAAkB,KAAK;;AAE3C,SAAO;;CAIT,SAAS,eAAe,KAAK;EAE3B,IAAI,WAAW;EAEf,IAAI,WAAW;EACf,IAAI,iBAAiB;EACrB,IAAI,MAAM,EAAE;AACZ,OAAK,IAAI,IAAI,IAAI,IAAI,IAAI,QAAQ,KAAK;GACpC,IAAI,IAAI,IAAI,OAAO,EAAE,IAAI;GACzB,IAAI,IAAI,IAAI,OAAO,IAAI,EAAE,IAAI;GAC7B,IAAI,mBAAmB,KAAK,SAAS,QAAQ,EAAE,IAAI;AACnD,OAAI,gBAAgB;AAClB,QAAI,MAAM,QAAQ,CAAC,iBACjB,KAAI,KAAK,EAAE;AAEb,qBAAiB;cAEb,MAAM,MAAM;AACd,qBAAiB;AAEjB,QAAI,KAAK,SAAS,QAAQ,EAAE,IAAI,GAC9B,oBAAmB;AAGrB,QAAI,CAAC,oBAAoB,MAAM,KAC7B,KAAI,KAAK,EAAE;UAER;AACL,QAAI,KAAK,EAAE;AACX,QAAI,oBAAoB,MAAM,KAC5B,KAAI,KAAK,KAAK;;;AAKtB,SAAO,IAAI,KAAK,GAAG;;CAMrB,IAAI,gBAAgB;EAAE,OAAO;EAAM,OAAO;EAAM,OAAO;EAAM;CAC7D,SAAS,sBAAsB,KAAK;EAClC,IAAI,iBAAiB;EACrB,IAAI,MAAM,EAAE;AACZ,OAAK,IAAI,IAAI,IAAI,IAAI,IAAI,QAAQ,KAAK;GACpC,IAAI,IAAI,IAAI,OAAO,EAAE,IAAI;GACzB,IAAI,IAAI,IAAI,OAAO,IAAI,EAAE,IAAI;AAC7B,OAAI,cAAc,IAAI,IAAI;AACxB,QAAI,KAAK,cAAc,IAAI,GAAG;AAC9B;cACS,gBAAgB;AAGzB,QAAI,KAAK,EAAE;AACX,qBAAiB;cAEb,MAAM,MAAM;AACd,qBAAiB;AACjB,QAAI,SAAS,EAAE,IAAI,MAAM,IACvB,KAAI,KAAK,IAAI;aACJ,MAAM,OAAO,MAAM,KAC5B,KAAI,KAAK,KAAK;UAEX;AACL,QAAI,MAAM,IACR,KAAI,KAAK,IAAI;AAEf,QAAI,KAAK,EAAE;AACX,QAAI,MAAM,IACR,KAAI,KAAK,KAAK;;;AAKtB,SAAO,IAAI,KAAK,GAAG;;CAIrB,IAAI,YAAY;EACd,OAAO;EACP,QAAQ;EACR,OAAO;EACP,OAAO;EACP,OAAO;EACP,OAAO;EACR;CACD,SAAS,qBAAqB,KAAK;EACjC,IAAI,SAAS,IAAIP,mBAAW,aAAa,IAAI;EAC7C,IAAI,SAAS,EAAE;AACf,SAAO,CAAC,OAAO,KAAK,EAAE;AAEpB,UAAO,OAAO,MAAM,IAAI,OAAO,MAAM,IAAI,KACvC,QAAO,KAAK,OAAO,MAAM,CAAC;GAE5B,IAAI,UAAU;AACd,QAAK,IAAI,WAAW,UAClB,KAAI,OAAO,MAAM,SAAS,KAAK,EAAE;AAC/B,cAAU;AACV,WAAO,KAAK,UAAU,SAAS;AAC/B;;AAGJ,OAAI,CAAC,QAEH,QAAO,KAAK,OAAO,MAAM,CAAC;;AAG9B,SAAO,OAAO,KAAK,GAAG;;;;;;;;;;;;CAaxB,SAAS,WAAW,OAAO,YAAY,WAAW;AAGhD,EADyB,eAAe,mBAAmB,YAAY,IAAI,CACxD,QAAQ,MAAM;AAEjC,MAAI,iBAAiB,OACnB,QAAO;EAKT,IAAI,UAAU,qBAAqB,MAAM;EACzC,IAAI;EACJ,IAAI;AACJ,MAAI,CAAC,QAAQ,OAEX,aAAY;OACP;AAEL,eAAY,MAAM,UAAU,GAAG,QAAQ,GAAG;AAE1C,qBADgB,MAAM,UAAU,QAAQ,GAAG,CACf,QAAQ,IAAI,IAAI;;AAE9C,MAAI,CAAC,UACH,QAAO;AAET,MAAI,CAAC,UAAU,OAAO,CACpB,aAAY,eAAe,UAAU;AAEvC,MAAI,UACF,cAAa,YAAY,KAAK,UAAU;AAM1C,SAJa,IAAI,OACf,WACA,cAAc,kBAAkB,OAAO,IACxC;;;;;;;;;;;;CAcH,SAAS,IAAI,GAAG;AACd,MAAI,OAAO,MAAM,SAAU,KAAI,SAAS,cAAc,EAAE;AACxD,OAAK,IAAI,GAAG,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AAC5C,OAAI,EAAE,IAAI,UAAU,IAAK;AACzB,OAAI,OAAO,MAAM,SAAU,KAAI,SAAS,eAAe,EAAE;AACzD,OAAI,EAAE,SAAU,GAAE,YAAY,EAAE;OAE9B,MAAK,IAAI,OAAO,GAAG;AACjB,QAAI,CAAC,OAAO,UAAU,eAAe,KAAK,GAAG,IAAI,CAAE;AACnD,QAAI,IAAI,OAAO,IAAK,GAAE,MAAM,IAAI,MAAM,EAAE,IAAI,EAAE;QACzC,GAAE,aAAa,KAAK,EAAE,KAAK;;;AAGtC,SAAO;;CAGT,SAAS,YAAY,IAAI,UAAU;EACjC,IAAI,MAAM,IAAI,OAAO;GAAE,QAAQ;GAAO,OAAO;GAAkB,EAAE,SAAS;AAC1E,MAAI,GAAG,iBACL,IAAG,iBAAiB,KAAK;GAAE,QAAQ;GAAM,UAAU;GAAM,CAAC;MAE1D,OAAM,IAAI,UAAU;;CAIxB,SAAS,WAAW,QAAQ,MAAM;AAChC,SAAO,IACL,SAAS,wBAAwB,EACjC,IACE,QACA;GAAE,aAAa;GAAa,aAAa;GAAO,EAChD,QACA,IAAI,SAAS;GACX,MAAM;GACN,aAAa;GACb,gBAAgB;GAChB,YAAY;GACb,CAAC,CACH,EACD,QAAQ,IAAI,QAAQ,EAAE,QAAQ,QAAQ,EAAE,KAAK,CAC9C;;CAGH,SAAS,WAAW,IAAI,WAAS;EAC/B,IAAI,WAAW,WAAWQ,UAAQ,QAAQA,UAAQ,KAAK;AACvD,MAAI,GAAG,WACL,IAAG,WAAW,UAAUA,UAAQ,SAAS;GACvC,WAAWA,UAAQ;GACnB,SAASA,UAAQ;GACjB,QAAQ;GACR,mBAAmB;GACnB,OAAOA,UAAQ;GAChB,CAAC;OACG;GACL,IAAI,YAAY;AAChB,OAAI,OAAOA,UAAQ,UAAU,YAAYA,UAAQ,OAC/C,cAAaA,UAAQ,OAAO;AAC9B,OAAIA,UAAQ,KAAM,cAAa,MAAMA,UAAQ;AAC7C,aAAQ,QAAQ,OAAO,WAAW,GAAG,CAAC;;;CAI1C,SAAS,WAAW,IAAI,IAAI;AAC1B,MAAI,cAAc,UAAU,cAAc,QAAQ;GAChD,IAAI,QAAQ;IAAC;IAAU;IAAa;IAAc;IAAS;AAC3D,QAAK,IAAI,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;IACrC,IAAI,OAAO,MAAM;AACjB,QAAI,GAAG,UAAU,GAAG,MAClB,QAAO;;AAGX,UAAO;;AAET,SAAO;;CAGT,SAAS,kBAAkB,IAAI,UAAU,YAAY,WAAW;AAC9D,MAAI,CAAC,SACH;EAEF,IAAI,QAAQ,eAAe,GAAG;EAC9B,IAAI,QAAQ,WAAW,UAAU,CAAC,CAAC,YAAY,CAAC,CAAC,UAAU;AAC3D,MAAI,CAAC,MACH;AAEF,yBAAuB,IAAI,MAAM;AACjC,MAAI,WAAW,OAAO,MAAM,UAAU,CAAC,CACrC,QAAO;AAET,QAAM,SAAS,MAAM;AACrB,SAAO;;CAET,SAAS,cAAc,OAAO;AAC5B,MAAI,MAAM,OAAO,OAAO,EAAE,IAAI,KAC5B,IAAI,WAAW;AAEjB,SAAO;GACL,OAAO,SAAU,QAAQ;AACvB,QAAI,YAAY,CAAC,OAAO,KAAK,EAAE;AAC7B,YAAO,WAAW;AAClB;;IAEF,IAAI,QAAQ,OAAO,MAAM,OAAO,MAAM;AACtC,QAAI,OAAO;AACT,SAAI,MAAM,GAAG,UAAU,GAAG;AAExB,aAAO,MAAM;AACb,aAAO;;AAET,SAAI,CAAC,OAAO,KAAK,EAAE;AAEjB,aAAO,OAAO,EAAE;AAChB,UAAI,CAAC,MAAM,KAAK,OAAO,MAAM,GAAG,MAAM,GAAG,EAAE;AACzC,cAAO,MAAM;AACb,cAAO;;;AAGX,YAAO,MAAM,MAAM;AACnB,YAAO;;AAET,WAAO,CAAC,OAAO,KAAK,EAAE;AACpB,YAAO,MAAM;AACb,SAAI,OAAO,MAAM,OAAO,MAAM,CAAE;;;GAG7B;GACR;;CAEH,IAAI,mBAAmB;CACvB,SAAS,uBAAuB,IAAI,OAAO;AACzC,eAAa,iBAAiB;AAC9B,qBAAmB,WAAW,WAAY;AACxC,OAAI,CAAC,GAAG,MAAM,IAAK;GACnB,IAAI,cAAc,eAAe,GAAG;GACpC,IAAI,UAAU,YAAY,YAAY;AACtC,OAAI,CAAC,WAAW,SAAS,QAAQ,OAAO;AACtC,QAAI,QACF,IAAG,cAAc,QAAQ;AAE3B,cAAU,cAAc,MAAM;AAC9B,OAAG,WAAW,QAAQ;AACtB,QAAI,GAAG,wBAAwB;AAC7B,SAAI,YAAY,sBAAsB,CACpC,aAAY,sBAAsB,CAAC,OAAO;AAE5C,iBAAY,qBAAqB,GAAG,uBAAuB,MAAM,CAAC;;AAEpE,gBAAY,WAAW,QAAQ;;KAEhC,GAAG;;CAER,SAAS,SAAS,IAAI,MAAM,OAAO,QAAQ;AACzC,MAAI,WAAW,OACb,UAAS;AAEX,SAAO,GAAG,UAAU,WAAY;GAC9B,IAAI,MAAM,GAAG,WAAW;GACxB,IAAI,SAAS,GAAG,gBAAgB,OAAO,IAAI;AAC3C,QAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK;IAC/B,IAAI,QAAQ,OAAO,KAAK,KAAK;AAC7B,QAAI,KAAK,KAAK,SAAS,YAAY,OAAO,MAAM,EAAE,IAAI,EAAE;KACtD,IAAI,aAAa,OAAO,OAAO,MAAM,GAAG,OAAO,IAAI;AACnD,aAAQ,OAAO,KAAK,KAAK;AACzB,SAAI,SAAS,CAAC,MAAM,MAAM,YAAY,OAAO,MAAM,EAAE,WAAW,EAC9D;UAAI,GAAG,QAAQ,WAAW,KAAK,CAAC,UAAU,WAAW,GACnD,SAAQ,OAAO,KAAK,KAAK;;;AAG/B,QAAI,CAAC,OAAO;AAGV,cAAS,GAAG,gBACV,OACA,OAAO,IAAI,IAAI,GAAG,UAAU,CAAC,GAAG,IAAI,IAAI,GAAG,WAAW,EAAE,EAAE,CAC3D;AACD,SAAI,CAAC,OAAO,KAAK,KAAK,CACpB;;;AAIN,UAAO,OAAO,MAAM;IACpB;;;;;;;;;CASJ,SAAS,2BAA2B,IAAI,MAAM,OAAO,QAAQ,KAAK;AAChE,MAAI,WAAW,OACb,UAAS;AAEX,SAAO,GAAG,UAAU,WAAY;GAC9B,IAAI,MAAM,GAAG,WAAW;GACxB,IAAI,SAAS,GAAG,gBAAgB,OAAO,IAAI;GAG3C,IAAI,QAAQ,OAAO,KAAK,CAAC,KAAK;AAG9B,OAAI,CAAC,IAAI,cAAc,SAAS,YAAY,OAAO,MAAM,EAAE,IAAI,CAC7D,QAAO,KAAK,CAAC,KAAK;AAGpB,QAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,YAAQ,OAAO,KAAK,KAAK;AACzB,QAAI,CAAC,OAAO;AAGV,cAAS,GAAG,gBACV,OACA,OAAO,IAAI,IAAI,GAAG,UAAU,CAAC,GAAG,IAAI,IAAI,GAAG,WAAW,EAAE,EAAE,CAC3D;AACD,SAAI,CAAC,OAAO,KAAK,KAAK,CACpB;;;AAIN,UAAO,CAAC,OAAO,MAAM,EAAE,OAAO,IAAI,CAAC;IACnC;;CAEJ,SAAS,qBAAqB,IAAI;EAChC,IAAI,QAAQ,eAAe,GAAG;AAC9B,KAAG,cAAc,eAAe,GAAG,CAAC,YAAY,CAAC;AACjD,QAAM,WAAW,KAAK;AACtB,MAAI,MAAM,sBAAsB,EAAE;AAChC,SAAM,sBAAsB,CAAC,OAAO;AACpC,SAAM,qBAAqB,KAAK;;;;;;;;;;;;;;CAcpC,SAAS,UAAU,KAAK,OAAO,KAAK;AAClC,MAAI,OAAO,OAAO,SAEhB,OAAM,IAAI;AAEZ,MAAI,iBAAiB,MACnB,QAAO,QAAQ,KAAK,MAAM;WAEtB,OAAO,OAAO,SAChB,QAAO,OAAO,SAAS,OAAO;MAE9B,QAAO,OAAO;;CAIpB,SAAS,oBAAoB,IAAI;EAC/B,IAAI,aAAa,GAAG,eAAe;EACnC,IAAI,sBAAsB;EAC1B,IAAI,yBAAyB;EAC7B,IAAI,OAAO,GAAG,WACZ;GAAE,MAAM;GAAG,KAAK,sBAAsB,WAAW;GAAK,EACtD,QACD;EACD,IAAI,UACF,WAAW,eAAe,yBAAyB,WAAW;EAChE,IAAI,KAAK,GAAG,WAAW;GAAE,MAAM;GAAG,KAAK;GAAS,EAAE,QAAQ;AAC1D,SAAO;GAAE,KAAK,KAAK;GAAM,QAAQ,GAAG;GAAM;;CAG5C,SAAS,WAAW,IAAI,KAAK,UAAU;AACrC,MAAI,YAAY,OAAO,YAAY,IACjC,QAAO,eAAe,SAAS,KAAK,IAAI,GAAG,IAAI,IAAI,IAAI,GAAG,EAAE;WACnD,YAAY,IACrB,QAAO,eAAe,GAAG;EAG3B,IAAI,OAAO,IAAI,MAAM;AACrB,SAAO,QAAQ,KAAK,MAAM;;CAG5B,SAAS,eAAe,IAAI;EAC1B,IAAI,OAAO,GAAG,IAAI,QAAQ;AAC1B,OAAK,IAAI,IAAI,KAAK,QAAQ,KACxB,KAAI,KAAK,GAAG,QACV,QAAO,WAAW,KAAK,GAAG,QAAQ,GAAG,GAAG;;CAK9C,IAAI,sBAAsB,WAAY;AACpC,OAAK,kBAAkB;;AAEzB,qBAAoB,YAAY;EAC9B,gBAAgB,SAAU,IAAI,OAAO,YAAY;GAC/C,IAAI,OAAO;AACX,MAAG,UAAU,WAAY;AACvB,OAAG,MAAM,UAAU;AACnB,SAAK,gBAAgB,IAAI,OAAO,WAAW;KAC3C;;EAEJ,iBAAiB,SAAU,IAAI,OAAO,YAAY;GAChD,IAAI,MAAM,GAAG,MAAM;GACnB,IAAI,yBACF,eAAe,mBAAmB,YAAY,IAAI;GACpD,IAAI,kBAAkB,uBAAuB,UAAU;AACvD,OAAI,IAAI,WACN,gBAAe,GAAG;GAEpB,IAAI,cAAc,IAAIR,mBAAW,aAAa,MAAM;AAEpD,0BAAuB,QAAQ,MAAM;GACrC,IAAI,SAAS,cAAc,EAAE;AAC7B,UAAO,QAAQ;AACf,OAAI;AACF,SAAK,YAAY,IAAI,aAAa,OAAO;YAClC,GAAG;AACV,gBAAY,IAAI,EAAE,UAAU,CAAC;AAC7B,UAAM;;GAER,IAAI;GACJ,IAAI;AACJ,OAAI,CAAC,OAAO,aAEV;QAAI,OAAO,SAAS,OAClB,eAAc;UAEX;AACL,cAAU,KAAK,cAAc,OAAO,YAAY;AAChD,QAAI,SAAS;AACX,mBAAc,QAAQ;AACtB,SAAI,QAAQ,0BACV,wBAAuB,QAAQ,gBAAgB;AAEjD,UAAK,kBAAkB,aAAa,QAAQ,QAAQ;AACpD,SAAI,QAAQ,QAAQ,WAAW;AAE7B,WAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,OAAO,QAAQ,IACzC,QAAO,UAAU,IAAI,QAAQ,OAAO,IAAI,UAAU;AAEpD;gBACS,QAAQ,QAAQ,UAAU;AAEnC,WAAK,eAAe,IAAI,QAAQ,QAAQ;AACxC;;;;AAIN,OAAI,CAAC,aAAa;AAChB,gBAAY,IAAI,8BAA6B,QAAQ,KAAI;AACzD;;AAEF,OAAI;AACF,eAAW,aAAa,IAAI,OAAO;AAInC,SAAK,CAAC,WAAW,CAAC,QAAQ,kBAAkB,OAAO,SACjD,QAAO,UAAU;YAEZ,GAAG;AACV,gBAAY,IAAI,EAAE,UAAU,CAAC;AAC7B,UAAM;;;EAGV,aAAa,SAAU,IAAI,aAAa,QAAQ;AAC9C,eAAY,SAAS,IAAI;AAEzB,OAAI,YAAY,IAAI,IAAI,EAAE;AACxB,WAAO,OAAO,GAAG,WAAW;AAC5B,WAAO,UAAU,GAAG,UAAU;UACzB;AACL,WAAO,OAAO,KAAK,eAAe,IAAI,YAAY;AAClD,QAAI,OAAO,SAAS,UAAa,YAAY,IAAI,IAAI,CACnD,QAAO,UAAU,KAAK,eAAe,IAAI,YAAY;;GAKzD,IAAIS,iBAAe,YAAY,MAAM,2BAA2B;AAChE,OAAIA,eACF,QAAO,cAAcA,eAAa;OAElC,QAAO,cAAc,YAAY,MAAM,KAAK,CAAC;AAG/C,UAAO;;EAET,gBAAgB,SAAU,IAAI,aAAa;GACzC,IAAI,cAAc,YAAY,MAAM,SAAS;AAC7C,OAAI,YAGF,QAAO,SAAS,YAAY,IAAI,GAAG,GAAG;AAExC,WAAQ,YAAY,MAAM,EAA1B;IACE,KAAK,IACH,QAAO,KAAK,qBAAqB,aAAa,GAAG,WAAW,CAAC,KAAK;IACpE,KAAK,IACH,QAAO,KAAK,qBAAqB,aAAa,GAAG,UAAU,CAAC;IAC9D,KAAK;KACH,IAAI,WAAW,YAAY,MAAM;KACjC,IAAI,UAAU,WAAW,IAAI,GAAG,MAAM,KAAK,SAAS;AACpD,SAAI,CAAC,QAAS,OAAM,IAAI,MAAM,eAAe;AAC7C,YAAO,KAAK,qBAAqB,aAAa,QAAQ,KAAK;IAC7D,KAAK;IACL,KAAK;AACH,iBAAY,OAAO,EAAE;AAErB,YAAO,KAAK,qBAAqB,aAAa,GAAG,WAAW,CAAC,KAAK;IACpE;AACE,iBAAY,OAAO,EAAE;AACrB;;;EAGN,sBAAsB,SAAU,aAAa,MAAM;GACjD,IAAI,cAAc,YAAY,MAAM,gBAAgB;AACpD,OAAI,aAAa;IACf,IAAI,SAAS,SAAS,YAAY,IAAI,GAAG;AACzC,QAAI,YAAY,MAAM,IACpB,SAAQ;QAER,SAAQ;;AAGZ,UAAO;;EAET,mBAAmB,SAAU,aAAa,QAAQ,SAAS;AACzD,OAAI,YAAY,KAAK,CACnB;AAEF,UAAO,YAAY,YAAY,MAAM,KAAK,CAAC;GAE3C,IAAI,QAAQ,QAAQ,gBAAgB;GACpC,IAAI,OAAO,KAAK,OAAO,UAAU,CAAC,MAAM,MAAM;AAC9C,OAAI,KAAK,UAAU,KAAK,GACtB,QAAO,OAAO;;EAGlB,eAAe,SAAU,aAAa;AAKpC,QAAK,IAAI,IAAI,YAAY,QAAQ,IAAI,GAAG,KAAK;IAC3C,IAAI,SAAS,YAAY,UAAU,GAAG,EAAE;AACxC,QAAI,KAAK,YAAY,SAAS;KAC5B,IAAI,UAAU,KAAK,YAAY;AAC/B,SAAI,QAAQ,KAAK,QAAQ,YAAY,KAAK,EACxC,QAAO;;;AAIb,UAAO;;EAET,kBAAkB,WAAY;AAC5B,QAAK,cAAc,EAAE;AACrB,QAAK,IAAI,IAAI,GAAG,IAAI,oBAAoB,QAAQ,KAAK;IACnD,IAAI,UAAU,oBAAoB;IAClC,IAAI,MAAM,QAAQ,aAAa,QAAQ;AACvC,SAAK,YAAY,OAAO;;;EAG5B,KAAK,SAAU,KAAK,KAAK,KAAK;AAC5B,OAAI,OAAO,OAAO,IAAI,OAAO,EAAE,IAAI,KAAK;AACtC,QAAI,IACF,OAAM,MAAM,qCAAqC;IAEnD,IAAI,cAAc,IAAI,UAAU,EAAE;AAClC,QAAI,OAAO,OAAO,IAAI,OAAO,EAAE,IAAI,IAEjC,MAAK,YAAY,eAAe;KAC9B,MAAM;KACN,MAAM;KACN,SAAS,IAAI,UAAU,EAAE;KACzB,MAAM;KACP;QAGD,MAAK,YAAY,eAAe;KAC9B,MAAM;KACN,MAAM;KACN,QAAQ;KACR,MAAM;KACP;cAGC,OAAO,OAAO,IAAI,OAAO,EAAE,IAAI,KAAK;IAEtC,IAAI,UAAU;KACZ,MAAM;KACN,MAAM;KACN,QAAQ,EAAE,OAAO,IAAI,UAAU,EAAE,EAAE;KACpC;AACD,QAAI,IACF,SAAQ,UAAU;AAEpB,kBAAc,QAAQ,QAAQ;UACzB;IAEL,IAAI,UAAU;KACZ,MAAM;KACN,MAAM;KACN,QAAQ;KACT;AACD,QAAI,IACF,SAAQ,UAAU;AAEpB,kBAAc,QAAQ,QAAQ;;;EAIpC,OAAO,SAAU,KAAK,KAAK;AACzB,OAAI,OAAO,OAAO,IAAI,OAAO,EAAE,IAAI,KAAK;AAEtC,QAAI,IACF,OAAM,MAAM,qCAAqC;IAEnD,IAAI,cAAc,IAAI,UAAU,EAAE;AAClC,QACE,KAAK,YAAY,gBACjB,KAAK,YAAY,aAAa,MAC9B;AACA,YAAO,KAAK,YAAY;AACxB,YAAO;;UAEJ;IAEL,IAAI,OAAO;AACX,SAAK,IAAI,IAAI,GAAG,IAAI,cAAc,QAAQ,IACxC,KACE,QAAQ,cAAc,GAAG,QACzB,cAAc,GAAG,YAAY,KAC7B;AACA,mBAAc,OAAO,GAAG,EAAE;AAC1B,YAAO;;;;EAKhB;CAED,IAAI,aAAa;EACf,aAAa,SAAU,IAAI,QAAQ;AACjC,OAAI,CAAC,OAAO,QAAQ,OAAO,KAAK,SAAS,GAAG;AAC1C,gBAAY,IAAI,GAAG,UAAU,QAAQ,CAAC;AACtC;;AAEF,MAAG,UAAU,SAAS,OAAO,KAAK,GAAG;;EAEvC,KAAK,SAAU,IAAI,QAAQ,KAAK;GAC9B,IAAI,UAAU,OAAO;AACrB,OAAI,CAAC,WAAW,QAAQ,SAAS,GAAG;AAClC,QAAI,GACF,aAAY,IAAI,sBAAsB,OAAO,MAAM;AAErD;;AAEF,uBAAoB,IAAI,QAAQ,IAAI,QAAQ,IAAI,IAAI;;EAEtD,MAAM,SAAU,IAAI,QAAQ;AAC1B,QAAK,IAAI,IAAI,QAAQ,SAAS;;EAEhC,MAAM,SAAU,IAAI,QAAQ;AAC1B,QAAK,IAAI,IAAI,QAAQ,SAAS;;EAEhC,MAAM,SAAU,IAAI,QAAQ;AAC1B,QAAK,IAAI,IAAI,QAAQ,SAAS;;EAEhC,OAAO,SAAU,IAAI,QAAQ,KAAK;GAChC,IAAI,UAAU,OAAO;AACrB,OACE,CAAC,WACD,QAAQ,SAAS,KACjB,CAAC,oBAAoB,MAAM,QAAQ,IAAI,IAAI,EAE3C;QAAI,GACF,aAAY,IAAI,sBAAsB,OAAO,MAAM;;;EAIzD,MAAM,SAAU,IAAI,QAAQ;AAC1B,qBAAkB,eAAe,IAAI,GAAG,MAAM,KAAK;IACjD,MAAM;IACN,QAAQ;IACR,YAAY;KAAE,SAAS;KAAO,gBAAgB;KAAM,UAAU;KAAM;IACpE,gBAAgB,OAAO,OAAO;IAC/B,CAAC;;EAEJ,KAAK,SAAU,IAAI,QAAQ;GACzB,IAAI,UAAU,OAAO;GAGrB,IAAI,SAAS,OAAO,UAAU,EAAE;AAChC,OAAI,CAAC,WAAW,QAAQ,SAAS,GAAG;AAClC,QAAI,GACF,aAAY,IAAI,sBAAsB,OAAO,MAAM;AAErD;;GAEF,IAAI,OAAO,QAAQ,GAAG,MAAM,IAAI;GAChC,IAAI,aAAa,KAAK;GACtB,IAAI,QAAQ,KAAK;GACjB,IAAI,WAAW;AAEf,OAAI,WAAW,OAAO,WAAW,SAAS,EAAE,IAAI,KAAK;AAEnD,QAAI,MACF,OAAM,MAAM,0BAA0B,OAAO,UAAU;AAEzD,iBAAa,WAAW,UAAU,GAAG,WAAW,SAAS,EAAE;AAC3D,eAAW;;AAEb,OAAI,UAAU,UAAa,WAAW,UAAU,GAAG,EAAE,IAAI,MAAM;AAG7D,iBAAa,WAAW,UAAU,EAAE;AACpC,YAAQ;;GAGV,IAAI,kBACF,QAAQ,eAAe,QAAQ,YAAY,QAAQ;AACrD,OAAI,mBAAmB,SAAS,OAE9B,SAAQ;AAGV,OAAK,CAAC,mBAAmB,UAAU,UAAc,UAAU;IACzD,IAAI,WAAW,UAAU,YAAY,IAAI,OAAO;AAChD,QAAI,oBAAoB,MACtB,aAAY,IAAI,SAAS,QAAQ;aACxB,aAAa,QAAQ,aAAa,MAC3C,aAAY,IAAI,OAAO,WAAW,KAAK,QAAQ,WAAW;QAE1D,aAAY,IAAI,OAAO,aAAa,MAAM,SAAS;UAEhD;IACL,IAAI,kBAAkB,UAAU,YAAY,OAAO,IAAI,OAAO;AAC9D,QAAI,2BAA2B,MAC7B,aAAY,IAAI,gBAAgB,QAAQ;;;EAI9C,UAAU,SAAU,IAAI,QAAQ;AAE9B,UAAO,SAAS,EAAE,OAAO,SAAS;AAClC,QAAK,IAAI,IAAI,OAAO;;EAEtB,WAAW,SAAU,IAAI,QAAQ;AAE/B,UAAO,SAAS,EAAE,OAAO,UAAU;AACnC,QAAK,IAAI,IAAI,OAAO;;EAEtB,WAAW,SAAU,IAAI,QAAQ;GAC/B,IAAI,UAAU,OAAO;GACrB,IAAI,YAAY,eAAe,mBAAmB;GAClD,IAAI,UAAU;AACd,OAAI,CAAC,QACH,MAAK,IAAI,gBAAgB,WAAW;IAClC,IAAI,OAAO,UAAU,cAAc,UAAU;AAC7C,QAAI,KAAK,OACP,YAAW,OAAM,eAAe,SAAS,OAAO;;QAG/C;IACL,IAAI;AACJ,cAAU,QAAQ,KAAK,GAAG;AAC1B,SAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,oBAAe,QAAQ,OAAO,EAAE;AAChC,SACE,CAAC,eAAe,mBAAmB,gBAAgB,aAAa,CAEhE;KAEF,IAAI,WAAW,UAAU,iBAAiB,IAAI,UAAU;AACxD,gBAAW,OAAM,eAAe,SAAS,SAAS,UAAU,GAAG;;;AAGnE,eAAY,IAAI,QAAQ;;EAE1B,MAAM,SAAU,IAAI,QAAQ;GAC1B,IAAI,SAAS,YAAYC,UAAQ,QAAQ;GACzC,SAAS,YAAY;AACnB,QAAI,OAAO,WAAW;KACpB,IAAI,OAAO,IAAIV,mBAAW,aAAa,OAAO,UAAU;AACxD,SAAI,KAAK,IAAI,IAAI,CACf,WAAU;AAEZ,SAAI,KAAK,KAAK,CACZ;AAEF,SAAI,CAAC,KAAK,UAAU,CAClB,QAAO;KAET,IAAI,OAAO,KAAK,MAAM,8BAA8B;AACpD,SAAI,CAAC,QAAQ,CAAC,KAAK,KAAK,CACtB,QAAO;AAET,SAAI,KAAK,IAAI;AACX,mBAAa,KAAK,GAAG,QAAQ,IAAI,IAAI;AACrC,iBAAS,KAAK,GAAG,QAAQ,IAAI,IAAI;MACjC,IAAI,UACF,KAAK,GAAG,QAAQ,IAAI,IAAI,MAAO,KAAK,GAAG,QAAQ,IAAI,IAAI,MAAM;MAC/D,IAAI,MAAM,KAAK,GAAG,QAAQ,IAAI,IAAI,MAAM;MACxC,IAAI,QAAQ,KAAK,GAAG,QAAQ,IAAI,IAAI,MAAM;AAC1C,UAAI,UAAU,MAAM,QAAQ,EAC1B,QAAO;AAET,eACG,WAAW,aAAe,OAAO,SAAW,SAAS;;AAE1D,SAAI,KAAK,GACP,WAAU,IAAI,OACZ,KAAK,GAAG,OAAO,GAAG,KAAK,GAAG,SAAS,EAAE,EACrC,aAAa,MAAM,GACpB;;;GAIP,IAAI,MAAM,WAAW;AACrB,OAAI,KAAK;AACP,gBAAY,IAAI,MAAM,OAAO,OAAO,UAAU;AAC9C;;GAEF,IAAI,YAAY,OAAO,QAAQ,GAAG,WAAW;GAC7C,IAAI,UAAU,OAAO,WAAW,OAAO,QAAQ,GAAG,UAAU;AAC5D,OAAI,aAAa,QACf;GAEF,IAAI,WAAW,IAAI,IAAI,WAAW,EAAE;GACpC,IAAI,SAAS,IAAI,IAAI,SAAS,WAAW,IAAI,QAAQ,CAAC;GACtD,IAAI,OAAO,GAAG,SAAS,UAAU,OAAO,CAAC,MAAM,KAAK;GACpD,IAAIW,gBAAc,UACd,UACA,UAAU,YACV,gBACA,UAAU,QACV,4BACA,UAAU,UACV,aACA;GACJ,IAAI,QACF,UAAU,YACN,KACA,UAAU,QACV,KACA,UAAU,UACV,IACA;GACN,IAAI,UAAU,EAAE,EACd,WAAW,EAAE;AACf,OAAI,UAAU,QACZ,MAAK,IAAI,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;IACpC,IAAI,YAAY,UAAU,KAAK,GAAG,MAAM,QAAQ,GAAG;AACnD,QAAI,aAAa,UAAU,MAAM,GAC/B,SAAQ,KAAK,UAAU;aACd,CAAC,WAAWA,cAAY,KAAK,KAAK,GAAG,CAC9C,SAAQ,KAAK,KAAK,GAAG;QAErB,UAAS,KAAK,KAAK,GAAG;;OAI1B,YAAW;GAEb,SAAS,UAAU,GAAG,GAAG;AACvB,QAAI,SAAS;KACX,IAAI,MACE;AACN,SAAI;AACJ,SAAI;;AAEN,QAAI,YAAY;AACd,SAAI,EAAE,aAAa;AACnB,SAAI,EAAE,aAAa;;IAErB,IAAI,OAAO,UAAUA,cAAY,KAAK,EAAE;IACxC,IAAI,OAAO,UAAUA,cAAY,KAAK,EAAE;AACxC,QAAI,CAAC,KACH,QAAO,IAAI,IAAI,KAAK;AAEtB,WAAO,UAAU,KAAK,KAAK,KAAK,IAAI,aAAa,EAAE,MAAM;AACzD,WAAO,UAAU,KAAK,KAAK,KAAK,IAAI,aAAa,EAAE,MAAM;AACzD,WAAO,OAAO;;GAEhB,SAAS,iBAAiB,GAAG,GAAG;AAC9B,QAAI,SAAS;KACX,IAAI,MACE;AACN,SAAI;AACJ,SAAI;;AAEN,QAAI,YAAY;AACd,OAAE,KAAK,EAAE,GAAG,aAAa;AACzB,OAAE,KAAK,EAAE,GAAG,aAAa;;AAE3B,WAAO,EAAE,KAAK,EAAE,KAAK,KAAK;;AAE5B,WAAQ,KAAK,UAAU,mBAAmB,UAAU;AACpD,OAAI,QACF,MAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,QAAQ,IAClC,SAAQ,KAAK,QAAQ,GAAG;YAEjB,CAAC,OACV,UAAS,KAAK,UAAU;AAE1B,UAAO,CAAC,UAAU,SAAS,OAAO,QAAQ,GAAG,QAAQ,OAAO,SAAS;AACrE,OAAID,UAAQ;IAEV,IAAI,UAAU;IACd,IAAI;AACJ,WAAO,EAAE;AACT,SAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACvC,SAAI,QAAQ,MAAM,SAChB,MAAK,KAAK,QAAQ,GAAG;AAEvB,gBAAW,QAAQ;;;AAGvB,MAAG,aAAa,KAAK,KAAK,KAAK,EAAE,UAAU,OAAO;;EAEpD,SAAS,SAAU,IAAI,QAAQ;AAE7B,QAAK,OAAO,IAAI,OAAO;;EAEzB,QAAQ,SAAU,IAAI,QAAQ;GAI5B,IAAI,YAAY,OAAO;AACvB,OAAI,CAAC,WAAW;AACd,gBAAY,IAAI,yCAAyC;AACzD;;GAEF,IAAI,WAAW,OAAO,YAAY,OAAO;GAEzC,IAAI,YAAY,OAAO,SAAS,SAAY,OAAO,OAAO,GAAG,WAAW;GACxE,IAAI,UAAU,OAAO,WAAW,OAAO,QAAQ,GAAG,UAAU;GAE5D,IAAI,SAAS,aAAa,UAAU;GACpC,IAAI,YAAY,WACd;AACF,OAAI,OAAO,QAAQ;AACjB,gBAAY,OAAO;AACnB,UAAM,OAAO,MAAM,GAAG,OAAO,OAAO,CAAC,KAAK,IAAI;;AAEhD,OAAI,UAGF,KAAI;AACF,sBACE,IACA,WACA,MACA,KACD;YACM,GAAG;AACV,gBAAY,IAAI,oBAAoB,UAAU;AAC9C;;GAKJ,IAAI,QAAQ,eAAe,GAAG,CAAC,UAAU;GACzC,IAAI,eAAe,EAAE;AACrB,QAAK,IAAI,IAAI,WAAW,KAAK,SAAS,KAAK;IACzC,IAAI,OAAO,GAAG,cAAc,EAAE;AAE9B,QADc,MAAM,KAAK,KAAK,KAAK,KACnB,SACd,cAAa,KAAK,MAAM,OAAO,KAAK,KAAK;;AAI7C,OAAI,CAAC,KAAK;AACR,gBAAY,IAAI,aAAa,KAAK,KAAK,CAAC;AACxC;;GAEF,IAAI,QAAQ;GACZ,IAAI,cAAc,WAAY;AAC5B,QAAI,QAAQ,aAAa,QAAQ;KAC/B,IAAIE,SAAO,aAAa;KACxB,IAAI,UAAU,GAAG,cAAcA,OAAK;AACpC,SAAI,WAAW,MAAM;AACnB,mBAAa;AACb;;KAEF,IAAI,UAAU,UAAU,IAAI;AAC5B,yBAAoB,eAAe,IAAI,SAAS,EAC9C,UAAU,aACX,CAAC;;;AAGN,gBAAa;;EAEf,YAAY,SAAU,IAAI,QAAQ;AAChC,OAAI,CAAC,GAAG,gBACN,OAAM,IAAI,MACR,sGAED;GAEH,IAAI,YAAY,OAAO;GACvB,IAAI,SAAS,YAAY,iBAAiB,WAAW,UAAU,GAAG,GAAG,EAAE;GACvE,IAAI,WACF,cAAc,IACd,UACA,WACA;GACF,IAAI,UAAU;GACd,IAAIC,WAAS;AACb,OAAI,OAAO,QAAQ;AACjB,gBAAY,OAAO;AACnB,QAAI,UAAU,OAAO,IAAI,cAAc,GACrC,aAAY,IAAI,OAAO,UAAU,CAAC;AAEpC,kBAAc,OAAO;AACrB,QAAI,gBAAgB,QAAW;AAC7B,SAAI,UAAU,OAAO,CACnB,eAAc,qBACZ,YAAY,QAAQ,aAAa,QAAQ,CAC1C;SAED,eAAc,sBAAsB,YAAY;AAElD,oBAAe,4BAA4B;;AAE7C,eAAW,OAAO,KAAK,OAAO,GAAG,MAAM,IAAI,GAAG,EAAE;cAK5C,aAAa,UAAU,QAAQ;AACjC,gBACE,IACA,0DACD;AACD;;AAKJ,OAAI,UAAU;AACZ,gBAAY,SAAS;AACrB,YAAQ,SAAS,SAAS,GAAG;AAC7B,QAAI,WAAW;AACb,SAAI,UAAU,QAAQ,IAAI,IAAI,GAC5B,WAAU;AAEZ,SAAI,UAAU,QAAQ,IAAI,IAAI,GAC5B,YAAS;AAEX,SAAI,UAAU,OAAO,CACnB,aAAY,YAAY,MAAM;SAE9B,aAAY,UAAU,QAAQ,OAAO,MAAM,GAAG,MAAM;;;AAI1D,OAAI,UAGF,KAAI;AACF,sBACE,IACA,WACA,MACA,KACD;YACM,GAAG;AACV,gBAAY,IAAI,oBAAoB,UAAU;AAC9C;;AAGJ,iBAAc,eAAe,eAAe;AAC5C,OAAI,gBAAgB,QAAW;AAC7B,gBAAY,IAAI,4CAA4C;AAC5D;;GAGF,IAAI,QADQ,eAAe,GAAG,CACZ,UAAU;GAC5B,IAAI,YACF,OAAO,SAAS,SAAY,OAAO,OAAO,GAAG,WAAW,CAAC;GAC3D,IAAI,UAAU,OAAO,WAAW;AAChC,OAAI,aAAa,GAAG,WAAW,IAAI,WAAW,GAAG,UAAU,CACzD,WAAU;AAEZ,OAAI,OAAO;AACT,gBAAY;AACZ,cAAU,YAAY,QAAQ;;GAEhC,IAAI,WAAW,oBAAoB,IAAI,IAAI,IAAI,WAAW,EAAE,CAAC;GAC7D,IAAI,SAAS,GAAG,gBAAgB,OAAO,SAAS;AAChD,MAAG,cAAc;AACjB,aACE,IACA,SACAA,UACA,WACA,SACA,QACA,OACA,aACA,OAAO,SACR;;EAEH,MAAMb,mBAAW,SAAS;EAC1B,MAAMA,mBAAW,SAAS;EAC1B,OAAO,SAAU,IAAI;AACnB,OAAIA,mBAAW,SAAS,KAEtB,oBAAW,SAAS,KAAK,GAAG;YACnB,GAAG,KAEZ,IAAG,MAAM;;EAGb,YAAY,SAAU,IAAI;AACxB,wBAAqB,GAAG;;EAE1B,MAAM,SAAU,IAAI;GAElB,IAAI,OADM,WAAW,GAAG,WAAW,CAAC,CACrB;GACf,IAAI,WAAW,GAAG,QAAQ,KAAK;AAC/B,kBAAe,mBAAmB,SAChC,KACA,QACA,UACA,MACA,KACD;;EAEH,UAAU,SAAU,IAAI,QAAQ;AAC9B,OAAI,CAAC,OAAO,aAAa,CAAC,KAAK,OAAO,UAAU,EAAE;AAChD,gBAAY,IAAI,oBAAoB;AACpC;;GAGF,IAAI,QAAQ,GAAG,MAAM;GACrB,IAAI,SAAS,IAAIA,mBAAW,aAAa,KAAK,OAAO,UAAU,CAAC;AAChE,UAAO,CAAC,OAAO,KAAK,EAAE;AACpB,WAAO,UAAU;IAIjB,IAAI,QAAQ,OAAO;AAEnB,QAAI,CAAC,OAAO,MAAM,YAAY,MAAM,EAAE;AACpC,iBACE,IACA,uBAAuB,OAAO,UAAU,UAAU,MAAM,CACzD;AACD;;IAGF,IAAI,MAAM,OAAO,MAAM;AAEvB,QAAI,OAAO,MAAM,KAAK,KAAK,EAAE;AAI3B,SAAI,CAAC,OAAO,MAAM,YAAY,MAAM,EAAE;AACpC,kBACE,IACA,uBAAuB,OAAO,UAAU,UAAU,MAAM,CACzD;AACD;;KAGF,IAAI,YAAY;KAChB,IAAI,aAAa,OAAO,MAAM;AAG9B,SACG,YAAY,UAAU,IAAI,YAAY,WAAW,IACjD,YAAY,UAAU,IAAI,YAAY,WAAW,EAClD;MACA,IAAI,QAAQ,UAAU,WAAW,EAAE;MACnC,IAAI,SAAS,WAAW,WAAW,EAAE;AACrC,UAAI,SAAS,QAAQ;AACnB,mBACE,IACA,uBAAuB,OAAO,UAAU,UAAU,MAAM,CACzD;AACD;;AAMF,WAAK,IAAI,IAAI,GAAG,KAAK,SAAS,OAAO,KAAK;OACxC,IAAI,OAAO,OAAO,aAAa,QAAQ,EAAE;AACzC,cAAO,MAAM,MAAM;;YAEhB;AACL,kBAAY,IAAI,uBAAuB,YAAY,IAAI;AACvD;;UAIF,QAAO,MAAM,MAAM;;;EAI1B;CAED,IAAI,sBAAsB,IAAI,qBAAqB;;;;;;;;;;;CAYnD,SAAS,UACP,IACA,SACA,UACA,WACA,SACA,cACA,OACA,aACA,UACA;AAEA,KAAG,MAAM,IAAI,SAAS;EACtB,IAAI,OAAO;EACX,IAAI,SAAS,oBAAoB;EACjC,SAAS,aAAa;AACpB,MAAG,UAAU,WAAY;AACvB,WAAO,CAAC,MAAM;AACZ,cAAS;AACT,WAAM;;AAER,UAAM;KACN;;EAEJ,SAAS,UAAU;GAEjB,IAAI,UADO,GAAG,SAAS,aAAa,MAAM,EAAE,aAAa,IAAI,CAAC,CAC3C,QAAQ,OAAO,YAAY;GAC9C,IAAI,uBAAuB,aAAa,IAAI,CAAC;AAC7C,gBAAa,QAAQ,QAAQ;AAC7B,wBAAqB,aAAa,IAAI,CAAC;AACvC,cAAW,qBAAqB;AAChC,YAAS,qBAAqB;;EAEhC,SAAS,qBAAqB;GAC5B,IAAI,cAAc,WAAW,WAAW,aAAa,IAAI,CAAC;GAC1D,IAAI,QAAQ,aAAa,UAAU;AACnC,OACE,SACA,CAAC,MAAM,MACP,eACA,YAAY,aAAa,MAAM,EAAE,YAAY,CAE7C,SAAQ,aAAa,UAAU;AAEjC,UAAO;;EAET,SAAS,OAAO;AAGd,UACE,oBAAoB,IACpB,UAAU,aAAa,MAAM,EAAE,WAAW,QAAQ,EAClD;AACA,QACE,CAACa,YACD,aAAa,MAAM,CAAC,QAAQ,sBAC5B,CAAC,OAED;AAEF,OAAG,eAAe,aAAa,MAAM,EAAE,GAAG;AAC1C,OAAG,aAAa,aAAa,MAAM,EAAE,aAAa,IAAI,CAAC;AACvD,cAAU,aAAa,MAAM;AAC7B,WAAO;AACP;;AAEF,UAAO;;EAET,SAAS,KAAK,OAAO;AACnB,OAAI,MACF,QAAO;AAET,MAAG,OAAO;AACV,OAAI,SAAS;AACX,OAAG,UAAU,QAAQ;IACrB,IAAI,MAAM,GAAG,MAAM;AACnB,QAAI,SAAS;AACb,QAAI,WAAW,IAAI,YAAY,QAAQ;;AAEzC,OAAI,SACF,WAAU;;EAGd,SAAS,gBAAgB,GAAG,QAAQ,OAAO;AAEzC,sBAAW,OAAO,EAAE;AAEpB,WADcb,mBAAW,QAAQ,EAAE,EACnC;IACE,KAAK;AACH,cAAS;AACT,WAAM;AACN;IACF,KAAK;AACH,WAAM;AACN;IACF,KAAK;KAGH,IAAI,gBAAgB;AACpB,gBAAW;AACX,QAAG,UAAU,WAAW;AACxB,gBAAW;AACX;IACF,KAAK,IACH,UAAS;IAEX,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACH,UAAK,MAAM;AACX;;AAEJ,OAAI,KACF,MAAK,MAAM;AAEb,UAAO;;AAIT,QAAM;AACN,MAAI,MAAM;AACR,eAAY,IAAI,oBAAoB,MAAM,OAAO;AACjD;;AAEF,MAAI,CAAC,SAAS;AACZ,eAAY;AACZ,OAAI,SACF,WAAU;AAEZ;;AAEF,aAAW,IAAI;GACb,QAAQ,IACN,QACA,iBACA,IAAI,UAAU,YAAY,EAC1B,eACD;GACD,WAAW;GACZ,CAAC;;AAGJ,oBAAW,OAAO,MAAM;EACtB,QAAQ;EACR,QAAQ;EACR,MAAM;EACP;CAED,SAAS,eAAe,IAAI;EAC1B,IAAI,MAAM,GAAG,MAAM;EACnB,IAAI,iBAAiB,eAAe;EACpC,IAAI,2BACF,eAAe,mBAAmB,YAAY,IAAI;EACpD,IAAI,YAAY,eAAe;EAC/B,IAAI,aAAa,eAAe;AAChC,MAAI,CAAC,WAAW;AACd,MAAG,IAAI,UAAU,SAAS;AAC1B,sBAAW,IAAI,GAAG,eAAe,EAAE,WAAW,wBAAwB;;AAExE,MAAI,CAAC,aAAa,IAAI,mBAAmB,GAAG;AAE1C,kBACE,IACA,KACA,IAAI,mBAAmB,GACvB,KACD;AACD,OAAI,mBAAmB,iBAAiB,IAAI;;AAE9C,SAAO,IAAI;AACX,MAAI,aAAa;AACjB,KAAG,UAAU,GAAG,WAAW,CAAC,MAAM,GAAG,WAAW,CAAC,KAAK,EAAE;AACxD,KAAG,UAAU,UAAU,MAAM;AAC7B,KAAG,UAAU,gBAAgB,KAAK;AAClC,KAAG,gBAAgB,MAAM;AAEzB,2BAAyB,QAAQ,WAAW,QAAQ,KAAK,GAAG,CAAC;AAC7D,qBAAW,OAAO,IAAI,mBAAmB,EAAE,MAAM,UAAU,CAAC;AAC5D,MAAI,eAAe,YACjB,qBAAoB,eAAe;AAErC,KAAG,cAAc;;CAGnB,SAAS,YAAY,SAAS;AAC5B,gBAAc,QAAQ,QAAQ;;CAGhC,SAAS,WAAW,MAAM,MAAM,MAAM,MAAM,OAAO;EACjD,IAAI,UAAU;GAAQ;GAAY;GAAM;AACxC,UAAQ,QAAQ;AAChB,UAAQ,OAAO,UAAU;AACzB,OAAK,IAAI,OAAO,MAAO,SAAQ,OAAO,MAAM;AAC5C,cAAY,QAAQ;;AAKtB,cAAa,4BAA4B,KAAK,SAAS;AAEvD,oBAAW,OAAO,gBAAgB;EAGhC,aAAa,CAAC,UAAU;EACxB,QAAQ;EACR,QAAQ;EACR,MAAM;EACP;AAED,oBAAW,OAAO,iBAAiB;EACjC,WAAW;EACX,aAAa,CAAC,aAAa;EAC3B,QAAQ;EACR,QAAQ;EACR,MAAM;EACP;CAED,SAAS,qBAAqB,IAAI,KAAK,gBAAgB,cAAc;EACnE,IAAI,WAAW,eAAe,mBAAmB,YAAY,aAAa;AAC1E,MAAI,gBAAgB,KAAK;AAEvB,OAAI,SAAS,UAAU,GACrB,qBAAoB,eAAe,IAAI,SAAS,UAAU,GAAG;AAE/D,kBAAe,YAAY;AAC3B;;EAEF,IAAI,YAAY,SAAS;EACzB,IAAI,MAAM;AACV,iBAAe,YAAY;AAC3B,iBAAe,sBAAsB,SAAS,cAAc,MAAM,EAAE;AACpE,OAAK,IAAI,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;GACzC,IAAI,OAAO,UAAU;GACrB,IAAI,OAAO;AACX,UAAO,MAAM;AAGX,YAAQ,oBAAoB,KAAK,KAAK;AACtC,UAAM,MAAM;AACZ,WAAO,KAAK,UAAU,MAAM,QAAQ,IAAI,OAAO;AAC/C,WAAO,UAAU,IAAI,KAAK,QAAQ;AAClC,QAAI,IAAI,YAAY;KAClB,IAAI,UAAU,SAAS,kBAAkB,OAAO;AAChD,oBAAe,eAAe,sBAAsB,UAAU;AAC9D,6BAAwB,IAAI,SAAS,EAAE;AACvC,oBAAe,GAAG;;;;AAIxB,iBAAe,YAAY;;CAG7B,SAAS,OAAO,gBAAgB,KAAK;AACnC,MAAI,eAAe,UACjB;EAEF,IAAI,eAAe,eAAe;EAClC,IAAI,WAAW,eAAe,mBAAmB,YAAY,aAAa;AAC1E,MAAI,SACF,UAAS,SAAS,IAAI;;CAI1B,SAAS,oBAAoB,gBAAgB;AAC3C,MAAI,eAAe,UACjB;EAEF,IAAI,eAAe,eAAe;EAClC,IAAI,WAAW,eAAe,mBAAmB,YAAY,aAAa;AAC1E,MAAI,YAAY,SAAS,sBACvB,UAAS,sBAAsB,eAAe,sBAAsB;;CAIxE,SAAS,eAAe,gBAAgB,OAAO;AAC7C,MAAI,eAAe,UACjB;EAEF,IAAI,eAAe,eAAe;EAClC,IAAI,WAAW,eAAe,mBAAmB,YAAY,aAAa;AAC1E,MAAI,YAAY,SAAS,gBACvB,UAAS,gBAAgB,MAAM;;;;;;CAQnC,SAAS,SAAS,IAAI,WAAW;EAC/B,IAAI,iBAAiB,eAAe;EACpC,IAAI,aAAa,eAAe;AAChC,MAAI,CAAC,eAAe,UAClB,QAAO,WAAW;AAChB,cAAW,gCAAgC;AAC3C,OAAI,WAAW,cAAc,EAC3B,YAAW;YAEX,UAAU,UAAU,YACpB,UAAU,UAAU,WACpB,UAAU,WAAW,QACrB;IACA,IAAI,iBAAiB,GAAG,gBAAgB,CAAC;AACzC,QAAI,iBAAiB,EAAG,YAAW,cAAc;IACjD,IAAI,OAAO,UAAU,KAAK,KAAK,KAAK;AACpC,QAAI,WAAW,YAAY;AACzB,gBAAW,UAAU,EAAE;AACvB,gBAAW,aAAa;;AAE1B,QAAI,KACF,KAAI,GAAG,MAAM,aAAa,CAAC,KAAK,KAAK,KAAK,CACxC,YAAW,QAAQ,KAAK,CAAC,KAAK,CAAC;QAE/B,YAAW,QAAQ,KAAK,KAAK;;AAKnC,eAAY,UAAU;;;;;;CAQ5B,SAAS,iBAAiB,IAAI;EAC5B,IAAI,MAAM,GAAG,MAAM;AACnB,MAAI,IAAI,YAAY;GAElB,IAAI,iBAAiB,eAAe;AACpC,OAAI,eAAe,UACjB;GAEF,IAAI,aAAa,eAAe;AAChC,OAAI,WAAW,8BACb,YAAW,gCAAgC;OAG3C,YAAW,aAAa;aAEjB,CAAC,GAAG,MAAM,QACnB,yBAAwB,IAAI,IAAI;;CAGpC,SAAS,wBAAwB,IAAI,KAAK;EACxC,IAAI,SAAS,GAAG,UAAU,SAAS;EACnC,IAAI,OAAO,GAAG,UAAU,OAAO;AAE/B,MAAI,IAAI,cAAc,CAAC,GAAG,mBAAmB,CAC3C,gBAAe,IAAI,MAAM;WAChB,CAAC,IAAI,cAAc,CAAC,IAAI,cAAc,GAAG,mBAAmB,EAAE;AACvE,OAAI,aAAa;AACjB,OAAI,aAAa;AACjB,sBAAW,OAAO,IAAI,mBAAmB,EAAE,MAAM,UAAU,CAAC;;AAE9D,MAAI,IAAI,YAAY;GAGlB,IAAI,aAAa,CAAC,eAAe,MAAM,OAAO,GAAG,KAAK;GACtD,IAAI,eAAe,eAAe,MAAM,OAAO,GAAG,KAAK;AACvD,UAAO,aAAa,MAAM,GAAG,WAAW;AACxC,YAAS,aAAa,QAAQ,GAAG,aAAa;AAC9C,OAAI,MAAM;IACA;IACF;IACP;AACD,cAAW,IAAI,KAAK,KAAK,UAAU,MAAM,OAAO,CAAC;AACjD,cAAW,IAAI,KAAK,KAAK,UAAU,MAAM,OAAO,CAAC;aACxC,CAAC,IAAI,WAEd,KAAI,WAAW,GAAG,WAAW,CAAC;;;CAKlC,SAAS,cAAc,SAAS;AAC9B,OAAK,UAAU;;;;;;;CAQjB,SAAS,wBAAwB,GAAG;EAElC,IAAI,aADiB,eAAe,eACJ;EAChC,IAAI,UAAUA,mBAAW,QAAQ,EAAE;AACnC,MAAI,CAAC,QACH;EAEF,SAAS,aAAa;AACpB,OAAI,WAAW,YAAY;AACzB,eAAW,UAAU,EAAE;AACvB,eAAW,aAAa;;AAE1B,cAAW,QAAQ,KAAK,IAAI,cAAc,QAAQ,CAAC;AACnD,UAAO;;AAET,MAAI,QAAQ,QAAQ,SAAS,IAAI,MAAM,QAAQ,QAAQ,YAAY,IAAI,GACrE,oBAAW,UAAU,SAAS,cAAc,WAAW;;;;;;;;;;;CAa3D,SAAS,eAAe,IAAI,KAAK,QAAQ,iBAAiB;EACxD,IAAI,iBAAiB,eAAe;AACpC,iBAAe,YAAY;EAC3B,IAAI,WAAW,CAAC,CAAC,IAAI;EACrB,IAAI,mBAAmB,IAAI;EAC3B,SAAS,gBAAgB;AACvB,OAAI,SACF,mBAAkB,cAAc,IAAI,KAAK,IAAI,sBAAsB;OAEnE,mBAAkB,UAAU,IAAI,IAAI;;EAGxC,SAAS,aAAa,UAAQ;AAC5B,OAAI,eAAe,sBAAsB,QAAQ,SAAS,GAAG;AAG3D,eAAS,CAAC,IAAI,wBAAwB,IAAIc;IAC1C,IAAI,eAAe,eAAe;AAClC,4BAAwB,IAAI,aAAa,SAASA,SAAO;;;AAG7D,MAAI,aAAa,IAAI;AACrB,MAAI,YAAY,IAAI,sBAAsB,sBAGxC,MAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,kBAAe;AACf,gBAAa,EAAE;;OAEZ;AACL,OAAI,CAAC,gBAIH,gBAAe;AAEjB,gBAAa,OAAO;;AAEtB,MAAI,aAAa;AACjB,MAAI,IAAI,cAAc,CAAC,gBAGrB,gBAAe,GAAG;AAEpB,iBAAe,YAAY;;CAG7B,SAAS,wBAAwB,IAAI,SAAS,QAAQ;EACpD,SAAS,WAAW,SAAS;AAC3B,OAAI,OAAO,WAAW,SACpB,oBAAW,SAAS,SAAS,GAAG;OAEhC,SAAQ,GAAG;AAEb,UAAO;;EAET,IAAI,OAAO,GAAG,UAAU,OAAO;EAC/B,IAAI,cACF,eAAe,eAAe,sBAAsB;AACtD,MAAI,aAAa;AAEf,mBAAgB,IAAI,MAAM,cAAc,EAAE;AAC1C,YAAS,GAAG,gBAAgB,CAAC;AAC7B,MAAG,UAAU,KAAK;;AAEpB,OAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC/B,OAAI,YACF,IAAG,UAAU,aAAa,MAAM,GAAG,EAAE,CAAC;AAExC,QAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;IACvC,IAAI,SAAS,QAAQ;AACrB,QAAI,kBAAkB,cACpB,oBAAW,UAAU,OAAO,SAAS,cAAc,WAAW;aACrD,OAAO,UAAU,UAAU;AACpC,YAAO,KAAK;AACZ,QAAG,kBAAkB,OAAO;WACvB;KACL,IAAI,QAAQ,GAAG,WAAW;KAC1B,IAAI,MAAM,aAAa,OAAO,GAAG,OAAO,GAAG,OAAO;AAClD,QAAG,aAAa,OAAO,IAAI,OAAO,IAAI;AACtC,QAAG,UAAU,IAAI;;;;AAIvB,MAAI,YACF,IAAG,UAAU,aAAa,MAAM,GAAG,EAAE,CAAC;;AAI1C,sBAAqB;AACrB,QAAO;;AAGT,mBAAW,MAAM,KAAK;AAGtB,yBAAed;;;;AC77Nf,IAAqB,eAArB,MAAkC;CAWhC,YACE,MACA,QACA,YAAuB,MACvB;OAPM,QAA+B;OAoGvC,mBAAmB;AACjB,QAAK,sBAAsB;AAC3B,QAAK,QAAQ;AACb,QAAK,OAAO,GAAG;AAEf,OAAI,KAAK,OACP,MAAK,OAAO,OAAO;;OAIvB,cAAc;AACZ,QAAK,cAAc,KAAK,MAAM,GAAG;;OAGnC,cAAc,MAAqB;AACjC,OAAI,CAAC,KAAK,MACR;GAEF,MAAM,EAAE,YAAY,KAAK;AACzB,OAAI,WAAW,QAAQ,QACrB,SAAQ,QACN,GACC,EAAE,OAA4B,OAC/B,KAAK,WACN;;OAIL,iBAAiB,MAAkB;AACjC,OAAI,CAAC,KAAK,MACR;GAEF,MAAM,EAAE,YAAY,KAAK;AACzB,OAAI,WAAW,QAAQ,WACrB,SAAQ,WAAW,GAAI,EAAE,OAA4B,OAAO,KAAK,WAAW;;OAIhF,aAAa,UAAsB;AACjC,OAAI,CAAC,KAAK,MACR;GAEF,MAAM,EAAE,YAAY,KAAK;AAEzB,yDAAI,QAAS,OACX,SAAQ,OAAO,OAAO,KAAK,WAAW;AAGxC,yDAAI,QAAS,YACX,MAAK,YAAY;;OAIrB,gBAAgB,MAAqB;AACnC,OAAI,CAAC,KAAK,MACR;GAEF,MAAM,EAAE,SAAS,aAAa,KAAK;AAEnC,OACE,WACA,QAAQ,aACR,QAAQ,UAAU,GAAI,EAAE,OAA4B,OAAO,KAAK,WAAW,CAE3E;AAGF,OACE,EAAE,YAAY,MACb,WAAW,QAAQ,iBAAiB,SAAS,EAAE,WAAW,IAC3D;AACA,SAAK,MAAM,KAAK,MAAM;AACtB,MAAE,iBAAiB;AACnB,SAAK,YAAY;;AAGnB,OAAI,EAAE,YAAY,MAAM,UAAU;AAChC,MAAE,iBAAiB;AACnB,MAAE,gBAAgB;AAClB,aAAU,EAAE,OAA4B,MAAM;;;AA3KhD,OAAK,OAAO;AACZ,OAAK,eAAe,SAAS,cAAc,OAAO;AAClD,OAAK,cAAc,SAAS,cAAc,OAAO;AACjD,OAAK,YAAY,SAAS,cAAc,OAAO;AAC/C,OAAK,UAAU,YAAY;AAC3B,OAAK,cAAc,SAAS,cAAc,OAAO;AACjD,OAAK,YAAY,aAAa,SAAS,eAAe;AACtD,OAAK,KAAK,YAAY,KAAK,aAAa;AACxC,OAAK,KAAK,YAAY,KAAK,YAAY;AACvC,OAAK,KAAK,YAAY,KAAK,UAAU;AACrC,OAAK,KAAK,YAAY,KAAK,YAAY;AACvC,OAAK,iBAAiB,MAAM;AAC5B,OAAK,SAAS;AACd,OAAK,YAAY;;CAGnB,QAAQ,IAAwB;AAC9B,MAAI,GAAG,SAAS,UAAU;AACxB,OAAI,GAAG,YAAY,WACjB,MAAK,QAAQ,kBAAkB;YACtB,GAAG,YAAY,YACxB,MAAK,QAAQ,mBAAmB;OAEhC,MAAK,QAAQ,aAAa;AAE5B;;AAGF,OAAK,QAAQ,KAAK,GAAG,KAAK,aAAa,CAAC,IAAI;;CAG9C,aAAa,KAAa;AACxB,OAAK,YAAY,cAAc;;CAGjC,OACE,MACA,UACA,SACA;AACA,OAAK,UAAU,cAAc;AAC7B,MAAI,SAAS,OACX,QAAO,KAAK;AAGd,OAAK,cAAc,KAAK,aAAa,KAAK;EAC1C,MAAM,QAAQ,KAAK,YAAY,cAAc,QAAQ;AAErD,MAAI,OAAO;AACT,SAAM,OAAO;AACb,QAAK,QAAQ;IACX;IACA;IACA,MAAM;IACP;AAED,OAAI,SAAS;AACX,QAAI,QAAQ,kBACV,OAAM,QAAQ;AAGhB,QAAI,QAAQ,MACV,OAAM,QAAQ,QAAQ;;AAI1B,QAAK,mBAAmB;;AAG1B,SAAO,KAAK;;CAGd,QAAQ,MAAc;AACpB,OAAK,aAAa,cAAc;;CAGlC,iBAAiB,QAAiB;AAChC,MAAI,OACF,MAAK,KAAK,MAAM,UAAU;MAE1B,MAAK,KAAK,MAAM,UAAU;AAG5B,MAAI,KAAK,MACP,MAAK,sBAAsB;AAG7B,MAAI,KAAK,aACP,cAAa,KAAK,aAAa;;CAuFnC,oBAAoB;AAClB,MAAI,CAAC,KAAK,MACR;EAEF,MAAM,EAAE,SAAS,KAAK;AACtB,OAAK,iBAAiB,SAAS,KAAK,WAAW;AAC/C,OAAK,iBAAiB,WAAW,KAAK,aAAa;AACnD,OAAK,iBAAiB,SAAS,KAAK,cAAc;AAClD,OAAK,iBAAiB,QAAQ,KAAK,UAAU;;CAG/C,uBAAuB;AACrB,MAAI,CAAC,KAAK,SAAS,CAAC,KAAK,MAAM,KAC7B;EAGF,MAAM,EAAE,SAAS,KAAK;AACtB,OAAK,oBAAoB,SAAS,KAAK,WAAW;AAClD,OAAK,oBAAoB,WAAW,KAAK,aAAa;AACtD,OAAK,oBAAoB,SAAS,KAAK,cAAc;AACrD,OAAK,oBAAoB,QAAQ,KAAK,UAAU;;CAGlD,iBAAiB,MAAqB;EACpC,MAAM,KAAK,SAAS,cAAc,OAAO;AACzC,OAAK,cAAc,IAAI,KAAK;AAC5B,OAAK,UAAU,cAAc,GAAG;AAChC,OAAK,eAAe,iBAAiB;AACnC,QAAK,UAAU,cAAc;KAC5B,IAAK;;CAGV,cAAc,SAAsB,cAAqC;AAEvE,SAAO,QAAQ,WAAW,OACxB,SAAQ,YAAY,QAAQ,WAAW,GAAG;AAE5C,MAAI,CAAC,aACH;AAEF,MAAI,OAAO,iBAAiB,UAAU;AACpC,WAAQ,YAAY,SAAS,eAAe,aAAa,CAAC;AAC1D;;EAEF,MAAM,OAAO,KAAK,YAAY,KAAK,UAAU,aAAa,GAAG;AAC7D,UAAQ,YAAY,KAAK;;;;;;AC7P7B,SAAgB,YACd,QACA,gBAAoC,MACpC,iBAAgCe,cAChC,YAAuB,MACH;CACpB,MAAM,aAAa,IAAIC,mBAAQ,OAAO;AAEtC,KAAI,CAAC,eAAe;AAClB,aAAW,QAAQ;AACnB,SAAO;;CAGT,MAAM,YAAY,IAAI,eAAe,eAAe,QAAQ,UAAU;CACtE,IAAI,YAAY;AAEhB,YAAW,GAAG,oBAAoB,SAAS;AACzC,YAAU,QAAQ,KAAK;GACvB;AAEF,YAAW,GAAG,iBAAiB,QAAQ;AACrC,MAAI,QAAQ,IACV,aAAY;MAEZ,cAAa;AAEf,YAAU,aAAa,UAAU;GACjC;AAEF,YAAW,GAAG,0BAA0B;AACtC,cAAY;AACZ,YAAU,aAAa,UAAU;GACjC;AAEF,YAAW,GAAG,WAAW,WAAY;AACnC,YAAU,iBAAiB,MAAM;AACjC,YAAU,YAAY;AACtB,YAAU,OAAO;GACjB;AAEF,WAAU,iBAAiB,KAAK;AAChC,YAAW,aAAa,UAAU;AAClC,YAAW,QAAQ;AAEnB,QAAO"}