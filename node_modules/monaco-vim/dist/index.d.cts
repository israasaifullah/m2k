import * as MonacoEditor from "monaco-editor";

//#region src/cm_adapter.d.ts
declare function isWordCharBasic(ch: any): boolean;
declare function Pos(line: any, column: any): any;
declare function signal(cm: any, signal: any, args: any): void;
declare class Marker {
  constructor(cm: any, id: any, line: any, ch: any);
  clear(): void;
  find(): any;
}
declare function monacoToCmKey(e: any, skip?: boolean): string;
declare class CMAdapter {
  static Pos: typeof Pos;
  static signal: typeof signal;
  static on: () => void;
  static off: () => void;
  static addClass: () => void;
  static rmClass: () => void;
  static defineOption: () => void;
  static keyMap: {
    default: (key: any) => (cm: any) => boolean;
  };
  static matchingBrackets: {
    "(": string;
    ")": string;
    "[": string;
    "]": string;
    "{": string;
    "}": string;
    "<": string;
    ">": string;
  };
  static isWordChar: typeof isWordCharBasic;
  static keyName: typeof monacoToCmKey;
  static StringStream: (string: any, tabSize: any) => void;
  static e_stop: (e: any) => boolean;
  static e_preventDefault: (e: any) => boolean;
  static commands: {
    redo: (cm: any) => void;
    undo: (cm: any) => void;
    newlineAndIndent: (cm: any) => void;
  };
  static lookupKey: (key: any, map: any, handle: any) => any;
  static defineExtension: (name: any, fn: any) => void;
  constructor(editor: any);
  attach(): void;
  addLocalListeners(): void;
  handleKeyDown: (e: any) => void;
  handleReplaceMode(key: any, e: any): void;
  handleCursorChange: (e: any) => void;
  handleChange: (e: any) => void;
  setOption(key: any, value: any): void;
  getConfiguration(): any;
  getOption(key: any): any;
  dispatch(signal: any, ...args: any[]): void;
  on(event: any, handler: any): void;
  off(event: any, handler: any): void;
  firstLine(): number;
  lastLine(): number;
  lineCount(): any;
  defaultTextHeight(): number;
  getLine(line: any): any;
  getAnchorForSelection(selection: any): any;
  getHeadForSelection(selection: any): any;
  getCursor(type?: any): any;
  getRange(start: any, end: any): any;
  getSelection(): string;
  replaceRange(text: any, start: any, end: any): void;
  pushUndoStop(): void;
  setCursor(line: any, ch: any): void;
  somethingSelected(): boolean;
  operation(fn: any, force: any): any;
  listSelections(): any;
  focus(): void;
  setSelections(selections: any, primIndex: any): void;
  setSelection(frm: any, to: any): void;
  getSelections(): any;
  replaceSelections(texts: any): void;
  toggleOverwrite(toggle: any): void;
  charCoords(pos: any, mode: any): {
    top: any;
    left: any;
  };
  coordsChar(pos: any, mode: any): void;
  clipPos(p: any): any;
  setBookmark(cursor: any, options: any): Marker;
  getScrollInfo(): {
    left: number;
    top: number;
    height: any;
    clientHeight: number;
  };
  triggerEditorAction(action: any): void;
  dispose(): void;
  getInputField(): void;
  getWrapperElement(): void;
  enterVimMode(toVim?: boolean): void;
  leaveVimMode(): void;
  virtualSelectionMode(): any;
  markText(): {
    clear: () => void;
    find: () => void;
  };
  getUserVisibleLines(): {
    top: number;
    bottom: number;
  };
  findPosV(startPos: any, amount: any, unit: any): any;
  findMatchingBracket(pos: any): {
    to: any;
  };
  findFirstNonWhiteSpaceCharacter(line: any): number;
  scrollTo(x: any, y: any): void;
  moveCurrentLineTo(viewPosition: any): void;
  getSearchCursor(query: any, pos: any): {
    getMatches(): any;
    findNext(): any;
    findPrevious(): any;
    jumpTo(index: any): any;
    find(back: any): any;
    from(): any;
    to(): any;
    replace(text: any): void;
  };
  highlightRanges(ranges: any, className?: string): any;
  addOverlay({
    query
  }: {
    query: any;
  }, hasBoundary: any, style: any): void;
  removeOverlay(): void;
  scrollIntoView(pos: any): void;
  moveH(units: any, type: any): void;
  scanForBracket(pos: any, dir: any, dd: any, config: any): {
    pos: any;
  };
  indexFromPos(pos: any): any;
  posFromIndex(offset: any): any;
  indentLine(line: any, indentRight?: boolean): void;
  setStatusBar(statusBar: any): void;
  openDialog(html: any, callback: any, options: any): any;
  openNotification(html: any): void;
  smartIndent(): void;
  moveCursorTo(to: any): void;
  execCommand(command: any): void;
}
//#endregion
//#region src/statusbar.d.ts
interface VimModeChangeEvent {
  mode: string;
  subMode?: string;
}
type Sanitizer$1 = ((node: Node) => Node) | null;
interface StatusBarInputOptions {
  selectValueOnOpen?: boolean;
  value?: string;
  onKeyUp?: (event: KeyboardEvent, value: string, close: () => void) => void;
  onKeyDown?: (event: KeyboardEvent, value: string, close: () => void) => boolean | void;
  onKeyInput?: (event: InputEvent, value: string, close: () => void) => void;
  onBlur?: (event: FocusEvent, close: () => void) => void;
  closeOnBlur?: boolean;
  closeOnEnter?: boolean;
}
declare class VimStatusBar {
  private readonly node;
  private readonly modeInfoNode;
  private readonly secInfoNode;
  private readonly notifNode;
  private readonly keyInfoNode;
  private readonly editor;
  private readonly sanitizer;
  private input;
  private notifTimeout?;
  constructor(node: HTMLElement, editor: MonacoEditor.editor.IStandaloneCodeEditor | null, sanitizer?: Sanitizer$1);
  setMode(ev: VimModeChangeEvent): void;
  setKeyBuffer(key: string): void;
  setSec(text: Node | string | null | undefined, callback?: (value: string) => void, options?: StatusBarInputOptions): () => void;
  setText(text: string): void;
  toggleVisibility(toggle: boolean): void;
  closeInput: () => void;
  clear: () => void;
  inputKeyUp: (e: KeyboardEvent) => void;
  inputKeyInput: (e: InputEvent) => void;
  inputBlur: (event: FocusEvent) => void;
  inputKeyDown: (e: KeyboardEvent) => void;
  addInputListeners(): void;
  removeInputListeners(): void;
  showNotification(text: string | Node): void;
  setInnerHtml_(element: HTMLElement, htmlContents?: Node | string | null): void;
}
//#endregion
//#region src/index.d.ts
type Sanitizer = ((node: Node) => Node) | null;
type StatusBarCtor = new (node: HTMLElement, editor: MonacoEditor.editor.IStandaloneCodeEditor, sanitizer?: Sanitizer) => VimStatusBar;
type VimAdapterInstance = InstanceType<typeof CMAdapter>;
declare function initVimMode(editor: MonacoEditor.editor.IStandaloneCodeEditor, statusbarNode?: HTMLElement | null, StatusBarClass?: StatusBarCtor, sanitizer?: Sanitizer): VimAdapterInstance;
//#endregion
export { VimStatusBar as StatusBar, VimAdapterInstance, CMAdapter as VimMode, initVimMode };
//# sourceMappingURL=index.d.cts.map