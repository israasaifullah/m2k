(function(global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ?  factory(exports, require('monaco-editor/esm/vs/editor/editor.api')) :
  typeof define === 'function' && define.amd ? define(['exports', 'monaco-editor/esm/vs/editor/editor.api'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.MonacoVim = {}), global.monaco));
})(this, function(exports, monaco_editor_esm_vs_editor_editor_api) {

//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/cache.js
/**
* Uses a LRU cache to make a given parametrized function cached.
* Caches just the last value.
* The key must be JSON serializable.
*/
var LRUCachedComputed = class {
	constructor(computeFn) {
		this.computeFn = computeFn;
		this.lastCache = void 0;
		this.lastArgKey = void 0;
	}
	get(arg) {
		const key = JSON.stringify(arg);
		if (this.lastArgKey !== key) {
			this.lastArgKey = key;
			this.lastCache = this.computeFn(arg);
		}
		return this.lastCache;
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lazy.js
var Lazy = class {
	constructor(executor) {
		this.executor = executor;
		this._didRun = false;
	}
	/**
	* Get the wrapped value.
	*
	* This will force evaluation of the lazy value if it has not been resolved yet. Lazy values are only
	* resolved once. `getValue` will re-throw exceptions that are hit while resolving the value
	*/
	getValue() {
		if (!this._didRun) try {
			this._value = this.executor();
		} catch (err) {
			this._error = err;
		} finally {
			this._didRun = true;
		}
		if (this._error) throw this._error;
		return this._value;
	}
	/**
	* Get the wrapped value without forcing evaluation.
	*/
	get rawValue() {
		return this._value;
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/strings.js
var _a$1;
/**
* Escapes regular expression characters in a given string
*/
function escapeRegExpCharacters(value) {
	return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, "\\$&");
}
function createRegExp(searchString, isRegex, options = {}) {
	if (!searchString) throw new Error("Cannot create regex from empty string");
	if (!isRegex) searchString = escapeRegExpCharacters(searchString);
	if (options.wholeWord) {
		if (!/\B/.test(searchString.charAt(0))) searchString = "\\b" + searchString;
		if (!/\B/.test(searchString.charAt(searchString.length - 1))) searchString = searchString + "\\b";
	}
	let modifiers = "";
	if (options.global) modifiers += "g";
	if (!options.matchCase) modifiers += "i";
	if (options.multiline) modifiers += "m";
	if (options.unicode) modifiers += "u";
	return new RegExp(searchString, modifiers);
}
/**
* Returns first index of the string that is not whitespace.
* If string is empty or contains only whitespaces, returns -1
*/
function firstNonWhitespaceIndex(str) {
	for (let i = 0, len = str.length; i < len; i++) {
		const chCode = str.charCodeAt(i);
		if (chCode !== 32 && chCode !== 9) return i;
	}
	return -1;
}
/**
* Returns the leading whitespace of the string.
* If the string contains only whitespaces, returns entire string
*/
function getLeadingWhitespace(str, start = 0, end = str.length) {
	for (let i = start; i < end; i++) {
		const chCode = str.charCodeAt(i);
		if (chCode !== 32 && chCode !== 9) return str.substring(start, i);
	}
	return str.substring(start, end);
}
/**
* See http://en.wikipedia.org/wiki/Surrogate_pair
*/
function isHighSurrogate(charCode) {
	return 55296 <= charCode && charCode <= 56319;
}
/**
* See http://en.wikipedia.org/wiki/Surrogate_pair
*/
function isLowSurrogate(charCode) {
	return 56320 <= charCode && charCode <= 57343;
}
/**
* See http://en.wikipedia.org/wiki/Surrogate_pair
*/
function computeCodePoint(highSurrogate, lowSurrogate) {
	return (highSurrogate - 55296 << 10) + (lowSurrogate - 56320) + 65536;
}
/**
* get the code point that begins at offset `offset`
*/
function getNextCodePoint(str, len, offset) {
	const charCode = str.charCodeAt(offset);
	if (isHighSurrogate(charCode) && offset + 1 < len) {
		const nextCharCode = str.charCodeAt(offset + 1);
		if (isLowSurrogate(nextCharCode)) return computeCodePoint(charCode, nextCharCode);
	}
	return charCode;
}
/**
* get the code point that ends right before offset `offset`
*/
function getPrevCodePoint(str, offset) {
	const charCode = str.charCodeAt(offset - 1);
	if (isLowSurrogate(charCode) && offset > 1) {
		const prevCharCode = str.charCodeAt(offset - 2);
		if (isHighSurrogate(prevCharCode)) return computeCodePoint(prevCharCode, charCode);
	}
	return charCode;
}
var CodePointIterator = class {
	constructor(str, offset = 0) {
		this._str = str;
		this._len = str.length;
		this._offset = offset;
	}
	get offset() {
		return this._offset;
	}
	setOffset(offset) {
		this._offset = offset;
	}
	prevCodePoint() {
		const codePoint = getPrevCodePoint(this._str, this._offset);
		this._offset -= codePoint >= 65536 ? 2 : 1;
		return codePoint;
	}
	nextCodePoint() {
		const codePoint = getNextCodePoint(this._str, this._len, this._offset);
		this._offset += codePoint >= 65536 ? 2 : 1;
		return codePoint;
	}
	eol() {
		return this._offset >= this._len;
	}
};
var GraphemeIterator = class {
	constructor(str, offset = 0) {
		this._iterator = new CodePointIterator(str, offset);
	}
	get offset() {
		return this._iterator.offset;
	}
	nextGraphemeLength() {
		const graphemeBreakTree = GraphemeBreakTree.getInstance();
		const iterator = this._iterator;
		const initialOffset = iterator.offset;
		let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
		while (!iterator.eol()) {
			const offset = iterator.offset;
			const nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.nextCodePoint());
			if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
				iterator.setOffset(offset);
				break;
			}
			graphemeBreakType = nextGraphemeBreakType;
		}
		return iterator.offset - initialOffset;
	}
	prevGraphemeLength() {
		const graphemeBreakTree = GraphemeBreakTree.getInstance();
		const iterator = this._iterator;
		const initialOffset = iterator.offset;
		let graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
		while (iterator.offset > 0) {
			const offset = iterator.offset;
			const prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(iterator.prevCodePoint());
			if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
				iterator.setOffset(offset);
				break;
			}
			graphemeBreakType = prevGraphemeBreakType;
		}
		return initialOffset - iterator.offset;
	}
	eol() {
		return this._iterator.eol();
	}
};
function isFullWidthCharacter(charCode) {
	return charCode >= 11904 && charCode <= 55215 || charCode >= 63744 && charCode <= 64255 || charCode >= 65281 && charCode <= 65374;
}
/**
* A fast function (therefore imprecise) to check if code points are emojis.
* Generated using https://github.com/alexdima/unicode-utils/blob/main/emoji-test.js
*/
function isEmojiImprecise(x) {
	return x >= 127462 && x <= 127487 || x === 8986 || x === 8987 || x === 9200 || x === 9203 || x >= 9728 && x <= 10175 || x === 11088 || x === 11093 || x >= 127744 && x <= 128591 || x >= 128640 && x <= 128764 || x >= 128992 && x <= 129008 || x >= 129280 && x <= 129535 || x >= 129648 && x <= 129782;
}
const UTF8_BOM_CHARACTER = String.fromCharCode(65279);
function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
	if (breakTypeA === 0) return breakTypeB !== 5 && breakTypeB !== 7;
	if (breakTypeA === 2) {
		if (breakTypeB === 3) return false;
	}
	if (breakTypeA === 4 || breakTypeA === 2 || breakTypeA === 3) return true;
	if (breakTypeB === 4 || breakTypeB === 2 || breakTypeB === 3) return true;
	if (breakTypeA === 8) {
		if (breakTypeB === 8 || breakTypeB === 9 || breakTypeB === 11 || breakTypeB === 12) return false;
	}
	if (breakTypeA === 11 || breakTypeA === 9) {
		if (breakTypeB === 9 || breakTypeB === 10) return false;
	}
	if (breakTypeA === 12 || breakTypeA === 10) {
		if (breakTypeB === 10) return false;
	}
	if (breakTypeB === 5 || breakTypeB === 13) return false;
	if (breakTypeB === 7) return false;
	if (breakTypeA === 1) return false;
	if (breakTypeA === 13 && breakTypeB === 14) return false;
	if (breakTypeA === 6 && breakTypeB === 6) return false;
	return true;
}
var GraphemeBreakTree = class GraphemeBreakTree {
	constructor() {
		this._data = getGraphemeBreakRawData();
	}
	static getInstance() {
		if (!GraphemeBreakTree._INSTANCE) GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
		return GraphemeBreakTree._INSTANCE;
	}
	getGraphemeBreakType(codePoint) {
		if (codePoint < 32) {
			if (codePoint === 10) return 3;
			if (codePoint === 13) return 2;
			return 4;
		}
		if (codePoint < 127) return 0;
		const data = this._data;
		const nodeCount = data.length / 3;
		let nodeIndex = 1;
		while (nodeIndex <= nodeCount) if (codePoint < data[3 * nodeIndex]) nodeIndex = 2 * nodeIndex;
		else if (codePoint > data[3 * nodeIndex + 1]) nodeIndex = 2 * nodeIndex + 1;
		else return data[3 * nodeIndex + 2];
		return 0;
	}
};
GraphemeBreakTree._INSTANCE = null;
function getGraphemeBreakRawData() {
	return JSON.parse("[0,0,0,51229,51255,12,44061,44087,12,127462,127487,6,7083,7085,5,47645,47671,12,54813,54839,12,128678,128678,14,3270,3270,5,9919,9923,14,45853,45879,12,49437,49463,12,53021,53047,12,71216,71218,7,128398,128399,14,129360,129374,14,2519,2519,5,4448,4519,9,9742,9742,14,12336,12336,14,44957,44983,12,46749,46775,12,48541,48567,12,50333,50359,12,52125,52151,12,53917,53943,12,69888,69890,5,73018,73018,5,127990,127990,14,128558,128559,14,128759,128760,14,129653,129655,14,2027,2035,5,2891,2892,7,3761,3761,5,6683,6683,5,8293,8293,4,9825,9826,14,9999,9999,14,43452,43453,5,44509,44535,12,45405,45431,12,46301,46327,12,47197,47223,12,48093,48119,12,48989,49015,12,49885,49911,12,50781,50807,12,51677,51703,12,52573,52599,12,53469,53495,12,54365,54391,12,65279,65279,4,70471,70472,7,72145,72147,7,119173,119179,5,127799,127818,14,128240,128244,14,128512,128512,14,128652,128652,14,128721,128722,14,129292,129292,14,129445,129450,14,129734,129743,14,1476,1477,5,2366,2368,7,2750,2752,7,3076,3076,5,3415,3415,5,4141,4144,5,6109,6109,5,6964,6964,5,7394,7400,5,9197,9198,14,9770,9770,14,9877,9877,14,9968,9969,14,10084,10084,14,43052,43052,5,43713,43713,5,44285,44311,12,44733,44759,12,45181,45207,12,45629,45655,12,46077,46103,12,46525,46551,12,46973,46999,12,47421,47447,12,47869,47895,12,48317,48343,12,48765,48791,12,49213,49239,12,49661,49687,12,50109,50135,12,50557,50583,12,51005,51031,12,51453,51479,12,51901,51927,12,52349,52375,12,52797,52823,12,53245,53271,12,53693,53719,12,54141,54167,12,54589,54615,12,55037,55063,12,69506,69509,5,70191,70193,5,70841,70841,7,71463,71467,5,72330,72342,5,94031,94031,5,123628,123631,5,127763,127765,14,127941,127941,14,128043,128062,14,128302,128317,14,128465,128467,14,128539,128539,14,128640,128640,14,128662,128662,14,128703,128703,14,128745,128745,14,129004,129007,14,129329,129330,14,129402,129402,14,129483,129483,14,129686,129704,14,130048,131069,14,173,173,4,1757,1757,1,2200,2207,5,2434,2435,7,2631,2632,5,2817,2817,5,3008,3008,5,3201,3201,5,3387,3388,5,3542,3542,5,3902,3903,7,4190,4192,5,6002,6003,5,6439,6440,5,6765,6770,7,7019,7027,5,7154,7155,7,8205,8205,13,8505,8505,14,9654,9654,14,9757,9757,14,9792,9792,14,9852,9853,14,9890,9894,14,9937,9937,14,9981,9981,14,10035,10036,14,11035,11036,14,42654,42655,5,43346,43347,7,43587,43587,5,44006,44007,7,44173,44199,12,44397,44423,12,44621,44647,12,44845,44871,12,45069,45095,12,45293,45319,12,45517,45543,12,45741,45767,12,45965,45991,12,46189,46215,12,46413,46439,12,46637,46663,12,46861,46887,12,47085,47111,12,47309,47335,12,47533,47559,12,47757,47783,12,47981,48007,12,48205,48231,12,48429,48455,12,48653,48679,12,48877,48903,12,49101,49127,12,49325,49351,12,49549,49575,12,49773,49799,12,49997,50023,12,50221,50247,12,50445,50471,12,50669,50695,12,50893,50919,12,51117,51143,12,51341,51367,12,51565,51591,12,51789,51815,12,52013,52039,12,52237,52263,12,52461,52487,12,52685,52711,12,52909,52935,12,53133,53159,12,53357,53383,12,53581,53607,12,53805,53831,12,54029,54055,12,54253,54279,12,54477,54503,12,54701,54727,12,54925,54951,12,55149,55175,12,68101,68102,5,69762,69762,7,70067,70069,7,70371,70378,5,70720,70721,7,71087,71087,5,71341,71341,5,71995,71996,5,72249,72249,7,72850,72871,5,73109,73109,5,118576,118598,5,121505,121519,5,127245,127247,14,127568,127569,14,127777,127777,14,127872,127891,14,127956,127967,14,128015,128016,14,128110,128172,14,128259,128259,14,128367,128368,14,128424,128424,14,128488,128488,14,128530,128532,14,128550,128551,14,128566,128566,14,128647,128647,14,128656,128656,14,128667,128673,14,128691,128693,14,128715,128715,14,128728,128732,14,128752,128752,14,128765,128767,14,129096,129103,14,129311,129311,14,129344,129349,14,129394,129394,14,129413,129425,14,129466,129471,14,129511,129535,14,129664,129666,14,129719,129722,14,129760,129767,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2307,2307,7,2382,2383,7,2497,2500,5,2563,2563,7,2677,2677,5,2763,2764,7,2879,2879,5,2914,2915,5,3021,3021,5,3142,3144,5,3263,3263,5,3285,3286,5,3398,3400,7,3530,3530,5,3633,3633,5,3864,3865,5,3974,3975,5,4155,4156,7,4229,4230,5,5909,5909,7,6078,6085,7,6277,6278,5,6451,6456,7,6744,6750,5,6846,6846,5,6972,6972,5,7074,7077,5,7146,7148,7,7222,7223,5,7416,7417,5,8234,8238,4,8417,8417,5,9000,9000,14,9203,9203,14,9730,9731,14,9748,9749,14,9762,9763,14,9776,9783,14,9800,9811,14,9831,9831,14,9872,9873,14,9882,9882,14,9900,9903,14,9929,9933,14,9941,9960,14,9974,9974,14,9989,9989,14,10006,10006,14,10062,10062,14,10160,10160,14,11647,11647,5,12953,12953,14,43019,43019,5,43232,43249,5,43443,43443,5,43567,43568,7,43696,43696,5,43765,43765,7,44013,44013,5,44117,44143,12,44229,44255,12,44341,44367,12,44453,44479,12,44565,44591,12,44677,44703,12,44789,44815,12,44901,44927,12,45013,45039,12,45125,45151,12,45237,45263,12,45349,45375,12,45461,45487,12,45573,45599,12,45685,45711,12,45797,45823,12,45909,45935,12,46021,46047,12,46133,46159,12,46245,46271,12,46357,46383,12,46469,46495,12,46581,46607,12,46693,46719,12,46805,46831,12,46917,46943,12,47029,47055,12,47141,47167,12,47253,47279,12,47365,47391,12,47477,47503,12,47589,47615,12,47701,47727,12,47813,47839,12,47925,47951,12,48037,48063,12,48149,48175,12,48261,48287,12,48373,48399,12,48485,48511,12,48597,48623,12,48709,48735,12,48821,48847,12,48933,48959,12,49045,49071,12,49157,49183,12,49269,49295,12,49381,49407,12,49493,49519,12,49605,49631,12,49717,49743,12,49829,49855,12,49941,49967,12,50053,50079,12,50165,50191,12,50277,50303,12,50389,50415,12,50501,50527,12,50613,50639,12,50725,50751,12,50837,50863,12,50949,50975,12,51061,51087,12,51173,51199,12,51285,51311,12,51397,51423,12,51509,51535,12,51621,51647,12,51733,51759,12,51845,51871,12,51957,51983,12,52069,52095,12,52181,52207,12,52293,52319,12,52405,52431,12,52517,52543,12,52629,52655,12,52741,52767,12,52853,52879,12,52965,52991,12,53077,53103,12,53189,53215,12,53301,53327,12,53413,53439,12,53525,53551,12,53637,53663,12,53749,53775,12,53861,53887,12,53973,53999,12,54085,54111,12,54197,54223,12,54309,54335,12,54421,54447,12,54533,54559,12,54645,54671,12,54757,54783,12,54869,54895,12,54981,55007,12,55093,55119,12,55243,55291,10,66045,66045,5,68325,68326,5,69688,69702,5,69817,69818,5,69957,69958,7,70089,70092,5,70198,70199,5,70462,70462,5,70502,70508,5,70750,70750,5,70846,70846,7,71100,71101,5,71230,71230,7,71351,71351,5,71737,71738,5,72000,72000,7,72160,72160,5,72273,72278,5,72752,72758,5,72882,72883,5,73031,73031,5,73461,73462,7,94192,94193,7,119149,119149,7,121403,121452,5,122915,122916,5,126980,126980,14,127358,127359,14,127535,127535,14,127759,127759,14,127771,127771,14,127792,127793,14,127825,127867,14,127897,127899,14,127945,127945,14,127985,127986,14,128000,128007,14,128021,128021,14,128066,128100,14,128184,128235,14,128249,128252,14,128266,128276,14,128335,128335,14,128379,128390,14,128407,128419,14,128444,128444,14,128481,128481,14,128499,128499,14,128526,128526,14,128536,128536,14,128543,128543,14,128556,128556,14,128564,128564,14,128577,128580,14,128643,128645,14,128649,128649,14,128654,128654,14,128660,128660,14,128664,128664,14,128675,128675,14,128686,128689,14,128695,128696,14,128705,128709,14,128717,128719,14,128725,128725,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129009,129023,14,129160,129167,14,129296,129304,14,129320,129327,14,129340,129342,14,129356,129356,14,129388,129392,14,129399,129400,14,129404,129407,14,129432,129442,14,129454,129455,14,129473,129474,14,129485,129487,14,129648,129651,14,129659,129660,14,129671,129679,14,129709,129711,14,129728,129730,14,129751,129753,14,129776,129782,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2274,2274,1,2363,2363,7,2377,2380,7,2402,2403,5,2494,2494,5,2507,2508,7,2558,2558,5,2622,2624,7,2641,2641,5,2691,2691,7,2759,2760,5,2786,2787,5,2876,2876,5,2881,2884,5,2901,2902,5,3006,3006,5,3014,3016,7,3072,3072,5,3134,3136,5,3157,3158,5,3260,3260,5,3266,3266,5,3274,3275,7,3328,3329,5,3391,3392,7,3405,3405,5,3457,3457,5,3536,3537,7,3551,3551,5,3636,3642,5,3764,3772,5,3895,3895,5,3967,3967,7,3993,4028,5,4146,4151,5,4182,4183,7,4226,4226,5,4253,4253,5,4957,4959,5,5940,5940,7,6070,6070,7,6087,6088,7,6158,6158,4,6432,6434,5,6448,6449,7,6679,6680,5,6742,6742,5,6754,6754,5,6783,6783,5,6912,6915,5,6966,6970,5,6978,6978,5,7042,7042,7,7080,7081,5,7143,7143,7,7150,7150,7,7212,7219,5,7380,7392,5,7412,7412,5,8203,8203,4,8232,8232,4,8265,8265,14,8400,8412,5,8421,8432,5,8617,8618,14,9167,9167,14,9200,9200,14,9410,9410,14,9723,9726,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9774,14,9786,9786,14,9794,9794,14,9823,9823,14,9828,9828,14,9833,9850,14,9855,9855,14,9875,9875,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9935,9935,14,9939,9939,14,9962,9962,14,9972,9972,14,9978,9978,14,9986,9986,14,9997,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10133,10135,14,10548,10549,14,11093,11093,14,12330,12333,5,12441,12442,5,42608,42610,5,43010,43010,5,43045,43046,5,43188,43203,7,43302,43309,5,43392,43394,5,43446,43449,5,43493,43493,5,43571,43572,7,43597,43597,7,43703,43704,5,43756,43757,5,44003,44004,7,44009,44010,7,44033,44059,12,44089,44115,12,44145,44171,12,44201,44227,12,44257,44283,12,44313,44339,12,44369,44395,12,44425,44451,12,44481,44507,12,44537,44563,12,44593,44619,12,44649,44675,12,44705,44731,12,44761,44787,12,44817,44843,12,44873,44899,12,44929,44955,12,44985,45011,12,45041,45067,12,45097,45123,12,45153,45179,12,45209,45235,12,45265,45291,12,45321,45347,12,45377,45403,12,45433,45459,12,45489,45515,12,45545,45571,12,45601,45627,12,45657,45683,12,45713,45739,12,45769,45795,12,45825,45851,12,45881,45907,12,45937,45963,12,45993,46019,12,46049,46075,12,46105,46131,12,46161,46187,12,46217,46243,12,46273,46299,12,46329,46355,12,46385,46411,12,46441,46467,12,46497,46523,12,46553,46579,12,46609,46635,12,46665,46691,12,46721,46747,12,46777,46803,12,46833,46859,12,46889,46915,12,46945,46971,12,47001,47027,12,47057,47083,12,47113,47139,12,47169,47195,12,47225,47251,12,47281,47307,12,47337,47363,12,47393,47419,12,47449,47475,12,47505,47531,12,47561,47587,12,47617,47643,12,47673,47699,12,47729,47755,12,47785,47811,12,47841,47867,12,47897,47923,12,47953,47979,12,48009,48035,12,48065,48091,12,48121,48147,12,48177,48203,12,48233,48259,12,48289,48315,12,48345,48371,12,48401,48427,12,48457,48483,12,48513,48539,12,48569,48595,12,48625,48651,12,48681,48707,12,48737,48763,12,48793,48819,12,48849,48875,12,48905,48931,12,48961,48987,12,49017,49043,12,49073,49099,12,49129,49155,12,49185,49211,12,49241,49267,12,49297,49323,12,49353,49379,12,49409,49435,12,49465,49491,12,49521,49547,12,49577,49603,12,49633,49659,12,49689,49715,12,49745,49771,12,49801,49827,12,49857,49883,12,49913,49939,12,49969,49995,12,50025,50051,12,50081,50107,12,50137,50163,12,50193,50219,12,50249,50275,12,50305,50331,12,50361,50387,12,50417,50443,12,50473,50499,12,50529,50555,12,50585,50611,12,50641,50667,12,50697,50723,12,50753,50779,12,50809,50835,12,50865,50891,12,50921,50947,12,50977,51003,12,51033,51059,12,51089,51115,12,51145,51171,12,51201,51227,12,51257,51283,12,51313,51339,12,51369,51395,12,51425,51451,12,51481,51507,12,51537,51563,12,51593,51619,12,51649,51675,12,51705,51731,12,51761,51787,12,51817,51843,12,51873,51899,12,51929,51955,12,51985,52011,12,52041,52067,12,52097,52123,12,52153,52179,12,52209,52235,12,52265,52291,12,52321,52347,12,52377,52403,12,52433,52459,12,52489,52515,12,52545,52571,12,52601,52627,12,52657,52683,12,52713,52739,12,52769,52795,12,52825,52851,12,52881,52907,12,52937,52963,12,52993,53019,12,53049,53075,12,53105,53131,12,53161,53187,12,53217,53243,12,53273,53299,12,53329,53355,12,53385,53411,12,53441,53467,12,53497,53523,12,53553,53579,12,53609,53635,12,53665,53691,12,53721,53747,12,53777,53803,12,53833,53859,12,53889,53915,12,53945,53971,12,54001,54027,12,54057,54083,12,54113,54139,12,54169,54195,12,54225,54251,12,54281,54307,12,54337,54363,12,54393,54419,12,54449,54475,12,54505,54531,12,54561,54587,12,54617,54643,12,54673,54699,12,54729,54755,12,54785,54811,12,54841,54867,12,54897,54923,12,54953,54979,12,55009,55035,12,55065,55091,12,55121,55147,12,55177,55203,12,65024,65039,5,65520,65528,4,66422,66426,5,68152,68154,5,69291,69292,5,69633,69633,5,69747,69748,5,69811,69814,5,69826,69826,5,69932,69932,7,70016,70017,5,70079,70080,7,70095,70095,5,70196,70196,5,70367,70367,5,70402,70403,7,70464,70464,5,70487,70487,5,70709,70711,7,70725,70725,7,70833,70834,7,70843,70844,7,70849,70849,7,71090,71093,5,71103,71104,5,71227,71228,7,71339,71339,5,71344,71349,5,71458,71461,5,71727,71735,5,71985,71989,7,71998,71998,5,72002,72002,7,72154,72155,5,72193,72202,5,72251,72254,5,72281,72283,5,72344,72345,5,72766,72766,7,72874,72880,5,72885,72886,5,73023,73029,5,73104,73105,5,73111,73111,5,92912,92916,5,94095,94098,5,113824,113827,4,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,125252,125258,5,127183,127183,14,127340,127343,14,127377,127386,14,127491,127503,14,127548,127551,14,127744,127756,14,127761,127761,14,127769,127769,14,127773,127774,14,127780,127788,14,127796,127797,14,127820,127823,14,127869,127869,14,127894,127895,14,127902,127903,14,127943,127943,14,127947,127950,14,127972,127972,14,127988,127988,14,127992,127994,14,128009,128011,14,128019,128019,14,128023,128041,14,128064,128064,14,128102,128107,14,128174,128181,14,128238,128238,14,128246,128247,14,128254,128254,14,128264,128264,14,128278,128299,14,128329,128330,14,128348,128359,14,128371,128377,14,128392,128393,14,128401,128404,14,128421,128421,14,128433,128434,14,128450,128452,14,128476,128478,14,128483,128483,14,128495,128495,14,128506,128506,14,128519,128520,14,128528,128528,14,128534,128534,14,128538,128538,14,128540,128542,14,128544,128549,14,128552,128555,14,128557,128557,14,128560,128563,14,128565,128565,14,128567,128576,14,128581,128591,14,128641,128642,14,128646,128646,14,128648,128648,14,128650,128651,14,128653,128653,14,128655,128655,14,128657,128659,14,128661,128661,14,128663,128663,14,128665,128666,14,128674,128674,14,128676,128677,14,128679,128685,14,128690,128690,14,128694,128694,14,128697,128702,14,128704,128704,14,128710,128714,14,128716,128716,14,128720,128720,14,128723,128724,14,128726,128727,14,128733,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129008,129008,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129661,129663,14,129667,129670,14,129680,129685,14,129705,129708,14,129712,129718,14,129723,129727,14,129731,129733,14,129744,129750,14,129754,129759,14,129768,129775,14,129783,129791,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2192,2193,1,2250,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3132,3132,5,3137,3140,7,3146,3149,5,3170,3171,5,3202,3203,7,3262,3262,7,3264,3265,7,3267,3268,7,3271,3272,7,3276,3277,5,3298,3299,5,3330,3331,7,3390,3390,5,3393,3396,5,3402,3404,7,3406,3406,1,3426,3427,5,3458,3459,7,3535,3535,5,3538,3540,5,3544,3550,7,3570,3571,7,3635,3635,7,3655,3662,5,3763,3763,7,3784,3789,5,3893,3893,5,3897,3897,5,3953,3966,5,3968,3972,5,3981,3991,5,4038,4038,5,4145,4145,7,4153,4154,5,4157,4158,5,4184,4185,5,4209,4212,5,4228,4228,7,4237,4237,5,4352,4447,8,4520,4607,10,5906,5908,5,5938,5939,5,5970,5971,5,6068,6069,5,6071,6077,5,6086,6086,5,6089,6099,5,6155,6157,5,6159,6159,5,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6862,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7679,5,8204,8204,5,8206,8207,4,8233,8233,4,8252,8252,14,8288,8292,4,8294,8303,4,8413,8416,5,8418,8420,5,8482,8482,14,8596,8601,14,8986,8987,14,9096,9096,14,9193,9196,14,9199,9199,14,9201,9202,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9729,14,9732,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9775,9775,14,9784,9785,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9874,14,9876,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9934,14,9936,9936,14,9938,9938,14,9940,9940,14,9961,9961,14,9963,9967,14,9970,9971,14,9973,9973,14,9975,9977,14,9979,9980,14,9982,9985,14,9987,9988,14,9992,9996,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10083,14,10085,10087,14,10145,10145,14,10175,10175,14,11013,11015,14,11088,11088,14,11503,11505,5,11744,11775,5,12334,12335,5,12349,12349,14,12951,12951,14,42607,42607,5,42612,42621,5,42736,42737,5,43014,43014,5,43043,43044,7,43047,43047,7,43136,43137,7,43204,43205,5,43263,43263,5,43335,43345,5,43360,43388,8,43395,43395,7,43444,43445,7,43450,43451,7,43454,43456,7,43561,43566,5,43569,43570,5,43573,43574,5,43596,43596,5,43644,43644,5,43698,43700,5,43710,43711,5,43755,43755,7,43758,43759,7,43766,43766,5,44005,44005,5,44008,44008,5,44012,44012,7,44032,44032,11,44060,44060,11,44088,44088,11,44116,44116,11,44144,44144,11,44172,44172,11,44200,44200,11,44228,44228,11,44256,44256,11,44284,44284,11,44312,44312,11,44340,44340,11,44368,44368,11,44396,44396,11,44424,44424,11,44452,44452,11,44480,44480,11,44508,44508,11,44536,44536,11,44564,44564,11,44592,44592,11,44620,44620,11,44648,44648,11,44676,44676,11,44704,44704,11,44732,44732,11,44760,44760,11,44788,44788,11,44816,44816,11,44844,44844,11,44872,44872,11,44900,44900,11,44928,44928,11,44956,44956,11,44984,44984,11,45012,45012,11,45040,45040,11,45068,45068,11,45096,45096,11,45124,45124,11,45152,45152,11,45180,45180,11,45208,45208,11,45236,45236,11,45264,45264,11,45292,45292,11,45320,45320,11,45348,45348,11,45376,45376,11,45404,45404,11,45432,45432,11,45460,45460,11,45488,45488,11,45516,45516,11,45544,45544,11,45572,45572,11,45600,45600,11,45628,45628,11,45656,45656,11,45684,45684,11,45712,45712,11,45740,45740,11,45768,45768,11,45796,45796,11,45824,45824,11,45852,45852,11,45880,45880,11,45908,45908,11,45936,45936,11,45964,45964,11,45992,45992,11,46020,46020,11,46048,46048,11,46076,46076,11,46104,46104,11,46132,46132,11,46160,46160,11,46188,46188,11,46216,46216,11,46244,46244,11,46272,46272,11,46300,46300,11,46328,46328,11,46356,46356,11,46384,46384,11,46412,46412,11,46440,46440,11,46468,46468,11,46496,46496,11,46524,46524,11,46552,46552,11,46580,46580,11,46608,46608,11,46636,46636,11,46664,46664,11,46692,46692,11,46720,46720,11,46748,46748,11,46776,46776,11,46804,46804,11,46832,46832,11,46860,46860,11,46888,46888,11,46916,46916,11,46944,46944,11,46972,46972,11,47000,47000,11,47028,47028,11,47056,47056,11,47084,47084,11,47112,47112,11,47140,47140,11,47168,47168,11,47196,47196,11,47224,47224,11,47252,47252,11,47280,47280,11,47308,47308,11,47336,47336,11,47364,47364,11,47392,47392,11,47420,47420,11,47448,47448,11,47476,47476,11,47504,47504,11,47532,47532,11,47560,47560,11,47588,47588,11,47616,47616,11,47644,47644,11,47672,47672,11,47700,47700,11,47728,47728,11,47756,47756,11,47784,47784,11,47812,47812,11,47840,47840,11,47868,47868,11,47896,47896,11,47924,47924,11,47952,47952,11,47980,47980,11,48008,48008,11,48036,48036,11,48064,48064,11,48092,48092,11,48120,48120,11,48148,48148,11,48176,48176,11,48204,48204,11,48232,48232,11,48260,48260,11,48288,48288,11,48316,48316,11,48344,48344,11,48372,48372,11,48400,48400,11,48428,48428,11,48456,48456,11,48484,48484,11,48512,48512,11,48540,48540,11,48568,48568,11,48596,48596,11,48624,48624,11,48652,48652,11,48680,48680,11,48708,48708,11,48736,48736,11,48764,48764,11,48792,48792,11,48820,48820,11,48848,48848,11,48876,48876,11,48904,48904,11,48932,48932,11,48960,48960,11,48988,48988,11,49016,49016,11,49044,49044,11,49072,49072,11,49100,49100,11,49128,49128,11,49156,49156,11,49184,49184,11,49212,49212,11,49240,49240,11,49268,49268,11,49296,49296,11,49324,49324,11,49352,49352,11,49380,49380,11,49408,49408,11,49436,49436,11,49464,49464,11,49492,49492,11,49520,49520,11,49548,49548,11,49576,49576,11,49604,49604,11,49632,49632,11,49660,49660,11,49688,49688,11,49716,49716,11,49744,49744,11,49772,49772,11,49800,49800,11,49828,49828,11,49856,49856,11,49884,49884,11,49912,49912,11,49940,49940,11,49968,49968,11,49996,49996,11,50024,50024,11,50052,50052,11,50080,50080,11,50108,50108,11,50136,50136,11,50164,50164,11,50192,50192,11,50220,50220,11,50248,50248,11,50276,50276,11,50304,50304,11,50332,50332,11,50360,50360,11,50388,50388,11,50416,50416,11,50444,50444,11,50472,50472,11,50500,50500,11,50528,50528,11,50556,50556,11,50584,50584,11,50612,50612,11,50640,50640,11,50668,50668,11,50696,50696,11,50724,50724,11,50752,50752,11,50780,50780,11,50808,50808,11,50836,50836,11,50864,50864,11,50892,50892,11,50920,50920,11,50948,50948,11,50976,50976,11,51004,51004,11,51032,51032,11,51060,51060,11,51088,51088,11,51116,51116,11,51144,51144,11,51172,51172,11,51200,51200,11,51228,51228,11,51256,51256,11,51284,51284,11,51312,51312,11,51340,51340,11,51368,51368,11,51396,51396,11,51424,51424,11,51452,51452,11,51480,51480,11,51508,51508,11,51536,51536,11,51564,51564,11,51592,51592,11,51620,51620,11,51648,51648,11,51676,51676,11,51704,51704,11,51732,51732,11,51760,51760,11,51788,51788,11,51816,51816,11,51844,51844,11,51872,51872,11,51900,51900,11,51928,51928,11,51956,51956,11,51984,51984,11,52012,52012,11,52040,52040,11,52068,52068,11,52096,52096,11,52124,52124,11,52152,52152,11,52180,52180,11,52208,52208,11,52236,52236,11,52264,52264,11,52292,52292,11,52320,52320,11,52348,52348,11,52376,52376,11,52404,52404,11,52432,52432,11,52460,52460,11,52488,52488,11,52516,52516,11,52544,52544,11,52572,52572,11,52600,52600,11,52628,52628,11,52656,52656,11,52684,52684,11,52712,52712,11,52740,52740,11,52768,52768,11,52796,52796,11,52824,52824,11,52852,52852,11,52880,52880,11,52908,52908,11,52936,52936,11,52964,52964,11,52992,52992,11,53020,53020,11,53048,53048,11,53076,53076,11,53104,53104,11,53132,53132,11,53160,53160,11,53188,53188,11,53216,53216,11,53244,53244,11,53272,53272,11,53300,53300,11,53328,53328,11,53356,53356,11,53384,53384,11,53412,53412,11,53440,53440,11,53468,53468,11,53496,53496,11,53524,53524,11,53552,53552,11,53580,53580,11,53608,53608,11,53636,53636,11,53664,53664,11,53692,53692,11,53720,53720,11,53748,53748,11,53776,53776,11,53804,53804,11,53832,53832,11,53860,53860,11,53888,53888,11,53916,53916,11,53944,53944,11,53972,53972,11,54000,54000,11,54028,54028,11,54056,54056,11,54084,54084,11,54112,54112,11,54140,54140,11,54168,54168,11,54196,54196,11,54224,54224,11,54252,54252,11,54280,54280,11,54308,54308,11,54336,54336,11,54364,54364,11,54392,54392,11,54420,54420,11,54448,54448,11,54476,54476,11,54504,54504,11,54532,54532,11,54560,54560,11,54588,54588,11,54616,54616,11,54644,54644,11,54672,54672,11,54700,54700,11,54728,54728,11,54756,54756,11,54784,54784,11,54812,54812,11,54840,54840,11,54868,54868,11,54896,54896,11,54924,54924,11,54952,54952,11,54980,54980,11,55008,55008,11,55036,55036,11,55064,55064,11,55092,55092,11,55120,55120,11,55148,55148,11,55176,55176,11,55216,55238,9,64286,64286,5,65056,65071,5,65438,65439,5,65529,65531,4,66272,66272,5,68097,68099,5,68108,68111,5,68159,68159,5,68900,68903,5,69446,69456,5,69632,69632,7,69634,69634,7,69744,69744,5,69759,69761,5,69808,69810,7,69815,69816,7,69821,69821,1,69837,69837,1,69927,69931,5,69933,69940,5,70003,70003,5,70018,70018,7,70070,70078,5,70082,70083,1,70094,70094,7,70188,70190,7,70194,70195,7,70197,70197,7,70206,70206,5,70368,70370,7,70400,70401,5,70459,70460,5,70463,70463,7,70465,70468,7,70475,70477,7,70498,70499,7,70512,70516,5,70712,70719,5,70722,70724,5,70726,70726,5,70832,70832,5,70835,70840,5,70842,70842,5,70845,70845,5,70847,70848,5,70850,70851,5,71088,71089,7,71096,71099,7,71102,71102,7,71132,71133,5,71219,71226,5,71229,71229,5,71231,71232,5,71340,71340,7,71342,71343,7,71350,71350,7,71453,71455,5,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,118528,118573,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123566,123566,5,125136,125142,5,126976,126979,14,126981,127182,14,127184,127231,14,127279,127279,14,127344,127345,14,127374,127374,14,127405,127461,14,127489,127490,14,127514,127514,14,127538,127546,14,127561,127567,14,127570,127743,14,127757,127758,14,127760,127760,14,127762,127762,14,127766,127768,14,127770,127770,14,127772,127772,14,127775,127776,14,127778,127779,14,127789,127791,14,127794,127795,14,127798,127798,14,127819,127819,14,127824,127824,14,127868,127868,14,127870,127871,14,127892,127893,14,127896,127896,14,127900,127901,14,127904,127940,14,127942,127942,14,127944,127944,14,127946,127946,14,127951,127955,14,127968,127971,14,127973,127984,14,127987,127987,14,127989,127989,14,127991,127991,14,127995,127999,5,128008,128008,14,128012,128014,14,128017,128018,14,128020,128020,14,128022,128022,14,128042,128042,14,128063,128063,14,128065,128065,14,128101,128101,14,128108,128109,14,128173,128173,14,128182,128183,14,128236,128237,14,128239,128239,14,128245,128245,14,128248,128248,14,128253,128253,14,128255,128258,14,128260,128263,14,128265,128265,14,128277,128277,14,128300,128301,14,128326,128328,14,128331,128334,14,128336,128347,14,128360,128366,14,128369,128370,14,128378,128378,14,128391,128391,14,128394,128397,14,128400,128400,14,128405,128406,14,128420,128420,14,128422,128423,14,128425,128432,14,128435,128443,14,128445,128449,14,128453,128464,14,128468,128475,14,128479,128480,14,128482,128482,14,128484,128487,14,128489,128494,14,128496,128498,14,128500,128505,14,128507,128511,14,128513,128518,14,128521,128525,14,128527,128527,14,128529,128529,14,128533,128533,14,128535,128535,14,128537,128537,14]");
}
var AmbiguousCharacters = class AmbiguousCharacters {
	constructor(confusableDictionary) {
		this.confusableDictionary = confusableDictionary;
	}
	static getInstance(locales) {
		return AmbiguousCharacters.cache.get(Array.from(locales));
	}
	static getLocales() {
		return AmbiguousCharacters._locales.getValue();
	}
	isAmbiguous(codePoint) {
		return this.confusableDictionary.has(codePoint);
	}
	/**
	* Returns the non basic ASCII code point that the given code point can be confused,
	* or undefined if such code point does note exist.
	*/
	getPrimaryConfusable(codePoint) {
		return this.confusableDictionary.get(codePoint);
	}
	getConfusableCodePoints() {
		return new Set(this.confusableDictionary.keys());
	}
};
_a$1 = AmbiguousCharacters;
AmbiguousCharacters.ambiguousCharacterData = new Lazy(() => {
	return JSON.parse("{\"_common\":[8232,32,8233,32,5760,32,8192,32,8193,32,8194,32,8195,32,8196,32,8197,32,8198,32,8200,32,8201,32,8202,32,8287,32,8199,32,8239,32,2042,95,65101,95,65102,95,65103,95,8208,45,8209,45,8210,45,65112,45,1748,45,8259,45,727,45,8722,45,10134,45,11450,45,1549,44,1643,44,8218,44,184,44,42233,44,894,59,2307,58,2691,58,1417,58,1795,58,1796,58,5868,58,65072,58,6147,58,6153,58,8282,58,1475,58,760,58,42889,58,8758,58,720,58,42237,58,451,33,11601,33,660,63,577,63,2429,63,5038,63,42731,63,119149,46,8228,46,1793,46,1794,46,42510,46,68176,46,1632,46,1776,46,42232,46,1373,96,65287,96,8219,96,8242,96,1370,96,1523,96,8175,96,65344,96,900,96,8189,96,8125,96,8127,96,8190,96,697,96,884,96,712,96,714,96,715,96,756,96,699,96,701,96,700,96,702,96,42892,96,1497,96,2036,96,2037,96,5194,96,5836,96,94033,96,94034,96,65339,91,10088,40,10098,40,12308,40,64830,40,65341,93,10089,41,10099,41,12309,41,64831,41,10100,123,119060,123,10101,125,65342,94,8270,42,1645,42,8727,42,66335,42,5941,47,8257,47,8725,47,8260,47,9585,47,10187,47,10744,47,119354,47,12755,47,12339,47,11462,47,20031,47,12035,47,65340,92,65128,92,8726,92,10189,92,10741,92,10745,92,119311,92,119355,92,12756,92,20022,92,12034,92,42872,38,708,94,710,94,5869,43,10133,43,66203,43,8249,60,10094,60,706,60,119350,60,5176,60,5810,60,5120,61,11840,61,12448,61,42239,61,8250,62,10095,62,707,62,119351,62,5171,62,94015,62,8275,126,732,126,8128,126,8764,126,65372,124,65293,45,120784,50,120794,50,120804,50,120814,50,120824,50,130034,50,42842,50,423,50,1000,50,42564,50,5311,50,42735,50,119302,51,120785,51,120795,51,120805,51,120815,51,120825,51,130035,51,42923,51,540,51,439,51,42858,51,11468,51,1248,51,94011,51,71882,51,120786,52,120796,52,120806,52,120816,52,120826,52,130036,52,5070,52,71855,52,120787,53,120797,53,120807,53,120817,53,120827,53,130037,53,444,53,71867,53,120788,54,120798,54,120808,54,120818,54,120828,54,130038,54,11474,54,5102,54,71893,54,119314,55,120789,55,120799,55,120809,55,120819,55,120829,55,130039,55,66770,55,71878,55,2819,56,2538,56,2666,56,125131,56,120790,56,120800,56,120810,56,120820,56,120830,56,130040,56,547,56,546,56,66330,56,2663,57,2920,57,2541,57,3437,57,120791,57,120801,57,120811,57,120821,57,120831,57,130041,57,42862,57,11466,57,71884,57,71852,57,71894,57,9082,97,65345,97,119834,97,119886,97,119938,97,119990,97,120042,97,120094,97,120146,97,120198,97,120250,97,120302,97,120354,97,120406,97,120458,97,593,97,945,97,120514,97,120572,97,120630,97,120688,97,120746,97,65313,65,119808,65,119860,65,119912,65,119964,65,120016,65,120068,65,120120,65,120172,65,120224,65,120276,65,120328,65,120380,65,120432,65,913,65,120488,65,120546,65,120604,65,120662,65,120720,65,5034,65,5573,65,42222,65,94016,65,66208,65,119835,98,119887,98,119939,98,119991,98,120043,98,120095,98,120147,98,120199,98,120251,98,120303,98,120355,98,120407,98,120459,98,388,98,5071,98,5234,98,5551,98,65314,66,8492,66,119809,66,119861,66,119913,66,120017,66,120069,66,120121,66,120173,66,120225,66,120277,66,120329,66,120381,66,120433,66,42932,66,914,66,120489,66,120547,66,120605,66,120663,66,120721,66,5108,66,5623,66,42192,66,66178,66,66209,66,66305,66,65347,99,8573,99,119836,99,119888,99,119940,99,119992,99,120044,99,120096,99,120148,99,120200,99,120252,99,120304,99,120356,99,120408,99,120460,99,7428,99,1010,99,11429,99,43951,99,66621,99,128844,67,71922,67,71913,67,65315,67,8557,67,8450,67,8493,67,119810,67,119862,67,119914,67,119966,67,120018,67,120174,67,120226,67,120278,67,120330,67,120382,67,120434,67,1017,67,11428,67,5087,67,42202,67,66210,67,66306,67,66581,67,66844,67,8574,100,8518,100,119837,100,119889,100,119941,100,119993,100,120045,100,120097,100,120149,100,120201,100,120253,100,120305,100,120357,100,120409,100,120461,100,1281,100,5095,100,5231,100,42194,100,8558,68,8517,68,119811,68,119863,68,119915,68,119967,68,120019,68,120071,68,120123,68,120175,68,120227,68,120279,68,120331,68,120383,68,120435,68,5024,68,5598,68,5610,68,42195,68,8494,101,65349,101,8495,101,8519,101,119838,101,119890,101,119942,101,120046,101,120098,101,120150,101,120202,101,120254,101,120306,101,120358,101,120410,101,120462,101,43826,101,1213,101,8959,69,65317,69,8496,69,119812,69,119864,69,119916,69,120020,69,120072,69,120124,69,120176,69,120228,69,120280,69,120332,69,120384,69,120436,69,917,69,120492,69,120550,69,120608,69,120666,69,120724,69,11577,69,5036,69,42224,69,71846,69,71854,69,66182,69,119839,102,119891,102,119943,102,119995,102,120047,102,120099,102,120151,102,120203,102,120255,102,120307,102,120359,102,120411,102,120463,102,43829,102,42905,102,383,102,7837,102,1412,102,119315,70,8497,70,119813,70,119865,70,119917,70,120021,70,120073,70,120125,70,120177,70,120229,70,120281,70,120333,70,120385,70,120437,70,42904,70,988,70,120778,70,5556,70,42205,70,71874,70,71842,70,66183,70,66213,70,66853,70,65351,103,8458,103,119840,103,119892,103,119944,103,120048,103,120100,103,120152,103,120204,103,120256,103,120308,103,120360,103,120412,103,120464,103,609,103,7555,103,397,103,1409,103,119814,71,119866,71,119918,71,119970,71,120022,71,120074,71,120126,71,120178,71,120230,71,120282,71,120334,71,120386,71,120438,71,1292,71,5056,71,5107,71,42198,71,65352,104,8462,104,119841,104,119945,104,119997,104,120049,104,120101,104,120153,104,120205,104,120257,104,120309,104,120361,104,120413,104,120465,104,1211,104,1392,104,5058,104,65320,72,8459,72,8460,72,8461,72,119815,72,119867,72,119919,72,120023,72,120179,72,120231,72,120283,72,120335,72,120387,72,120439,72,919,72,120494,72,120552,72,120610,72,120668,72,120726,72,11406,72,5051,72,5500,72,42215,72,66255,72,731,105,9075,105,65353,105,8560,105,8505,105,8520,105,119842,105,119894,105,119946,105,119998,105,120050,105,120102,105,120154,105,120206,105,120258,105,120310,105,120362,105,120414,105,120466,105,120484,105,618,105,617,105,953,105,8126,105,890,105,120522,105,120580,105,120638,105,120696,105,120754,105,1110,105,42567,105,1231,105,43893,105,5029,105,71875,105,65354,106,8521,106,119843,106,119895,106,119947,106,119999,106,120051,106,120103,106,120155,106,120207,106,120259,106,120311,106,120363,106,120415,106,120467,106,1011,106,1112,106,65322,74,119817,74,119869,74,119921,74,119973,74,120025,74,120077,74,120129,74,120181,74,120233,74,120285,74,120337,74,120389,74,120441,74,42930,74,895,74,1032,74,5035,74,5261,74,42201,74,119844,107,119896,107,119948,107,120000,107,120052,107,120104,107,120156,107,120208,107,120260,107,120312,107,120364,107,120416,107,120468,107,8490,75,65323,75,119818,75,119870,75,119922,75,119974,75,120026,75,120078,75,120130,75,120182,75,120234,75,120286,75,120338,75,120390,75,120442,75,922,75,120497,75,120555,75,120613,75,120671,75,120729,75,11412,75,5094,75,5845,75,42199,75,66840,75,1472,108,8739,73,9213,73,65512,73,1633,108,1777,73,66336,108,125127,108,120783,73,120793,73,120803,73,120813,73,120823,73,130033,73,65321,73,8544,73,8464,73,8465,73,119816,73,119868,73,119920,73,120024,73,120128,73,120180,73,120232,73,120284,73,120336,73,120388,73,120440,73,65356,108,8572,73,8467,108,119845,108,119897,108,119949,108,120001,108,120053,108,120105,73,120157,73,120209,73,120261,73,120313,73,120365,73,120417,73,120469,73,448,73,120496,73,120554,73,120612,73,120670,73,120728,73,11410,73,1030,73,1216,73,1493,108,1503,108,1575,108,126464,108,126592,108,65166,108,65165,108,1994,108,11599,73,5825,73,42226,73,93992,73,66186,124,66313,124,119338,76,8556,76,8466,76,119819,76,119871,76,119923,76,120027,76,120079,76,120131,76,120183,76,120235,76,120287,76,120339,76,120391,76,120443,76,11472,76,5086,76,5290,76,42209,76,93974,76,71843,76,71858,76,66587,76,66854,76,65325,77,8559,77,8499,77,119820,77,119872,77,119924,77,120028,77,120080,77,120132,77,120184,77,120236,77,120288,77,120340,77,120392,77,120444,77,924,77,120499,77,120557,77,120615,77,120673,77,120731,77,1018,77,11416,77,5047,77,5616,77,5846,77,42207,77,66224,77,66321,77,119847,110,119899,110,119951,110,120003,110,120055,110,120107,110,120159,110,120211,110,120263,110,120315,110,120367,110,120419,110,120471,110,1400,110,1404,110,65326,78,8469,78,119821,78,119873,78,119925,78,119977,78,120029,78,120081,78,120185,78,120237,78,120289,78,120341,78,120393,78,120445,78,925,78,120500,78,120558,78,120616,78,120674,78,120732,78,11418,78,42208,78,66835,78,3074,111,3202,111,3330,111,3458,111,2406,111,2662,111,2790,111,3046,111,3174,111,3302,111,3430,111,3664,111,3792,111,4160,111,1637,111,1781,111,65359,111,8500,111,119848,111,119900,111,119952,111,120056,111,120108,111,120160,111,120212,111,120264,111,120316,111,120368,111,120420,111,120472,111,7439,111,7441,111,43837,111,959,111,120528,111,120586,111,120644,111,120702,111,120760,111,963,111,120532,111,120590,111,120648,111,120706,111,120764,111,11423,111,4351,111,1413,111,1505,111,1607,111,126500,111,126564,111,126596,111,65259,111,65260,111,65258,111,65257,111,1726,111,64428,111,64429,111,64427,111,64426,111,1729,111,64424,111,64425,111,64423,111,64422,111,1749,111,3360,111,4125,111,66794,111,71880,111,71895,111,66604,111,1984,79,2534,79,2918,79,12295,79,70864,79,71904,79,120782,79,120792,79,120802,79,120812,79,120822,79,130032,79,65327,79,119822,79,119874,79,119926,79,119978,79,120030,79,120082,79,120134,79,120186,79,120238,79,120290,79,120342,79,120394,79,120446,79,927,79,120502,79,120560,79,120618,79,120676,79,120734,79,11422,79,1365,79,11604,79,4816,79,2848,79,66754,79,42227,79,71861,79,66194,79,66219,79,66564,79,66838,79,9076,112,65360,112,119849,112,119901,112,119953,112,120005,112,120057,112,120109,112,120161,112,120213,112,120265,112,120317,112,120369,112,120421,112,120473,112,961,112,120530,112,120544,112,120588,112,120602,112,120646,112,120660,112,120704,112,120718,112,120762,112,120776,112,11427,112,65328,80,8473,80,119823,80,119875,80,119927,80,119979,80,120031,80,120083,80,120187,80,120239,80,120291,80,120343,80,120395,80,120447,80,929,80,120504,80,120562,80,120620,80,120678,80,120736,80,11426,80,5090,80,5229,80,42193,80,66197,80,119850,113,119902,113,119954,113,120006,113,120058,113,120110,113,120162,113,120214,113,120266,113,120318,113,120370,113,120422,113,120474,113,1307,113,1379,113,1382,113,8474,81,119824,81,119876,81,119928,81,119980,81,120032,81,120084,81,120188,81,120240,81,120292,81,120344,81,120396,81,120448,81,11605,81,119851,114,119903,114,119955,114,120007,114,120059,114,120111,114,120163,114,120215,114,120267,114,120319,114,120371,114,120423,114,120475,114,43847,114,43848,114,7462,114,11397,114,43905,114,119318,82,8475,82,8476,82,8477,82,119825,82,119877,82,119929,82,120033,82,120189,82,120241,82,120293,82,120345,82,120397,82,120449,82,422,82,5025,82,5074,82,66740,82,5511,82,42211,82,94005,82,65363,115,119852,115,119904,115,119956,115,120008,115,120060,115,120112,115,120164,115,120216,115,120268,115,120320,115,120372,115,120424,115,120476,115,42801,115,445,115,1109,115,43946,115,71873,115,66632,115,65331,83,119826,83,119878,83,119930,83,119982,83,120034,83,120086,83,120138,83,120190,83,120242,83,120294,83,120346,83,120398,83,120450,83,1029,83,1359,83,5077,83,5082,83,42210,83,94010,83,66198,83,66592,83,119853,116,119905,116,119957,116,120009,116,120061,116,120113,116,120165,116,120217,116,120269,116,120321,116,120373,116,120425,116,120477,116,8868,84,10201,84,128872,84,65332,84,119827,84,119879,84,119931,84,119983,84,120035,84,120087,84,120139,84,120191,84,120243,84,120295,84,120347,84,120399,84,120451,84,932,84,120507,84,120565,84,120623,84,120681,84,120739,84,11430,84,5026,84,42196,84,93962,84,71868,84,66199,84,66225,84,66325,84,119854,117,119906,117,119958,117,120010,117,120062,117,120114,117,120166,117,120218,117,120270,117,120322,117,120374,117,120426,117,120478,117,42911,117,7452,117,43854,117,43858,117,651,117,965,117,120534,117,120592,117,120650,117,120708,117,120766,117,1405,117,66806,117,71896,117,8746,85,8899,85,119828,85,119880,85,119932,85,119984,85,120036,85,120088,85,120140,85,120192,85,120244,85,120296,85,120348,85,120400,85,120452,85,1357,85,4608,85,66766,85,5196,85,42228,85,94018,85,71864,85,8744,118,8897,118,65366,118,8564,118,119855,118,119907,118,119959,118,120011,118,120063,118,120115,118,120167,118,120219,118,120271,118,120323,118,120375,118,120427,118,120479,118,7456,118,957,118,120526,118,120584,118,120642,118,120700,118,120758,118,1141,118,1496,118,71430,118,43945,118,71872,118,119309,86,1639,86,1783,86,8548,86,119829,86,119881,86,119933,86,119985,86,120037,86,120089,86,120141,86,120193,86,120245,86,120297,86,120349,86,120401,86,120453,86,1140,86,11576,86,5081,86,5167,86,42719,86,42214,86,93960,86,71840,86,66845,86,623,119,119856,119,119908,119,119960,119,120012,119,120064,119,120116,119,120168,119,120220,119,120272,119,120324,119,120376,119,120428,119,120480,119,7457,119,1121,119,1309,119,1377,119,71434,119,71438,119,71439,119,43907,119,71919,87,71910,87,119830,87,119882,87,119934,87,119986,87,120038,87,120090,87,120142,87,120194,87,120246,87,120298,87,120350,87,120402,87,120454,87,1308,87,5043,87,5076,87,42218,87,5742,120,10539,120,10540,120,10799,120,65368,120,8569,120,119857,120,119909,120,119961,120,120013,120,120065,120,120117,120,120169,120,120221,120,120273,120,120325,120,120377,120,120429,120,120481,120,5441,120,5501,120,5741,88,9587,88,66338,88,71916,88,65336,88,8553,88,119831,88,119883,88,119935,88,119987,88,120039,88,120091,88,120143,88,120195,88,120247,88,120299,88,120351,88,120403,88,120455,88,42931,88,935,88,120510,88,120568,88,120626,88,120684,88,120742,88,11436,88,11613,88,5815,88,42219,88,66192,88,66228,88,66327,88,66855,88,611,121,7564,121,65369,121,119858,121,119910,121,119962,121,120014,121,120066,121,120118,121,120170,121,120222,121,120274,121,120326,121,120378,121,120430,121,120482,121,655,121,7935,121,43866,121,947,121,8509,121,120516,121,120574,121,120632,121,120690,121,120748,121,1199,121,4327,121,71900,121,65337,89,119832,89,119884,89,119936,89,119988,89,120040,89,120092,89,120144,89,120196,89,120248,89,120300,89,120352,89,120404,89,120456,89,933,89,978,89,120508,89,120566,89,120624,89,120682,89,120740,89,11432,89,1198,89,5033,89,5053,89,42220,89,94019,89,71844,89,66226,89,119859,122,119911,122,119963,122,120015,122,120067,122,120119,122,120171,122,120223,122,120275,122,120327,122,120379,122,120431,122,120483,122,7458,122,43923,122,71876,122,66293,90,71909,90,65338,90,8484,90,8488,90,119833,90,119885,90,119937,90,119989,90,120041,90,120197,90,120249,90,120301,90,120353,90,120405,90,120457,90,918,90,120493,90,120551,90,120609,90,120667,90,120725,90,5059,90,42204,90,71849,90,65282,34,65284,36,65285,37,65286,38,65290,42,65291,43,65294,46,65295,47,65296,48,65297,49,65298,50,65299,51,65300,52,65301,53,65302,54,65303,55,65304,56,65305,57,65308,60,65309,61,65310,62,65312,64,65316,68,65318,70,65319,71,65324,76,65329,81,65330,82,65333,85,65334,86,65335,87,65343,95,65346,98,65348,100,65350,102,65355,107,65357,109,65358,110,65361,113,65362,114,65364,116,65365,117,65367,119,65370,122,65371,123,65373,125],\"_default\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"cs\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"de\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"es\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"fr\":[65374,126,65306,58,65281,33,8216,96,8245,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"it\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ja\":[8211,45,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65292,44,65307,59],\"ko\":[8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pl\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"pt-BR\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"qps-ploc\":[160,32,8211,45,65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"ru\":[65374,126,65306,58,65281,33,8216,96,8217,96,8245,96,180,96,12494,47,305,105,921,73,1009,112,215,120,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"tr\":[160,32,8211,45,65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65288,40,65289,41,65292,44,65307,59,65311,63],\"zh-hans\":[65374,126,65306,58,65281,33,8245,96,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65288,40,65289,41],\"zh-hant\":[8211,45,65374,126,180,96,12494,47,1047,51,1073,54,1072,97,1040,65,1068,98,1042,66,1089,99,1057,67,1077,101,1045,69,1053,72,305,105,1050,75,921,73,1052,77,1086,111,1054,79,1009,112,1088,112,1056,80,1075,114,1058,84,215,120,1093,120,1061,88,1091,121,1059,89,65283,35,65307,59]}");
});
AmbiguousCharacters.cache = new LRUCachedComputed((locales) => {
	function arrayToMap(arr) {
		const result = /* @__PURE__ */ new Map();
		for (let i = 0; i < arr.length; i += 2) result.set(arr[i], arr[i + 1]);
		return result;
	}
	function mergeMaps(map1, map2) {
		const result = new Map(map1);
		for (const [key, value] of map2) result.set(key, value);
		return result;
	}
	function intersectMaps(map1, map2) {
		if (!map1) return map2;
		const result = /* @__PURE__ */ new Map();
		for (const [key, value] of map1) if (map2.has(key)) result.set(key, value);
		return result;
	}
	const data = _a$1.ambiguousCharacterData.getValue();
	let filteredLocales = locales.filter((l) => !l.startsWith("_") && l in data);
	if (filteredLocales.length === 0) filteredLocales = ["_default"];
	let languageSpecificMap = void 0;
	for (const locale of filteredLocales) {
		const map = arrayToMap(data[locale]);
		languageSpecificMap = intersectMaps(languageSpecificMap, map);
	}
	return new AmbiguousCharacters(mergeMaps(arrayToMap(data["_common"]), languageSpecificMap));
});
AmbiguousCharacters._locales = new Lazy(() => Object.keys(AmbiguousCharacters.ambiguousCharacterData.getValue()).filter((k) => !k.startsWith("_")));
var InvisibleCharacters = class InvisibleCharacters {
	static getRawData() {
		return JSON.parse("[9,10,11,12,13,32,127,160,173,847,1564,4447,4448,6068,6069,6155,6156,6157,6158,7355,7356,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8203,8204,8205,8206,8207,8234,8235,8236,8237,8238,8239,8287,8288,8289,8290,8291,8292,8293,8294,8295,8296,8297,8298,8299,8300,8301,8302,8303,10240,12288,12644,65024,65025,65026,65027,65028,65029,65030,65031,65032,65033,65034,65035,65036,65037,65038,65039,65279,65440,65520,65521,65522,65523,65524,65525,65526,65527,65528,65532,78844,119155,119156,119157,119158,119159,119160,119161,119162,917504,917505,917506,917507,917508,917509,917510,917511,917512,917513,917514,917515,917516,917517,917518,917519,917520,917521,917522,917523,917524,917525,917526,917527,917528,917529,917530,917531,917532,917533,917534,917535,917536,917537,917538,917539,917540,917541,917542,917543,917544,917545,917546,917547,917548,917549,917550,917551,917552,917553,917554,917555,917556,917557,917558,917559,917560,917561,917562,917563,917564,917565,917566,917567,917568,917569,917570,917571,917572,917573,917574,917575,917576,917577,917578,917579,917580,917581,917582,917583,917584,917585,917586,917587,917588,917589,917590,917591,917592,917593,917594,917595,917596,917597,917598,917599,917600,917601,917602,917603,917604,917605,917606,917607,917608,917609,917610,917611,917612,917613,917614,917615,917616,917617,917618,917619,917620,917621,917622,917623,917624,917625,917626,917627,917628,917629,917630,917631,917760,917761,917762,917763,917764,917765,917766,917767,917768,917769,917770,917771,917772,917773,917774,917775,917776,917777,917778,917779,917780,917781,917782,917783,917784,917785,917786,917787,917788,917789,917790,917791,917792,917793,917794,917795,917796,917797,917798,917799,917800,917801,917802,917803,917804,917805,917806,917807,917808,917809,917810,917811,917812,917813,917814,917815,917816,917817,917818,917819,917820,917821,917822,917823,917824,917825,917826,917827,917828,917829,917830,917831,917832,917833,917834,917835,917836,917837,917838,917839,917840,917841,917842,917843,917844,917845,917846,917847,917848,917849,917850,917851,917852,917853,917854,917855,917856,917857,917858,917859,917860,917861,917862,917863,917864,917865,917866,917867,917868,917869,917870,917871,917872,917873,917874,917875,917876,917877,917878,917879,917880,917881,917882,917883,917884,917885,917886,917887,917888,917889,917890,917891,917892,917893,917894,917895,917896,917897,917898,917899,917900,917901,917902,917903,917904,917905,917906,917907,917908,917909,917910,917911,917912,917913,917914,917915,917916,917917,917918,917919,917920,917921,917922,917923,917924,917925,917926,917927,917928,917929,917930,917931,917932,917933,917934,917935,917936,917937,917938,917939,917940,917941,917942,917943,917944,917945,917946,917947,917948,917949,917950,917951,917952,917953,917954,917955,917956,917957,917958,917959,917960,917961,917962,917963,917964,917965,917966,917967,917968,917969,917970,917971,917972,917973,917974,917975,917976,917977,917978,917979,917980,917981,917982,917983,917984,917985,917986,917987,917988,917989,917990,917991,917992,917993,917994,917995,917996,917997,917998,917999]");
	}
	static getData() {
		if (!this._data) this._data = new Set(InvisibleCharacters.getRawData());
		return this._data;
	}
	static isInvisibleCharacter(codePoint) {
		return InvisibleCharacters.getData().has(codePoint);
	}
	static get codePoints() {
		return InvisibleCharacters.getData();
	}
};
InvisibleCharacters._data = void 0;

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js
/**
* A column in a position is the gap between two adjacent characters. The methods here
* work with a concept called "visible column". A visible column is a very rough approximation
* of the horizontal screen position of a column. For example, using a tab size of 4:
* ```txt
* |<TAB>|<TAB>|T|ext
* |     |     | \---- column = 4, visible column = 9
* |     |     \------ column = 3, visible column = 8
* |     \------------ column = 2, visible column = 4
* \------------------ column = 1, visible column = 0
* ```
*
* **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.
*
* **NOTE**: These methods work and make sense both on the model and on the view model.
*/
var CursorColumns = class CursorColumns {
	static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {
		if (codePoint === 9) return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);
		if (isFullWidthCharacter(codePoint) || isEmojiImprecise(codePoint)) return visibleColumn + 2;
		return visibleColumn + 1;
	}
	/**
	* Returns a visible column from a column.
	* @see {@link CursorColumns}
	*/
	static visibleColumnFromColumn(lineContent, column, tabSize) {
		const textLen = Math.min(column - 1, lineContent.length);
		const text = lineContent.substring(0, textLen);
		const iterator = new GraphemeIterator(text);
		let result = 0;
		while (!iterator.eol()) {
			const codePoint = getNextCodePoint(text, textLen, iterator.offset);
			iterator.nextGraphemeLength();
			result = this._nextVisibleColumn(codePoint, result, tabSize);
		}
		return result;
	}
	/**
	* Returns a column from a visible column.
	* @see {@link CursorColumns}
	*/
	static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {
		if (visibleColumn <= 0) return 1;
		const lineContentLength = lineContent.length;
		const iterator = new GraphemeIterator(lineContent);
		let beforeVisibleColumn = 0;
		let beforeColumn = 1;
		while (!iterator.eol()) {
			const codePoint = getNextCodePoint(lineContent, lineContentLength, iterator.offset);
			iterator.nextGraphemeLength();
			const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);
			const afterColumn = iterator.offset + 1;
			if (afterVisibleColumn >= visibleColumn) {
				const beforeDelta = visibleColumn - beforeVisibleColumn;
				if (afterVisibleColumn - visibleColumn < beforeDelta) return afterColumn;
				else return beforeColumn;
			}
			beforeVisibleColumn = afterVisibleColumn;
			beforeColumn = afterColumn;
		}
		return lineContentLength + 1;
	}
	/**
	* ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
	* @see {@link CursorColumns}
	*/
	static nextRenderTabStop(visibleColumn, tabSize) {
		return visibleColumn + tabSize - visibleColumn % tabSize;
	}
	/**
	* ATTENTION: This works with 0-based columns (as oposed to the regular 1-based columns)
	* @see {@link CursorColumns}
	*/
	static nextIndentTabStop(visibleColumn, indentSize) {
		return visibleColumn + indentSize - visibleColumn % indentSize;
	}
	/**
	* ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
	* @see {@link CursorColumns}
	*/
	static prevRenderTabStop(column, tabSize) {
		return Math.max(0, column - 1 - (column - 1) % tabSize);
	}
	/**
	* ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)
	* @see {@link CursorColumns}
	*/
	static prevIndentTabStop(column, indentSize) {
		return Math.max(0, column - 1 - (column - 1) % indentSize);
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/position.js
/**
* A position in the editor.
*/
var Position$1 = class Position$1 {
	constructor(lineNumber, column) {
		this.lineNumber = lineNumber;
		this.column = column;
	}
	/**
	* Create a new position from this position.
	*
	* @param newLineNumber new line number
	* @param newColumn new column
	*/
	with(newLineNumber = this.lineNumber, newColumn = this.column) {
		if (newLineNumber === this.lineNumber && newColumn === this.column) return this;
		else return new Position$1(newLineNumber, newColumn);
	}
	/**
	* Derive a new position from this position.
	*
	* @param deltaLineNumber line number delta
	* @param deltaColumn column delta
	*/
	delta(deltaLineNumber = 0, deltaColumn = 0) {
		return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
	}
	/**
	* Test if this position equals other position
	*/
	equals(other) {
		return Position$1.equals(this, other);
	}
	/**
	* Test if position `a` equals position `b`
	*/
	static equals(a, b) {
		if (!a && !b) return true;
		return !!a && !!b && a.lineNumber === b.lineNumber && a.column === b.column;
	}
	/**
	* Test if this position is before other position.
	* If the two positions are equal, the result will be false.
	*/
	isBefore(other) {
		return Position$1.isBefore(this, other);
	}
	/**
	* Test if position `a` is before position `b`.
	* If the two positions are equal, the result will be false.
	*/
	static isBefore(a, b) {
		if (a.lineNumber < b.lineNumber) return true;
		if (b.lineNumber < a.lineNumber) return false;
		return a.column < b.column;
	}
	/**
	* Test if this position is before other position.
	* If the two positions are equal, the result will be true.
	*/
	isBeforeOrEqual(other) {
		return Position$1.isBeforeOrEqual(this, other);
	}
	/**
	* Test if position `a` is before position `b`.
	* If the two positions are equal, the result will be true.
	*/
	static isBeforeOrEqual(a, b) {
		if (a.lineNumber < b.lineNumber) return true;
		if (b.lineNumber < a.lineNumber) return false;
		return a.column <= b.column;
	}
	/**
	* A function that compares positions, useful for sorting
	*/
	static compare(a, b) {
		const aLineNumber = a.lineNumber | 0;
		const bLineNumber = b.lineNumber | 0;
		if (aLineNumber === bLineNumber) return (a.column | 0) - (b.column | 0);
		return aLineNumber - bLineNumber;
	}
	/**
	* Clone this position.
	*/
	clone() {
		return new Position$1(this.lineNumber, this.column);
	}
	/**
	* Convert to a human-readable representation.
	*/
	toString() {
		return "(" + this.lineNumber + "," + this.column + ")";
	}
	/**
	* Create a `Position` from an `IPosition`.
	*/
	static lift(pos) {
		return new Position$1(pos.lineNumber, pos.column);
	}
	/**
	* Test if `obj` is an `IPosition`.
	*/
	static isIPosition(obj) {
		return obj && typeof obj.lineNumber === "number" && typeof obj.column === "number";
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/range.js
/**
* A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
*/
var Range$1 = class Range$1 {
	constructor(startLineNumber, startColumn, endLineNumber, endColumn) {
		if (startLineNumber > endLineNumber || startLineNumber === endLineNumber && startColumn > endColumn) {
			this.startLineNumber = endLineNumber;
			this.startColumn = endColumn;
			this.endLineNumber = startLineNumber;
			this.endColumn = startColumn;
		} else {
			this.startLineNumber = startLineNumber;
			this.startColumn = startColumn;
			this.endLineNumber = endLineNumber;
			this.endColumn = endColumn;
		}
	}
	/**
	* Test if this range is empty.
	*/
	isEmpty() {
		return Range$1.isEmpty(this);
	}
	/**
	* Test if `range` is empty.
	*/
	static isEmpty(range) {
		return range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn;
	}
	/**
	* Test if position is in this range. If the position is at the edges, will return true.
	*/
	containsPosition(position) {
		return Range$1.containsPosition(this, position);
	}
	/**
	* Test if `position` is in `range`. If the position is at the edges, will return true.
	*/
	static containsPosition(range, position) {
		if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) return false;
		if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) return false;
		if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) return false;
		return true;
	}
	/**
	* Test if `position` is in `range`. If the position is at the edges, will return false.
	* @internal
	*/
	static strictContainsPosition(range, position) {
		if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) return false;
		if (position.lineNumber === range.startLineNumber && position.column <= range.startColumn) return false;
		if (position.lineNumber === range.endLineNumber && position.column >= range.endColumn) return false;
		return true;
	}
	/**
	* Test if range is in this range. If the range is equal to this range, will return true.
	*/
	containsRange(range) {
		return Range$1.containsRange(this, range);
	}
	/**
	* Test if `otherRange` is in `range`. If the ranges are equal, will return true.
	*/
	static containsRange(range, otherRange) {
		if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) return false;
		if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) return false;
		if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) return false;
		if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) return false;
		return true;
	}
	/**
	* Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
	*/
	strictContainsRange(range) {
		return Range$1.strictContainsRange(this, range);
	}
	/**
	* Test if `otherRange` is strictly in `range` (must start after, and end before). If the ranges are equal, will return false.
	*/
	static strictContainsRange(range, otherRange) {
		if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) return false;
		if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) return false;
		if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) return false;
		if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) return false;
		return true;
	}
	/**
	* A reunion of the two ranges.
	* The smallest position will be used as the start point, and the largest one as the end point.
	*/
	plusRange(range) {
		return Range$1.plusRange(this, range);
	}
	/**
	* A reunion of the two ranges.
	* The smallest position will be used as the start point, and the largest one as the end point.
	*/
	static plusRange(a, b) {
		let startLineNumber;
		let startColumn;
		let endLineNumber;
		let endColumn;
		if (b.startLineNumber < a.startLineNumber) {
			startLineNumber = b.startLineNumber;
			startColumn = b.startColumn;
		} else if (b.startLineNumber === a.startLineNumber) {
			startLineNumber = b.startLineNumber;
			startColumn = Math.min(b.startColumn, a.startColumn);
		} else {
			startLineNumber = a.startLineNumber;
			startColumn = a.startColumn;
		}
		if (b.endLineNumber > a.endLineNumber) {
			endLineNumber = b.endLineNumber;
			endColumn = b.endColumn;
		} else if (b.endLineNumber === a.endLineNumber) {
			endLineNumber = b.endLineNumber;
			endColumn = Math.max(b.endColumn, a.endColumn);
		} else {
			endLineNumber = a.endLineNumber;
			endColumn = a.endColumn;
		}
		return new Range$1(startLineNumber, startColumn, endLineNumber, endColumn);
	}
	/**
	* A intersection of the two ranges.
	*/
	intersectRanges(range) {
		return Range$1.intersectRanges(this, range);
	}
	/**
	* A intersection of the two ranges.
	*/
	static intersectRanges(a, b) {
		let resultStartLineNumber = a.startLineNumber;
		let resultStartColumn = a.startColumn;
		let resultEndLineNumber = a.endLineNumber;
		let resultEndColumn = a.endColumn;
		let otherStartLineNumber = b.startLineNumber;
		let otherStartColumn = b.startColumn;
		let otherEndLineNumber = b.endLineNumber;
		let otherEndColumn = b.endColumn;
		if (resultStartLineNumber < otherStartLineNumber) {
			resultStartLineNumber = otherStartLineNumber;
			resultStartColumn = otherStartColumn;
		} else if (resultStartLineNumber === otherStartLineNumber) resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
		if (resultEndLineNumber > otherEndLineNumber) {
			resultEndLineNumber = otherEndLineNumber;
			resultEndColumn = otherEndColumn;
		} else if (resultEndLineNumber === otherEndLineNumber) resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
		if (resultStartLineNumber > resultEndLineNumber) return null;
		if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) return null;
		return new Range$1(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
	}
	/**
	* Test if this range equals other.
	*/
	equalsRange(other) {
		return Range$1.equalsRange(this, other);
	}
	/**
	* Test if range `a` equals `b`.
	*/
	static equalsRange(a, b) {
		return !!a && !!b && a.startLineNumber === b.startLineNumber && a.startColumn === b.startColumn && a.endLineNumber === b.endLineNumber && a.endColumn === b.endColumn;
	}
	/**
	* Return the end position (which will be after or equal to the start position)
	*/
	getEndPosition() {
		return Range$1.getEndPosition(this);
	}
	/**
	* Return the end position (which will be after or equal to the start position)
	*/
	static getEndPosition(range) {
		return new Position$1(range.endLineNumber, range.endColumn);
	}
	/**
	* Return the start position (which will be before or equal to the end position)
	*/
	getStartPosition() {
		return Range$1.getStartPosition(this);
	}
	/**
	* Return the start position (which will be before or equal to the end position)
	*/
	static getStartPosition(range) {
		return new Position$1(range.startLineNumber, range.startColumn);
	}
	/**
	* Transform to a user presentable string representation.
	*/
	toString() {
		return "[" + this.startLineNumber + "," + this.startColumn + " -> " + this.endLineNumber + "," + this.endColumn + "]";
	}
	/**
	* Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
	*/
	setEndPosition(endLineNumber, endColumn) {
		return new Range$1(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
	}
	/**
	* Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
	*/
	setStartPosition(startLineNumber, startColumn) {
		return new Range$1(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
	}
	/**
	* Create a new empty range using this range's start position.
	*/
	collapseToStart() {
		return Range$1.collapseToStart(this);
	}
	/**
	* Create a new empty range using this range's start position.
	*/
	static collapseToStart(range) {
		return new Range$1(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
	}
	static fromPositions(start, end = start) {
		return new Range$1(start.lineNumber, start.column, end.lineNumber, end.column);
	}
	static lift(range) {
		if (!range) return null;
		return new Range$1(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
	}
	/**
	* Test if `obj` is an `IRange`.
	*/
	static isIRange(obj) {
		return obj && typeof obj.startLineNumber === "number" && typeof obj.startColumn === "number" && typeof obj.endLineNumber === "number" && typeof obj.endColumn === "number";
	}
	/**
	* Test if the two ranges are touching in any way.
	*/
	static areIntersectingOrTouching(a, b) {
		if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn) return false;
		if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn) return false;
		return true;
	}
	/**
	* Test if the two ranges are intersecting. If the ranges are touching it returns true.
	*/
	static areIntersecting(a, b) {
		if (a.endLineNumber < b.startLineNumber || a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn) return false;
		if (b.endLineNumber < a.startLineNumber || b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn) return false;
		return true;
	}
	/**
	* A function that compares ranges, useful for sorting ranges
	* It will first compare ranges on the startPosition and then on the endPosition
	*/
	static compareRangesUsingStarts(a, b) {
		if (a && b) {
			const aStartLineNumber = a.startLineNumber | 0;
			const bStartLineNumber = b.startLineNumber | 0;
			if (aStartLineNumber === bStartLineNumber) {
				const aStartColumn = a.startColumn | 0;
				const bStartColumn = b.startColumn | 0;
				if (aStartColumn === bStartColumn) {
					const aEndLineNumber = a.endLineNumber | 0;
					const bEndLineNumber = b.endLineNumber | 0;
					if (aEndLineNumber === bEndLineNumber) return (a.endColumn | 0) - (b.endColumn | 0);
					return aEndLineNumber - bEndLineNumber;
				}
				return aStartColumn - bStartColumn;
			}
			return aStartLineNumber - bStartLineNumber;
		}
		return (a ? 1 : 0) - (b ? 1 : 0);
	}
	/**
	* A function that compares ranges, useful for sorting ranges
	* It will first compare ranges on the endPosition and then on the startPosition
	*/
	static compareRangesUsingEnds(a, b) {
		if (a.endLineNumber === b.endLineNumber) {
			if (a.endColumn === b.endColumn) {
				if (a.startLineNumber === b.startLineNumber) return a.startColumn - b.startColumn;
				return a.startLineNumber - b.startLineNumber;
			}
			return a.endColumn - b.endColumn;
		}
		return a.endLineNumber - b.endLineNumber;
	}
	/**
	* Test if the range spans multiple lines.
	*/
	static spansMultipleLines(range) {
		return range.endLineNumber > range.startLineNumber;
	}
	toJSON() {
		return this;
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
/**
* A selection in the editor.
* The selection is a range that has an orientation.
*/
var Selection$1 = class Selection$1 extends Range$1 {
	constructor(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
		super(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn);
		this.selectionStartLineNumber = selectionStartLineNumber;
		this.selectionStartColumn = selectionStartColumn;
		this.positionLineNumber = positionLineNumber;
		this.positionColumn = positionColumn;
	}
	/**
	* Transform to a human-readable representation.
	*/
	toString() {
		return "[" + this.selectionStartLineNumber + "," + this.selectionStartColumn + " -> " + this.positionLineNumber + "," + this.positionColumn + "]";
	}
	/**
	* Test if equals other selection.
	*/
	equalsSelection(other) {
		return Selection$1.selectionsEqual(this, other);
	}
	/**
	* Test if the two selections are equal.
	*/
	static selectionsEqual(a, b) {
		return a.selectionStartLineNumber === b.selectionStartLineNumber && a.selectionStartColumn === b.selectionStartColumn && a.positionLineNumber === b.positionLineNumber && a.positionColumn === b.positionColumn;
	}
	/**
	* Get directions (LTR or RTL).
	*/
	getDirection() {
		if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) return 0;
		return 1;
	}
	/**
	* Create a new selection with a different `positionLineNumber` and `positionColumn`.
	*/
	setEndPosition(endLineNumber, endColumn) {
		if (this.getDirection() === 0) return new Selection$1(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
		return new Selection$1(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
	}
	/**
	* Get the position at `positionLineNumber` and `positionColumn`.
	*/
	getPosition() {
		return new Position$1(this.positionLineNumber, this.positionColumn);
	}
	/**
	* Get the position at the start of the selection.
	*/
	getSelectionStart() {
		return new Position$1(this.selectionStartLineNumber, this.selectionStartColumn);
	}
	/**
	* Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
	*/
	setStartPosition(startLineNumber, startColumn) {
		if (this.getDirection() === 0) return new Selection$1(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
		return new Selection$1(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
	}
	/**
	* Create a `Selection` from one or two positions
	*/
	static fromPositions(start, end = start) {
		return new Selection$1(start.lineNumber, start.column, end.lineNumber, end.column);
	}
	/**
	* Creates a `Selection` from a range, given a direction.
	*/
	static fromRange(range, direction) {
		if (direction === 0) return new Selection$1(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
		else return new Selection$1(range.endLineNumber, range.endColumn, range.startLineNumber, range.startColumn);
	}
	/**
	* Create a `Selection` from an `ISelection`.
	*/
	static liftSelection(sel) {
		return new Selection$1(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
	}
	/**
	* `a` equals `b`.
	*/
	static selectionsArrEqual(a, b) {
		if (a && !b || !a && b) return false;
		if (!a && !b) return true;
		if (a.length !== b.length) return false;
		for (let i = 0, len = a.length; i < len; i++) if (!this.selectionsEqual(a[i], b[i])) return false;
		return true;
	}
	/**
	* Test if `obj` is an `ISelection`.
	*/
	static isISelection(obj) {
		return obj && typeof obj.selectionStartLineNumber === "number" && typeof obj.selectionStartColumn === "number" && typeof obj.positionLineNumber === "number" && typeof obj.positionColumn === "number";
	}
	/**
	* Create with a direction.
	*/
	static createWithDirection(startLineNumber, startColumn, endLineNumber, endColumn, direction) {
		if (direction === 0) return new Selection$1(startLineNumber, startColumn, endLineNumber, endColumn);
		return new Selection$1(endLineNumber, endColumn, startLineNumber, startColumn);
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/errors.js
var ErrorHandler = class {
	constructor() {
		this.listeners = [];
		this.unexpectedErrorHandler = function(e) {
			setTimeout(() => {
				if (e.stack) throw new Error(e.message + "\n\n" + e.stack);
				throw e;
			}, 0);
		};
	}
	emit(e) {
		this.listeners.forEach((listener) => {
			listener(e);
		});
	}
	onUnexpectedError(e) {
		this.unexpectedErrorHandler(e);
		this.emit(e);
	}
	onUnexpectedExternalError(e) {
		this.unexpectedErrorHandler(e);
	}
};
const errorHandler = new ErrorHandler();
function onUnexpectedError(e) {
	if (!isCancellationError(e)) errorHandler.onUnexpectedError(e);
}
const canceledName = "Canceled";
/**
* Checks if the given error is a promise in canceled state
*/
function isCancellationError(error) {
	if (error instanceof CancellationError) return true;
	return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
var CancellationError = class extends Error {
	constructor() {
		super(canceledName);
		this.name = this.message;
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/functional.js
function once(fn) {
	const _this = this;
	let didCall = false;
	let result;
	return function() {
		if (didCall) return result;
		didCall = true;
		result = fn.apply(_this, arguments);
		return result;
	};
}

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/iterator.js
var Iterable;
(function(Iterable$1) {
	function is(thing) {
		return thing && typeof thing === "object" && typeof thing[Symbol.iterator] === "function";
	}
	Iterable$1.is = is;
	const _empty = Object.freeze([]);
	function empty() {
		return _empty;
	}
	Iterable$1.empty = empty;
	function* single(element) {
		yield element;
	}
	Iterable$1.single = single;
	function from(iterable) {
		return iterable || _empty;
	}
	Iterable$1.from = from;
	function isEmpty(iterable) {
		return !iterable || iterable[Symbol.iterator]().next().done === true;
	}
	Iterable$1.isEmpty = isEmpty;
	function first(iterable) {
		return iterable[Symbol.iterator]().next().value;
	}
	Iterable$1.first = first;
	function some(iterable, predicate) {
		for (const element of iterable) if (predicate(element)) return true;
		return false;
	}
	Iterable$1.some = some;
	function find(iterable, predicate) {
		for (const element of iterable) if (predicate(element)) return element;
	}
	Iterable$1.find = find;
	function* filter(iterable, predicate) {
		for (const element of iterable) if (predicate(element)) yield element;
	}
	Iterable$1.filter = filter;
	function* map(iterable, fn) {
		let index = 0;
		for (const element of iterable) yield fn(element, index++);
	}
	Iterable$1.map = map;
	function* concat(...iterables) {
		for (const iterable of iterables) for (const element of iterable) yield element;
	}
	Iterable$1.concat = concat;
	function* concatNested(iterables) {
		for (const iterable of iterables) for (const element of iterable) yield element;
	}
	Iterable$1.concatNested = concatNested;
	function reduce(iterable, reducer, initialValue) {
		let value = initialValue;
		for (const element of iterable) value = reducer(value, element);
		return value;
	}
	Iterable$1.reduce = reduce;
	/**
	* Returns an iterable slice of the array, with the same semantics as `array.slice()`.
	*/
	function* slice(arr, from$1, to = arr.length) {
		if (from$1 < 0) from$1 += arr.length;
		if (to < 0) to += arr.length;
		else if (to > arr.length) to = arr.length;
		for (; from$1 < to; from$1++) yield arr[from$1];
	}
	Iterable$1.slice = slice;
	/**
	* Consumes `atMost` elements from iterable and returns the consumed elements,
	* and an iterable for the rest of the elements.
	*/
	function consume(iterable, atMost = Number.POSITIVE_INFINITY) {
		const consumed = [];
		if (atMost === 0) return [consumed, iterable];
		const iterator = iterable[Symbol.iterator]();
		for (let i = 0; i < atMost; i++) {
			const next = iterator.next();
			if (next.done) return [consumed, Iterable$1.empty()];
			consumed.push(next.value);
		}
		return [consumed, { [Symbol.iterator]() {
			return iterator;
		} }];
	}
	Iterable$1.consume = consume;
	/**
	* Returns whether the iterables are the same length and all items are
	* equal using the comparator function.
	*/
	function equals(a, b, comparator = (at, bt) => at === bt) {
		const ai = a[Symbol.iterator]();
		const bi = b[Symbol.iterator]();
		while (true) {
			const an = ai.next();
			const bn = bi.next();
			if (an.done !== bn.done) return false;
			else if (an.done) return true;
			else if (!comparator(an.value, bn.value)) return false;
		}
	}
	Iterable$1.equals = equals;
})(Iterable || (Iterable = {}));

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
let disposableTracker = null;
function trackDisposable(x) {
	disposableTracker === null || disposableTracker === void 0 || disposableTracker.trackDisposable(x);
	return x;
}
function markAsDisposed(disposable) {
	disposableTracker === null || disposableTracker === void 0 || disposableTracker.markAsDisposed(disposable);
}
function setParentOfDisposable(child, parent) {
	disposableTracker === null || disposableTracker === void 0 || disposableTracker.setParent(child, parent);
}
function setParentOfDisposables(children, parent) {
	if (!disposableTracker) return;
	for (const child of children) disposableTracker.setParent(child, parent);
}
var MultiDisposeError = class extends Error {
	constructor(errors) {
		super(`Encountered errors while disposing of store. Errors: [${errors.join(", ")}]`);
		this.errors = errors;
	}
};
function dispose(arg) {
	if (Iterable.is(arg)) {
		let errors = [];
		for (const d of arg) if (d) try {
			d.dispose();
		} catch (e) {
			errors.push(e);
		}
		if (errors.length === 1) throw errors[0];
		else if (errors.length > 1) throw new MultiDisposeError(errors);
		return Array.isArray(arg) ? [] : arg;
	} else if (arg) {
		arg.dispose();
		return arg;
	}
}
function combinedDisposable(...disposables) {
	const parent = toDisposable(() => dispose(disposables));
	setParentOfDisposables(disposables, parent);
	return parent;
}
function toDisposable(fn) {
	const self$1 = trackDisposable({ dispose: once(() => {
		markAsDisposed(self$1);
		fn();
	}) });
	return self$1;
}
var DisposableStore = class DisposableStore {
	constructor() {
		this._toDispose = /* @__PURE__ */ new Set();
		this._isDisposed = false;
		trackDisposable(this);
	}
	/**
	* Dispose of all registered disposables and mark this object as disposed.
	*
	* Any future disposables added to this object will be disposed of on `add`.
	*/
	dispose() {
		if (this._isDisposed) return;
		markAsDisposed(this);
		this._isDisposed = true;
		this.clear();
	}
	/**
	* Returns `true` if this object has been disposed
	*/
	get isDisposed() {
		return this._isDisposed;
	}
	/**
	* Dispose of all registered disposables but do not mark this object as disposed.
	*/
	clear() {
		try {
			dispose(this._toDispose.values());
		} finally {
			this._toDispose.clear();
		}
	}
	add(o) {
		if (!o) return o;
		if (o === this) throw new Error("Cannot register a disposable on itself!");
		setParentOfDisposable(o, this);
		if (this._isDisposed) {
			if (!DisposableStore.DISABLE_DISPOSED_WARNING) console.warn((/* @__PURE__ */ new Error("Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!")).stack);
		} else this._toDispose.add(o);
		return o;
	}
};
DisposableStore.DISABLE_DISPOSED_WARNING = false;
var Disposable = class {
	constructor() {
		this._store = new DisposableStore();
		trackDisposable(this);
		setParentOfDisposable(this._store, this);
	}
	dispose() {
		markAsDisposed(this);
		this._store.dispose();
	}
	_register(o) {
		if (o === this) throw new Error("Cannot register a disposable on itself!");
		return this._store.add(o);
	}
};
Disposable.None = Object.freeze({ dispose() {} });
/**
* A safe disposable can be `unset` so that a leaked reference (listener)
* can be cut-off.
*/
var SafeDisposable = class {
	constructor() {
		this.dispose = () => {};
		this.unset = () => {};
		this.isset = () => false;
		trackDisposable(this);
	}
	set(fn) {
		let callback = fn;
		this.unset = () => callback = void 0;
		this.isset = () => callback !== void 0;
		this.dispose = () => {
			if (callback) {
				callback();
				callback = void 0;
				markAsDisposed(this);
			}
		};
		return this;
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/linkedList.js
var Node = class Node {
	constructor(element) {
		this.element = element;
		this.next = Node.Undefined;
		this.prev = Node.Undefined;
	}
};
Node.Undefined = new Node(void 0);
var LinkedList = class {
	constructor() {
		this._first = Node.Undefined;
		this._last = Node.Undefined;
		this._size = 0;
	}
	get size() {
		return this._size;
	}
	isEmpty() {
		return this._first === Node.Undefined;
	}
	clear() {
		let node = this._first;
		while (node !== Node.Undefined) {
			const next = node.next;
			node.prev = Node.Undefined;
			node.next = Node.Undefined;
			node = next;
		}
		this._first = Node.Undefined;
		this._last = Node.Undefined;
		this._size = 0;
	}
	unshift(element) {
		return this._insert(element, false);
	}
	push(element) {
		return this._insert(element, true);
	}
	_insert(element, atTheEnd) {
		const newNode = new Node(element);
		if (this._first === Node.Undefined) {
			this._first = newNode;
			this._last = newNode;
		} else if (atTheEnd) {
			const oldLast = this._last;
			this._last = newNode;
			newNode.prev = oldLast;
			oldLast.next = newNode;
		} else {
			const oldFirst = this._first;
			this._first = newNode;
			newNode.next = oldFirst;
			oldFirst.prev = newNode;
		}
		this._size += 1;
		let didRemove = false;
		return () => {
			if (!didRemove) {
				didRemove = true;
				this._remove(newNode);
			}
		};
	}
	shift() {
		if (this._first === Node.Undefined) return;
		else {
			const res = this._first.element;
			this._remove(this._first);
			return res;
		}
	}
	pop() {
		if (this._last === Node.Undefined) return;
		else {
			const res = this._last.element;
			this._remove(this._last);
			return res;
		}
	}
	_remove(node) {
		if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
			const anchor = node.prev;
			anchor.next = node.next;
			node.next.prev = anchor;
		} else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
			this._first = Node.Undefined;
			this._last = Node.Undefined;
		} else if (node.next === Node.Undefined) {
			this._last = this._last.prev;
			this._last.next = Node.Undefined;
		} else if (node.prev === Node.Undefined) {
			this._first = this._first.next;
			this._first.prev = Node.Undefined;
		}
		this._size -= 1;
	}
	*[Symbol.iterator]() {
		let node = this._first;
		while (node !== Node.Undefined) {
			yield node.element;
			node = node.next;
		}
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/platform.js
var _a;
const LANGUAGE_DEFAULT = "en";
let _isWindows = false;
let _isMacintosh = false;
let _isLinux = false;
let _isNative = false;
let _isWeb = false;
let _isIOS = false;
let _locale = void 0;
let _language = LANGUAGE_DEFAULT;
let _userAgent = void 0;
const globals = typeof self === "object" ? self : typeof global === "object" ? global : {};
let nodeProcess = void 0;
if (typeof globals.vscode !== "undefined" && typeof globals.vscode.process !== "undefined") nodeProcess = globals.vscode.process;
else if (typeof process !== "undefined") nodeProcess = process;
const isElectronRenderer = typeof ((_a = nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.versions) === null || _a === void 0 ? void 0 : _a.electron) === "string" && (nodeProcess === null || nodeProcess === void 0 ? void 0 : nodeProcess.type) === "renderer";
if (typeof navigator === "object" && !isElectronRenderer) {
	_userAgent = navigator.userAgent;
	_isWindows = _userAgent.indexOf("Windows") >= 0;
	_isMacintosh = _userAgent.indexOf("Macintosh") >= 0;
	_isIOS = (_userAgent.indexOf("Macintosh") >= 0 || _userAgent.indexOf("iPad") >= 0 || _userAgent.indexOf("iPhone") >= 0) && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
	_isLinux = _userAgent.indexOf("Linux") >= 0;
	_isWeb = true;
	_locale = navigator.language;
	_language = _locale;
} else if (typeof nodeProcess === "object") {
	_isWindows = nodeProcess.platform === "win32";
	_isMacintosh = nodeProcess.platform === "darwin";
	_isLinux = nodeProcess.platform === "linux";
	_isLinux && nodeProcess.env["SNAP"] && nodeProcess.env["SNAP_REVISION"];
	nodeProcess.env["CI"] || nodeProcess.env["BUILD_ARTIFACTSTAGINGDIRECTORY"];
	_locale = LANGUAGE_DEFAULT;
	_language = LANGUAGE_DEFAULT;
	const rawNlsConfig = nodeProcess.env["VSCODE_NLS_CONFIG"];
	if (rawNlsConfig) try {
		const nlsConfig = JSON.parse(rawNlsConfig);
		const resolved = nlsConfig.availableLanguages["*"];
		_locale = nlsConfig.locale;
		_language = resolved ? resolved : LANGUAGE_DEFAULT;
		nlsConfig._translationsConfigFile;
	} catch (e) {}
	_isNative = true;
} else console.error("Unable to resolve platform.");
const isWebWorker = _isWeb && typeof globals.importScripts === "function";
const userAgent = _userAgent;
/**
* See https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#:~:text=than%204%2C%20then-,set%20timeout%20to%204,-.
*
* Works similarly to `setTimeout(0)` but doesn't suffer from the 4ms artificial delay
* that browsers set when the nesting level is > 5.
*/
const setTimeout0 = (() => {
	if (typeof globals.postMessage === "function" && !globals.importScripts) {
		let pending = [];
		globals.addEventListener("message", (e) => {
			if (e.data && e.data.vscodeScheduleAsyncWork) for (let i = 0, len = pending.length; i < len; i++) {
				const candidate = pending[i];
				if (candidate.id === e.data.vscodeScheduleAsyncWork) {
					pending.splice(i, 1);
					candidate.callback();
					return;
				}
			}
		});
		let lastId = 0;
		return (callback) => {
			const myId = ++lastId;
			pending.push({
				id: myId,
				callback
			});
			globals.postMessage({ vscodeScheduleAsyncWork: myId }, "*");
		};
	}
	return (callback) => setTimeout(callback);
})();
let _isLittleEndian = true;
let _isLittleEndianComputed = false;
function isLittleEndian() {
	if (!_isLittleEndianComputed) {
		_isLittleEndianComputed = true;
		const test = new Uint8Array(2);
		test[0] = 1;
		test[1] = 2;
		_isLittleEndian = new Uint16Array(test.buffer)[0] === 513;
	}
	return _isLittleEndian;
}
const isChrome = !!(userAgent && userAgent.indexOf("Chrome") >= 0);
const isFirefox = !!(userAgent && userAgent.indexOf("Firefox") >= 0);
const isSafari = !!(!isChrome && userAgent && userAgent.indexOf("Safari") >= 0);
const isEdge = !!(userAgent && userAgent.indexOf("Edg/") >= 0);
const isAndroid = !!(userAgent && userAgent.indexOf("Android") >= 0);

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/stopwatch.js
const hasPerformanceNow = globals.performance && typeof globals.performance.now === "function";
var StopWatch = class StopWatch {
	constructor(highResolution) {
		this._highResolution = hasPerformanceNow && highResolution;
		this._startTime = this._now();
		this._stopTime = -1;
	}
	static create(highResolution = true) {
		return new StopWatch(highResolution);
	}
	stop() {
		this._stopTime = this._now();
	}
	elapsed() {
		if (this._stopTime !== -1) return this._stopTime - this._startTime;
		return this._now() - this._startTime;
	}
	_now() {
		return this._highResolution ? globals.performance.now() : Date.now();
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/event.js
var Event;
(function(Event$1) {
	Event$1.None = () => Disposable.None;
	function _addLeakageTraceLogic(options) {}
	/**
	* Given an event, returns another event which only fires once.
	*/
	function once$1(event) {
		return (listener, thisArgs = null, disposables) => {
			let didFire = false;
			let result;
			result = event((e) => {
				if (didFire) return;
				else if (result) result.dispose();
				else didFire = true;
				return listener.call(thisArgs, e);
			}, null, disposables);
			if (didFire) result.dispose();
			return result;
		};
	}
	Event$1.once = once$1;
	/**
	* *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
	* event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
	* returned event causes this utility to leak a listener on the original event.
	*/
	function map(event, map$1, disposable) {
		return snapshot((listener, thisArgs = null, disposables) => event((i) => listener.call(thisArgs, map$1(i)), null, disposables), disposable);
	}
	Event$1.map = map;
	/**
	* *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
	* event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
	* returned event causes this utility to leak a listener on the original event.
	*/
	function forEach(event, each, disposable) {
		return snapshot((listener, thisArgs = null, disposables) => event((i) => {
			each(i);
			listener.call(thisArgs, i);
		}, null, disposables), disposable);
	}
	Event$1.forEach = forEach;
	function filter(event, filter$1, disposable) {
		return snapshot((listener, thisArgs = null, disposables) => event((e) => filter$1(e) && listener.call(thisArgs, e), null, disposables), disposable);
	}
	Event$1.filter = filter;
	/**
	* Given an event, returns the same event but typed as `Event<void>`.
	*/
	function signal$1(event) {
		return event;
	}
	Event$1.signal = signal$1;
	function any(...events) {
		return (listener, thisArgs = null, disposables) => combinedDisposable(...events.map((event) => event((e) => listener.call(thisArgs, e), null, disposables)));
	}
	Event$1.any = any;
	/**
	* *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
	* event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
	* returned event causes this utility to leak a listener on the original event.
	*/
	function reduce(event, merge, initial, disposable) {
		let output = initial;
		return map(event, (e) => {
			output = merge(output, e);
			return output;
		}, disposable);
	}
	Event$1.reduce = reduce;
	function snapshot(event, disposable) {
		let listener;
		const options = {
			onFirstListenerAdd() {
				listener = event(emitter.fire, emitter);
			},
			onLastListenerRemove() {
				listener.dispose();
			}
		};
		if (!disposable) _addLeakageTraceLogic(options);
		const emitter = new Emitter(options);
		if (disposable) disposable.add(emitter);
		return emitter.event;
	}
	function debounce(event, merge, delay = 100, leading = false, leakWarningThreshold, disposable) {
		let subscription;
		let output = void 0;
		let handle = void 0;
		let numDebouncedCalls = 0;
		const options = {
			leakWarningThreshold,
			onFirstListenerAdd() {
				subscription = event((cur) => {
					numDebouncedCalls++;
					output = merge(output, cur);
					if (leading && !handle) {
						emitter.fire(output);
						output = void 0;
					}
					clearTimeout(handle);
					handle = setTimeout(() => {
						const _output = output;
						output = void 0;
						handle = void 0;
						if (!leading || numDebouncedCalls > 1) emitter.fire(_output);
						numDebouncedCalls = 0;
					}, delay);
				});
			},
			onLastListenerRemove() {
				subscription.dispose();
			}
		};
		if (!disposable) _addLeakageTraceLogic(options);
		const emitter = new Emitter(options);
		if (disposable) disposable.add(emitter);
		return emitter.event;
	}
	Event$1.debounce = debounce;
	/**
	* *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
	* event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
	* returned event causes this utility to leak a listener on the original event.
	*/
	function latch(event, equals = (a, b) => a === b, disposable) {
		let firstCall = true;
		let cache;
		return filter(event, (value) => {
			const shouldEmit = firstCall || !equals(value, cache);
			firstCall = false;
			cache = value;
			return shouldEmit;
		}, disposable);
	}
	Event$1.latch = latch;
	/**
	* *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
	* event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
	* returned event causes this utility to leak a listener on the original event.
	*/
	function split(event, isT, disposable) {
		return [Event$1.filter(event, isT, disposable), Event$1.filter(event, (e) => !isT(e), disposable)];
	}
	Event$1.split = split;
	/**
	* *NOTE* that this function returns an `Event` and it MUST be called with a `DisposableStore` whenever the returned
	* event is accessible to "third parties", e.g the event is a public property. Otherwise a leaked listener on the
	* returned event causes this utility to leak a listener on the original event.
	*/
	function buffer(event, flushAfterTimeout = false, _buffer = []) {
		let buffer$1 = _buffer.slice();
		let listener = event((e) => {
			if (buffer$1) buffer$1.push(e);
			else emitter.fire(e);
		});
		const flush = () => {
			if (buffer$1) buffer$1.forEach((e) => emitter.fire(e));
			buffer$1 = null;
		};
		const emitter = new Emitter({
			onFirstListenerAdd() {
				if (!listener) listener = event((e) => emitter.fire(e));
			},
			onFirstListenerDidAdd() {
				if (buffer$1) if (flushAfterTimeout) setTimeout(flush);
				else flush();
			},
			onLastListenerRemove() {
				if (listener) listener.dispose();
				listener = null;
			}
		});
		return emitter.event;
	}
	Event$1.buffer = buffer;
	class ChainableEvent {
		constructor(event) {
			this.event = event;
		}
		map(fn) {
			return new ChainableEvent(map(this.event, fn));
		}
		forEach(fn) {
			return new ChainableEvent(forEach(this.event, fn));
		}
		filter(fn) {
			return new ChainableEvent(filter(this.event, fn));
		}
		reduce(merge, initial) {
			return new ChainableEvent(reduce(this.event, merge, initial));
		}
		latch() {
			return new ChainableEvent(latch(this.event));
		}
		debounce(merge, delay = 100, leading = false, leakWarningThreshold) {
			return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));
		}
		on(listener, thisArgs, disposables) {
			return this.event(listener, thisArgs, disposables);
		}
		once(listener, thisArgs, disposables) {
			return once$1(this.event)(listener, thisArgs, disposables);
		}
	}
	/**
	* @deprecated DO NOT use, this leaks memory
	*/
	function chain(event) {
		return new ChainableEvent(event);
	}
	Event$1.chain = chain;
	function fromNodeEventEmitter(emitter, eventName, map$1 = (id) => id) {
		const fn = (...args) => result.fire(map$1(...args));
		const onFirstListenerAdd = () => emitter.on(eventName, fn);
		const onLastListenerRemove = () => emitter.removeListener(eventName, fn);
		const result = new Emitter({
			onFirstListenerAdd,
			onLastListenerRemove
		});
		return result.event;
	}
	Event$1.fromNodeEventEmitter = fromNodeEventEmitter;
	function fromDOMEventEmitter(emitter, eventName, map$1 = (id) => id) {
		const fn = (...args) => result.fire(map$1(...args));
		const onFirstListenerAdd = () => emitter.addEventListener(eventName, fn);
		const onLastListenerRemove = () => emitter.removeEventListener(eventName, fn);
		const result = new Emitter({
			onFirstListenerAdd,
			onLastListenerRemove
		});
		return result.event;
	}
	Event$1.fromDOMEventEmitter = fromDOMEventEmitter;
	function toPromise(event) {
		return new Promise((resolve) => once$1(event)(resolve));
	}
	Event$1.toPromise = toPromise;
	function runAndSubscribe(event, handler) {
		handler(void 0);
		return event((e) => handler(e));
	}
	Event$1.runAndSubscribe = runAndSubscribe;
	function runAndSubscribeWithStore(event, handler) {
		let store = null;
		function run(e) {
			store === null || store === void 0 || store.dispose();
			store = new DisposableStore();
			handler(e, store);
		}
		run(void 0);
		const disposable = event((e) => run(e));
		return toDisposable(() => {
			disposable.dispose();
			store === null || store === void 0 || store.dispose();
		});
	}
	Event$1.runAndSubscribeWithStore = runAndSubscribeWithStore;
})(Event || (Event = {}));
var EventProfiling = class EventProfiling {
	constructor(name) {
		this._listenerCount = 0;
		this._invocationCount = 0;
		this._elapsedOverall = 0;
		this._name = `${name}_${EventProfiling._idPool++}`;
	}
	start(listenerCount) {
		this._stopWatch = new StopWatch(true);
		this._listenerCount = listenerCount;
	}
	stop() {
		if (this._stopWatch) {
			const elapsed = this._stopWatch.elapsed();
			this._elapsedOverall += elapsed;
			this._invocationCount += 1;
			console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`);
			this._stopWatch = void 0;
		}
	}
};
EventProfiling._idPool = 0;
let _globalLeakWarningThreshold = -1;
var LeakageMonitor = class {
	constructor(customThreshold, name = Math.random().toString(18).slice(2, 5)) {
		this.customThreshold = customThreshold;
		this.name = name;
		this._warnCountdown = 0;
	}
	dispose() {
		if (this._stacks) this._stacks.clear();
	}
	check(stack, listenerCount) {
		let threshold = _globalLeakWarningThreshold;
		if (typeof this.customThreshold === "number") threshold = this.customThreshold;
		if (threshold <= 0 || listenerCount < threshold) return;
		if (!this._stacks) this._stacks = /* @__PURE__ */ new Map();
		const count = this._stacks.get(stack.value) || 0;
		this._stacks.set(stack.value, count + 1);
		this._warnCountdown -= 1;
		if (this._warnCountdown <= 0) {
			this._warnCountdown = threshold * .5;
			let topStack;
			let topCount = 0;
			for (const [stack$1, count$1] of this._stacks) if (!topStack || topCount < count$1) {
				topStack = stack$1;
				topCount = count$1;
			}
			console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`);
			console.warn(topStack);
		}
		return () => {
			const count$1 = this._stacks.get(stack.value) || 0;
			this._stacks.set(stack.value, count$1 - 1);
		};
	}
};
var Stacktrace = class Stacktrace {
	constructor(value) {
		this.value = value;
	}
	static create() {
		var _a$2;
		return new Stacktrace((_a$2 = (/* @__PURE__ */ new Error()).stack) !== null && _a$2 !== void 0 ? _a$2 : "");
	}
	print() {
		console.warn(this.value.split("\n").slice(2).join("\n"));
	}
};
var Listener = class {
	constructor(callback, callbackThis, stack) {
		this.callback = callback;
		this.callbackThis = callbackThis;
		this.stack = stack;
		this.subscription = new SafeDisposable();
	}
	invoke(e) {
		this.callback.call(this.callbackThis, e);
	}
};
/**
* The Emitter can be used to expose an Event to the public
* to fire it from the insides.
* Sample:
class Document {

private readonly _onDidChange = new Emitter<(value:string)=>any>();

public onDidChange = this._onDidChange.event;

// getter-style
// get onDidChange(): Event<(value:string)=>any> {
// 	return this._onDidChange.event;
// }

private _doIt() {
//...
this._onDidChange.fire(value);
}
}
*/
var Emitter = class {
	constructor(options) {
		var _a$2;
		this._disposed = false;
		this._options = options;
		this._leakageMon = _globalLeakWarningThreshold > 0 ? new LeakageMonitor(this._options && this._options.leakWarningThreshold) : void 0;
		this._perfMon = ((_a$2 = this._options) === null || _a$2 === void 0 ? void 0 : _a$2._profName) ? new EventProfiling(this._options._profName) : void 0;
	}
	dispose() {
		var _a$2, _b, _c, _d;
		if (!this._disposed) {
			this._disposed = true;
			if (this._listeners) this._listeners.clear();
			(_a$2 = this._deliveryQueue) === null || _a$2 === void 0 || _a$2.clear();
			(_c = (_b = this._options) === null || _b === void 0 ? void 0 : _b.onLastListenerRemove) === null || _c === void 0 || _c.call(_b);
			(_d = this._leakageMon) === null || _d === void 0 || _d.dispose();
		}
	}
	/**
	* For the public to allow to subscribe
	* to events from this Emitter
	*/
	get event() {
		if (!this._event) this._event = (callback, thisArgs, disposables) => {
			var _a$2, _b, _c;
			if (!this._listeners) this._listeners = new LinkedList();
			const firstListener = this._listeners.isEmpty();
			if (firstListener && ((_a$2 = this._options) === null || _a$2 === void 0 ? void 0 : _a$2.onFirstListenerAdd)) this._options.onFirstListenerAdd(this);
			let removeMonitor;
			let stack;
			if (this._leakageMon && this._listeners.size >= 30) {
				stack = Stacktrace.create();
				removeMonitor = this._leakageMon.check(stack, this._listeners.size + 1);
			}
			const listener = new Listener(callback, thisArgs, stack);
			const removeListener = this._listeners.push(listener);
			if (firstListener && ((_b = this._options) === null || _b === void 0 ? void 0 : _b.onFirstListenerDidAdd)) this._options.onFirstListenerDidAdd(this);
			if ((_c = this._options) === null || _c === void 0 ? void 0 : _c.onListenerDidAdd) this._options.onListenerDidAdd(this, callback, thisArgs);
			const result = listener.subscription.set(() => {
				if (removeMonitor) removeMonitor();
				if (!this._disposed) {
					removeListener();
					if (this._options && this._options.onLastListenerRemove) {
						if (!(this._listeners && !this._listeners.isEmpty())) this._options.onLastListenerRemove(this);
					}
				}
			});
			if (disposables instanceof DisposableStore) disposables.add(result);
			else if (Array.isArray(disposables)) disposables.push(result);
			return result;
		};
		return this._event;
	}
	/**
	* To be kept private to fire an event to
	* subscribers
	*/
	fire(event) {
		var _a$2, _b;
		if (this._listeners) {
			if (!this._deliveryQueue) this._deliveryQueue = new LinkedList();
			for (let listener of this._listeners) this._deliveryQueue.push([listener, event]);
			(_a$2 = this._perfMon) === null || _a$2 === void 0 || _a$2.start(this._deliveryQueue.size);
			while (this._deliveryQueue.size > 0) {
				const [listener, event$1] = this._deliveryQueue.shift();
				try {
					listener.invoke(event$1);
				} catch (e) {
					onUnexpectedError(e);
				}
			}
			(_b = this._perfMon) === null || _b === void 0 || _b.stop();
		}
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/wordHelper.js
const USUAL_WORD_SEPARATORS = "`~!@#$%^&*()-=+[{]}\\|;:'\",.<>/?";
/**
* Create a word definition regular expression based on default word separators.
* Optionally provide allowed separators that should be included in words.
*
* The default would look like this:
* /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
*/
function createWordRegExp(allowInWords = "") {
	let source = "(-?\\d*\\.\\d\\w*)|([^";
	for (const sep of USUAL_WORD_SEPARATORS) {
		if (allowInWords.indexOf(sep) >= 0) continue;
		source += "\\" + sep;
	}
	source += "\\s]+)";
	return new RegExp(source, "g");
}
const DEFAULT_WORD_REGEXP = createWordRegExp();
function ensureValidWordDefinition(wordDefinition) {
	let result = DEFAULT_WORD_REGEXP;
	if (wordDefinition && wordDefinition instanceof RegExp) if (!wordDefinition.global) {
		let flags = "g";
		if (wordDefinition.ignoreCase) flags += "i";
		if (wordDefinition.multiline) flags += "m";
		if (wordDefinition.unicode) flags += "u";
		result = new RegExp(wordDefinition.source, flags);
	} else result = wordDefinition;
	result.lastIndex = 0;
	return result;
}

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js
/**
* Describes what to do with the indentation when pressing Enter.
*/
var IndentAction;
(function(IndentAction$1) {
	/**
	* Insert new line and copy the previous line's indentation.
	*/
	IndentAction$1[IndentAction$1["None"] = 0] = "None";
	/**
	* Insert new line and indent once (relative to the previous line's indentation).
	*/
	IndentAction$1[IndentAction$1["Indent"] = 1] = "Indent";
	/**
	* Insert two new lines:
	*  - the first one indented which will hold the cursor
	*  - the second one at the same indentation level
	*/
	IndentAction$1[IndentAction$1["IndentOutdent"] = 2] = "IndentOutdent";
	/**
	* Insert new line and outdent once (relative to the previous line's indentation).
	*/
	IndentAction$1[IndentAction$1["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
/**
* @internal
*/
var StandardAutoClosingPairConditional = class {
	constructor(source) {
		this._neutralCharacter = null;
		this._neutralCharacterSearched = false;
		this.open = source.open;
		this.close = source.close;
		this._inString = true;
		this._inComment = true;
		this._inRegEx = true;
		if (Array.isArray(source.notIn)) for (let i = 0, len = source.notIn.length; i < len; i++) switch (source.notIn[i]) {
			case "string":
				this._inString = false;
				break;
			case "comment":
				this._inComment = false;
				break;
			case "regex":
				this._inRegEx = false;
				break;
		}
	}
	isOK(standardToken) {
		switch (standardToken) {
			case 0: return true;
			case 1: return this._inComment;
			case 2: return this._inString;
			case 3: return this._inRegEx;
		}
	}
	shouldAutoClose(context, column) {
		if (context.getTokenCount() === 0) return true;
		const tokenIndex = context.findTokenIndexAtOffset(column - 2);
		const standardTokenType = context.getStandardTokenType(tokenIndex);
		return this.isOK(standardTokenType);
	}
	_findNeutralCharacterInRange(fromCharCode, toCharCode) {
		for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {
			const character = String.fromCharCode(charCode);
			if (!this.open.includes(character) && !this.close.includes(character)) return character;
		}
		return null;
	}
	/**
	* Find a character in the range [0-9a-zA-Z] that does not appear in the open or close
	*/
	findNeutralCharacter() {
		if (!this._neutralCharacterSearched) {
			this._neutralCharacterSearched = true;
			if (!this._neutralCharacter) this._neutralCharacter = this._findNeutralCharacterInRange(48, 57);
			if (!this._neutralCharacter) this._neutralCharacter = this._findNeutralCharacterInRange(97, 122);
			if (!this._neutralCharacter) this._neutralCharacter = this._findNeutralCharacterInRange(65, 90);
		}
		return this._neutralCharacter;
	}
};
/**
* @internal
*/
var AutoClosingPairs = class {
	constructor(autoClosingPairs) {
		this.autoClosingPairsOpenByStart = /* @__PURE__ */ new Map();
		this.autoClosingPairsOpenByEnd = /* @__PURE__ */ new Map();
		this.autoClosingPairsCloseByStart = /* @__PURE__ */ new Map();
		this.autoClosingPairsCloseByEnd = /* @__PURE__ */ new Map();
		this.autoClosingPairsCloseSingleChar = /* @__PURE__ */ new Map();
		for (const pair of autoClosingPairs) {
			appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);
			appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);
			appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);
			appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);
			if (pair.close.length === 1 && pair.open.length === 1) appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);
		}
	}
};
function appendEntry(target, key, value) {
	if (target.has(key)) target.get(key).push(value);
	else target.set(key, [value]);
}

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js
function createScopedLineTokens(context, offset) {
	const tokenCount = context.getCount();
	const tokenIndex = context.findTokenIndexAtOffset(offset);
	const desiredLanguageId = context.getLanguageId(tokenIndex);
	let lastTokenIndex = tokenIndex;
	while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) lastTokenIndex++;
	let firstTokenIndex = tokenIndex;
	while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) firstTokenIndex--;
	return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));
}
var ScopedLineTokens = class {
	constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {
		this._scopedLineTokensBrand = void 0;
		this._actual = actual;
		this.languageId = languageId;
		this._firstTokenIndex = firstTokenIndex;
		this._lastTokenIndex = lastTokenIndex;
		this.firstCharOffset = firstCharOffset;
		this._lastCharOffset = lastCharOffset;
	}
	getLineContent() {
		return this._actual.getLineContent().substring(this.firstCharOffset, this._lastCharOffset);
	}
	getActualLineContentBefore(offset) {
		return this._actual.getLineContent().substring(0, this.firstCharOffset + offset);
	}
	getTokenCount() {
		return this._lastTokenIndex - this._firstTokenIndex;
	}
	findTokenIndexAtOffset(offset) {
		return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;
	}
	getStandardTokenType(tokenIndex) {
		return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);
	}
};
function ignoreBracketsInToken(standardTokenType) {
	return (standardTokenType & 3) !== 0;
}

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js
var CharacterPairSupport = class CharacterPairSupport {
	constructor(config) {
		if (config.autoClosingPairs) this._autoClosingPairs = config.autoClosingPairs.map((el) => new StandardAutoClosingPairConditional(el));
		else if (config.brackets) this._autoClosingPairs = config.brackets.map((b) => new StandardAutoClosingPairConditional({
			open: b[0],
			close: b[1]
		}));
		else this._autoClosingPairs = [];
		if (config.colorizedBracketPairs) this._colorizedBracketPairs = filterValidBrackets(config.colorizedBracketPairs.map((b) => [b[0], b[1]]));
		else if (config.brackets) this._colorizedBracketPairs = filterValidBrackets(config.brackets.map((b) => [b[0], b[1]]).filter((p) => !(p[0] === "<" && p[1] === ">")));
		else this._colorizedBracketPairs = [];
		if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {
			const docComment = config.__electricCharacterSupport.docComment;
			this._autoClosingPairs.push(new StandardAutoClosingPairConditional({
				open: docComment.open,
				close: docComment.close || ""
			}));
		}
		this._autoCloseBefore = typeof config.autoCloseBefore === "string" ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED;
		this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;
	}
	getAutoClosingPairs() {
		return this._autoClosingPairs;
	}
	getAutoCloseBeforeSet() {
		return this._autoCloseBefore;
	}
	getSurroundingPairs() {
		return this._surroundingPairs;
	}
	getColorizedBrackets() {
		return this._colorizedBracketPairs;
	}
};
CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED = ";:.,=}])> \n	";
function filterValidBrackets(bracketPairs) {
	return bracketPairs.filter(([open, close]) => open !== "" && close !== "");
}

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/arrays.js
/**
* Removes duplicates from the given array. The optional keyFn allows to specify
* how elements are checked for equality by returning an alternate value for each.
*/
function distinct(array, keyFn = (value) => value) {
	const seen = /* @__PURE__ */ new Set();
	return array.filter((element) => {
		const key = keyFn(element);
		if (seen.has(key)) return false;
		seen.add(key);
		return true;
	});
}

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/base/common/buffer.js
function readUInt16LE(source, offset) {
	return source[offset + 0] << 0 >>> 0 | source[offset + 1] << 8 >>> 0;
}

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js
let _utf16LE_TextDecoder;
function getUTF16LE_TextDecoder() {
	if (!_utf16LE_TextDecoder) _utf16LE_TextDecoder = new TextDecoder("UTF-16LE");
	return _utf16LE_TextDecoder;
}
let _utf16BE_TextDecoder;
function getUTF16BE_TextDecoder() {
	if (!_utf16BE_TextDecoder) _utf16BE_TextDecoder = new TextDecoder("UTF-16BE");
	return _utf16BE_TextDecoder;
}
let _platformTextDecoder;
function getPlatformTextDecoder() {
	if (!_platformTextDecoder) _platformTextDecoder = isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();
	return _platformTextDecoder;
}
const hasTextDecoder = typeof TextDecoder !== "undefined";
let createStringBuilder;
let decodeUTF16LE;
if (hasTextDecoder) {
	createStringBuilder = (capacity) => new StringBuilder(capacity);
	decodeUTF16LE = standardDecodeUTF16LE;
} else {
	createStringBuilder = (capacity) => new CompatStringBuilder();
	decodeUTF16LE = compatDecodeUTF16LE;
}
function standardDecodeUTF16LE(source, offset, len) {
	const view = new Uint16Array(source.buffer, offset, len);
	if (len > 0 && (view[0] === 65279 || view[0] === 65534)) return compatDecodeUTF16LE(source, offset, len);
	return getUTF16LE_TextDecoder().decode(view);
}
function compatDecodeUTF16LE(source, offset, len) {
	const result = [];
	let resultLen = 0;
	for (let i = 0; i < len; i++) {
		const charCode = readUInt16LE(source, offset);
		offset += 2;
		result[resultLen++] = String.fromCharCode(charCode);
	}
	return result.join("");
}
var StringBuilder = class {
	constructor(capacity) {
		this._capacity = capacity | 0;
		this._buffer = new Uint16Array(this._capacity);
		this._completedStrings = null;
		this._bufferLength = 0;
	}
	reset() {
		this._completedStrings = null;
		this._bufferLength = 0;
	}
	build() {
		if (this._completedStrings !== null) {
			this._flushBuffer();
			return this._completedStrings.join("");
		}
		return this._buildBuffer();
	}
	_buildBuffer() {
		if (this._bufferLength === 0) return "";
		const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);
		return getPlatformTextDecoder().decode(view);
	}
	_flushBuffer() {
		const bufferString = this._buildBuffer();
		this._bufferLength = 0;
		if (this._completedStrings === null) this._completedStrings = [bufferString];
		else this._completedStrings[this._completedStrings.length] = bufferString;
	}
	write1(charCode) {
		const remainingSpace = this._capacity - this._bufferLength;
		if (remainingSpace <= 1) {
			if (remainingSpace === 0 || isHighSurrogate(charCode)) this._flushBuffer();
		}
		this._buffer[this._bufferLength++] = charCode;
	}
	appendASCII(charCode) {
		if (this._bufferLength === this._capacity) this._flushBuffer();
		this._buffer[this._bufferLength++] = charCode;
	}
	appendASCIIString(str) {
		const strLen = str.length;
		if (this._bufferLength + strLen >= this._capacity) {
			this._flushBuffer();
			this._completedStrings[this._completedStrings.length] = str;
			return;
		}
		for (let i = 0; i < strLen; i++) this._buffer[this._bufferLength++] = str.charCodeAt(i);
	}
};
var CompatStringBuilder = class {
	constructor() {
		this._pieces = [];
		this._piecesLen = 0;
	}
	reset() {
		this._pieces = [];
		this._piecesLen = 0;
	}
	build() {
		return this._pieces.join("");
	}
	write1(charCode) {
		this._pieces[this._piecesLen++] = String.fromCharCode(charCode);
	}
	appendASCII(charCode) {
		this._pieces[this._piecesLen++] = String.fromCharCode(charCode);
	}
	appendASCIIString(str) {
		this._pieces[this._piecesLen++] = str;
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js
/**
* Represents a grouping of colliding bracket pairs.
*
* Most of the times this contains a single bracket pair,
* but sometimes this contains multiple bracket pairs in cases
* where the same string appears as a closing bracket for multiple
* bracket pairs, or the same string appears an opening bracket for
* multiple bracket pairs.
*
* e.g. of a group containing a single pair:
*   open: ['{'], close: ['}']
*
* e.g. of a group containing multiple pairs:
*   open: ['if', 'for'], close: ['end', 'end']
*/
var RichEditBracket = class RichEditBracket {
	constructor(languageId, index, open, close, forwardRegex, reversedRegex) {
		this._richEditBracketBrand = void 0;
		this.languageId = languageId;
		this.index = index;
		this.open = open;
		this.close = close;
		this.forwardRegex = forwardRegex;
		this.reversedRegex = reversedRegex;
		this._openSet = RichEditBracket._toSet(this.open);
		this._closeSet = RichEditBracket._toSet(this.close);
	}
	/**
	* Check if the provided `text` is an open bracket in this group.
	*/
	isOpen(text) {
		return this._openSet.has(text);
	}
	/**
	* Check if the provided `text` is a close bracket in this group.
	*/
	isClose(text) {
		return this._closeSet.has(text);
	}
	static _toSet(arr) {
		const result = /* @__PURE__ */ new Set();
		for (const element of arr) result.add(element);
		return result;
	}
};
/**
* Groups together brackets that have equal open or close sequences.
*
* For example, if the following brackets are defined:
*   ['IF','END']
*   ['for','end']
*   ['{','}']
*
* Then the grouped brackets would be:
*   { open: ['if', 'for'], close: ['end', 'end'] }
*   { open: ['{'], close: ['}'] }
*
*/
function groupFuzzyBrackets(brackets) {
	const N = brackets.length;
	brackets = brackets.map((b) => [b[0].toLowerCase(), b[1].toLowerCase()]);
	const group = [];
	for (let i = 0; i < N; i++) group[i] = i;
	const areOverlapping = (a, b) => {
		const [aOpen, aClose] = a;
		const [bOpen, bClose] = b;
		return aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose;
	};
	const mergeGroups = (g1, g2) => {
		const newG = Math.min(g1, g2);
		const oldG = Math.max(g1, g2);
		for (let i = 0; i < N; i++) if (group[i] === oldG) group[i] = newG;
	};
	for (let i = 0; i < N; i++) {
		const a = brackets[i];
		for (let j = i + 1; j < N; j++) {
			const b = brackets[j];
			if (areOverlapping(a, b)) mergeGroups(group[i], group[j]);
		}
	}
	const result = [];
	for (let g = 0; g < N; g++) {
		const currentOpen = [];
		const currentClose = [];
		for (let i = 0; i < N; i++) if (group[i] === g) {
			const [open, close] = brackets[i];
			currentOpen.push(open);
			currentClose.push(close);
		}
		if (currentOpen.length > 0) result.push({
			open: currentOpen,
			close: currentClose
		});
	}
	return result;
}
var RichEditBrackets = class {
	constructor(languageId, _brackets) {
		this._richEditBracketsBrand = void 0;
		const brackets = groupFuzzyBrackets(_brackets);
		this.brackets = brackets.map((b, index) => {
			return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));
		});
		this.forwardRegex = getRegexForBrackets(this.brackets);
		this.reversedRegex = getReversedRegexForBrackets(this.brackets);
		this.textIsBracket = {};
		this.textIsOpenBracket = {};
		this.maxBracketLength = 0;
		for (const bracket of this.brackets) {
			for (const open of bracket.open) {
				this.textIsBracket[open] = bracket;
				this.textIsOpenBracket[open] = true;
				this.maxBracketLength = Math.max(this.maxBracketLength, open.length);
			}
			for (const close of bracket.close) {
				this.textIsBracket[close] = bracket;
				this.textIsOpenBracket[close] = false;
				this.maxBracketLength = Math.max(this.maxBracketLength, close.length);
			}
		}
	}
};
function collectSuperstrings(str, brackets, currentIndex, dest) {
	for (let i = 0, len = brackets.length; i < len; i++) {
		if (i === currentIndex) continue;
		const bracket = brackets[i];
		for (const open of bracket.open) if (open.indexOf(str) >= 0) dest.push(open);
		for (const close of bracket.close) if (close.indexOf(str) >= 0) dest.push(close);
	}
}
function lengthcmp(a, b) {
	return a.length - b.length;
}
function unique(arr) {
	if (arr.length <= 1) return arr;
	const result = [];
	const seen = /* @__PURE__ */ new Set();
	for (const element of arr) {
		if (seen.has(element)) continue;
		result.push(element);
		seen.add(element);
	}
	return result;
}
/**
* Create a regular expression that can be used to search forward in a piece of text
* for a group of bracket pairs. But this regex must be built in a way in which
* it is aware of the other bracket pairs defined for the language.
*
* For example, if a language contains the following bracket pairs:
*   ['begin', 'end']
*   ['if', 'end if']
* The two bracket pairs do not collide because no open or close brackets are equal.
* So the function getRegexForBracketPair is called twice, once with
* the ['begin'], ['end'] group consisting of one bracket pair, and once with
* the ['if'], ['end if'] group consiting of the other bracket pair.
*
* But there could be a situation where an occurrence of 'end if' is mistaken
* for an occurrence of 'end'.
*
* Therefore, for the bracket pair ['begin', 'end'], the regex will also
* target 'end if'. The regex will be something like:
*   /(\bend if\b)|(\bend\b)|(\bif\b)/
*
* The regex also searches for "superstrings" (other brackets that might be mistaken with the current bracket).
*
*/
function getRegexForBracketPair(open, close, brackets, currentIndex) {
	let pieces = [];
	pieces = pieces.concat(open);
	pieces = pieces.concat(close);
	for (let i = 0, len = pieces.length; i < len; i++) collectSuperstrings(pieces[i], brackets, currentIndex, pieces);
	pieces = unique(pieces);
	pieces.sort(lengthcmp);
	pieces.reverse();
	return createBracketOrRegExp(pieces);
}
/**
* Matching a regular expression in JS can only be done "forwards". So JS offers natively only
* methods to find the first match of a regex in a string. But sometimes, it is useful to
* find the last match of a regex in a string. For such a situation, a nice solution is to
* simply reverse the string and then search for a reversed regex.
*
* This function also has the fine details of `getRegexForBracketPair`. For the same example
* given above, the regex produced here would look like:
*   /(\bfi dne\b)|(\bdne\b)|(\bfi\b)/
*/
function getReversedRegexForBracketPair(open, close, brackets, currentIndex) {
	let pieces = [];
	pieces = pieces.concat(open);
	pieces = pieces.concat(close);
	for (let i = 0, len = pieces.length; i < len; i++) collectSuperstrings(pieces[i], brackets, currentIndex, pieces);
	pieces = unique(pieces);
	pieces.sort(lengthcmp);
	pieces.reverse();
	return createBracketOrRegExp(pieces.map(toReversedString));
}
/**
* Creates a regular expression that targets all bracket pairs.
*
* e.g. for the bracket pairs:
*  ['{','}']
*  ['begin,'end']
*  ['for','end']
* the regex would look like:
*  /(\{)|(\})|(\bbegin\b)|(\bend\b)|(\bfor\b)/
*/
function getRegexForBrackets(brackets) {
	let pieces = [];
	for (const bracket of brackets) {
		for (const open of bracket.open) pieces.push(open);
		for (const close of bracket.close) pieces.push(close);
	}
	pieces = unique(pieces);
	return createBracketOrRegExp(pieces);
}
/**
* Matching a regular expression in JS can only be done "forwards". So JS offers natively only
* methods to find the first match of a regex in a string. But sometimes, it is useful to
* find the last match of a regex in a string. For such a situation, a nice solution is to
* simply reverse the string and then search for a reversed regex.
*
* e.g. for the bracket pairs:
*  ['{','}']
*  ['begin,'end']
*  ['for','end']
* the regex would look like:
*  /(\{)|(\})|(\bnigeb\b)|(\bdne\b)|(\brof\b)/
*/
function getReversedRegexForBrackets(brackets) {
	let pieces = [];
	for (const bracket of brackets) {
		for (const open of bracket.open) pieces.push(open);
		for (const close of bracket.close) pieces.push(close);
	}
	pieces = unique(pieces);
	return createBracketOrRegExp(pieces.map(toReversedString));
}
function prepareBracketForRegExp(str) {
	const insertWordBoundaries = /^[\w ]+$/.test(str);
	str = escapeRegExpCharacters(str);
	return insertWordBoundaries ? `\\b${str}\\b` : str;
}
function createBracketOrRegExp(pieces) {
	const regexStr = `(${pieces.map(prepareBracketForRegExp).join(")|(")})`;
	return createRegExp(regexStr, true);
}
const toReversedString = (function() {
	function reverse(str) {
		if (hasTextDecoder) {
			const arr = new Uint16Array(str.length);
			let offset = 0;
			for (let i = str.length - 1; i >= 0; i--) arr[offset++] = str.charCodeAt(i);
			return getPlatformTextDecoder().decode(arr);
		} else {
			const result = [];
			let resultLen = 0;
			for (let i = str.length - 1; i >= 0; i--) result[resultLen++] = str.charAt(i);
			return result.join("");
		}
	}
	let lastInput = null;
	let lastOutput = null;
	return function toReversedString$1(str) {
		if (lastInput !== str) {
			lastInput = str;
			lastOutput = reverse(lastInput);
		}
		return lastOutput;
	};
})();
var BracketsUtils = class {
	static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {
		const m = reversedText.match(reversedBracketRegex);
		if (!m) return null;
		const matchOffset = reversedText.length - (m.index || 0);
		const matchLength = m[0].length;
		const absoluteMatchOffset = offset + matchOffset;
		return new Range$1(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);
	}
	static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {
		const reversedSubstr = toReversedString(lineText).substring(lineText.length - endOffset, lineText.length - startOffset);
		return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);
	}
	static findNextBracketInText(bracketRegex, lineNumber, text, offset) {
		const m = text.match(bracketRegex);
		if (!m) return null;
		const matchOffset = m.index || 0;
		const matchLength = m[0].length;
		if (matchLength === 0) return null;
		const absoluteMatchOffset = offset + matchOffset;
		return new Range$1(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);
	}
	static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {
		const substr = lineText.substring(startOffset, endOffset);
		return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js
var BracketElectricCharacterSupport = class {
	constructor(richEditBrackets) {
		this._richEditBrackets = richEditBrackets;
	}
	getElectricCharacters() {
		const result = [];
		if (this._richEditBrackets) for (const bracket of this._richEditBrackets.brackets) for (const close of bracket.close) {
			const lastChar = close.charAt(close.length - 1);
			result.push(lastChar);
		}
		return distinct(result);
	}
	onElectricCharacter(character, context, column) {
		if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) return null;
		const tokenIndex = context.findTokenIndexAtOffset(column - 1);
		if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) return null;
		const reversedBracketRegex = this._richEditBrackets.reversedRegex;
		const text = context.getLineContent().substring(0, column - 1) + character;
		const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);
		if (!r) return null;
		const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();
		if (this._richEditBrackets.textIsOpenBracket[bracketText]) return null;
		const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);
		if (!/^\s*$/.test(textBeforeBracket)) return null;
		return { matchOpenBracket: bracketText };
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js
function resetGlobalRegex(reg) {
	if (reg.global) reg.lastIndex = 0;
	return true;
}
var IndentRulesSupport = class {
	constructor(indentationRules) {
		this._indentationRules = indentationRules;
	}
	shouldIncrease(text) {
		if (this._indentationRules) {
			if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) return true;
		}
		return false;
	}
	shouldDecrease(text) {
		if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) return true;
		return false;
	}
	shouldIndentNextLine(text) {
		if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) return true;
		return false;
	}
	shouldIgnore(text) {
		if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) return true;
		return false;
	}
	getIndentMetadata(text) {
		let ret = 0;
		if (this.shouldIncrease(text)) ret += 1;
		if (this.shouldDecrease(text)) ret += 2;
		if (this.shouldIndentNextLine(text)) ret += 4;
		if (this.shouldIgnore(text)) ret += 8;
		return ret;
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js
var OnEnterSupport = class OnEnterSupport {
	constructor(opts) {
		opts = opts || {};
		opts.brackets = opts.brackets || [
			["(", ")"],
			["{", "}"],
			["[", "]"]
		];
		this._brackets = [];
		opts.brackets.forEach((bracket) => {
			const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);
			const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);
			if (openRegExp && closeRegExp) this._brackets.push({
				open: bracket[0],
				openRegExp,
				close: bracket[1],
				closeRegExp
			});
		});
		this._regExpRules = opts.onEnterRules || [];
	}
	onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {
		if (autoIndent >= 3) for (let i = 0, len = this._regExpRules.length; i < len; i++) {
			const rule = this._regExpRules[i];
			if ([
				{
					reg: rule.beforeText,
					text: beforeEnterText
				},
				{
					reg: rule.afterText,
					text: afterEnterText
				},
				{
					reg: rule.previousLineText,
					text: previousLineText
				}
			].every((obj) => {
				if (!obj.reg) return true;
				obj.reg.lastIndex = 0;
				return obj.reg.test(obj.text);
			})) return rule.action;
		}
		if (autoIndent >= 2) {
			if (beforeEnterText.length > 0 && afterEnterText.length > 0) for (let i = 0, len = this._brackets.length; i < len; i++) {
				const bracket = this._brackets[i];
				if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) return { indentAction: IndentAction.IndentOutdent };
			}
		}
		if (autoIndent >= 2) {
			if (beforeEnterText.length > 0) {
				for (let i = 0, len = this._brackets.length; i < len; i++) if (this._brackets[i].openRegExp.test(beforeEnterText)) return { indentAction: IndentAction.Indent };
			}
		}
		return null;
	}
	static _createOpenBracketRegExp(bracket) {
		let str = escapeRegExpCharacters(bracket);
		if (!/\B/.test(str.charAt(0))) str = "\\b" + str;
		str += "\\s*$";
		return OnEnterSupport._safeRegExp(str);
	}
	static _createCloseBracketRegExp(bracket) {
		let str = escapeRegExpCharacters(bracket);
		if (!/\B/.test(str.charAt(str.length - 1))) str = str + "\\b";
		str = "^\\s*" + str;
		return OnEnterSupport._safeRegExp(str);
	}
	static _safeRegExp(def) {
		try {
			return new RegExp(def);
		} catch (err) {
			onUnexpectedError(err);
			return null;
		}
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/platform/instantiation/common/instantiation.js
var _util;
(function(_util$1) {
	_util$1.serviceIds = /* @__PURE__ */ new Map();
	_util$1.DI_TARGET = "$di$target";
	_util$1.DI_DEPENDENCIES = "$di$dependencies";
	function getServiceDependencies(ctor) {
		return ctor[_util$1.DI_DEPENDENCIES] || [];
	}
	_util$1.getServiceDependencies = getServiceDependencies;
})(_util || (_util = {}));
const IInstantiationService = createDecorator("instantiationService");
function storeServiceDependency(id, target, index) {
	if (target[_util.DI_TARGET] === target) target[_util.DI_DEPENDENCIES].push({
		id,
		index
	});
	else {
		target[_util.DI_DEPENDENCIES] = [{
			id,
			index
		}];
		target[_util.DI_TARGET] = target;
	}
}
/**
* The *only* valid way to create a {{ServiceIdentifier}}.
*/
function createDecorator(serviceId) {
	if (_util.serviceIds.has(serviceId)) return _util.serviceIds.get(serviceId);
	const id = function(target, key, index) {
		if (arguments.length !== 3) throw new Error("@IServiceName-decorator can only be used to decorate a parameter");
		storeServiceDependency(id, target, index);
	};
	id.toString = () => serviceId;
	_util.serviceIds.set(serviceId, id);
	return id;
}

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/platform/configuration/common/configuration.js
const IConfigurationService = createDecorator("configurationService");

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/language.js
const ILanguageService = createDecorator("languageService");

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js
var SyncDescriptor = class {
	constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {
		this.ctor = ctor;
		this.staticArguments = staticArguments;
		this.supportsDelayedInstantiation = supportsDelayedInstantiation;
	}
};

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js
const _registry = [];
function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {
	if (!(ctorOrDescriptor instanceof SyncDescriptor)) ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], supportsDelayedInstantiation);
	_registry.push([id, ctorOrDescriptor]);
}

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js
var __decorate = void 0 && (void 0).__decorate || function(decorators, target, key, desc) {
	var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
	if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
	else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
	return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = void 0 && (void 0).__param || function(paramIndex, decorator) {
	return function(target, key) {
		decorator(target, key, paramIndex);
	};
};
var LanguageConfigurationServiceChangeEvent = class {
	constructor(languageId) {
		this.languageId = languageId;
	}
	affects(languageId) {
		return !this.languageId ? true : this.languageId === languageId;
	}
};
const ILanguageConfigurationService = createDecorator("languageConfigurationService");
let LanguageConfigurationService = class LanguageConfigurationService$1 extends Disposable {
	constructor(configurationService, languageService) {
		super();
		this.configurationService = configurationService;
		this.languageService = languageService;
		this.onDidChangeEmitter = this._register(new Emitter());
		this.onDidChange = this.onDidChangeEmitter.event;
		this.configurations = /* @__PURE__ */ new Map();
		const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));
		this._register(this.configurationService.onDidChangeConfiguration((e) => {
			const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));
			const localConfigChanged = e.change.overrides.filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k))).map(([overrideLangName]) => overrideLangName);
			if (globalConfigChanged) {
				this.configurations.clear();
				this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(void 0));
			} else for (const languageId of localConfigChanged) if (this.languageService.isRegisteredLanguageId(languageId)) {
				this.configurations.delete(languageId);
				this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));
			}
		}));
		this._register(LanguageConfigurationRegistry.onDidChange((e) => {
			this.configurations.delete(e.languageId);
			this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));
		}));
	}
	getLanguageConfiguration(languageId) {
		let result = this.configurations.get(languageId);
		if (!result) {
			result = computeConfig(languageId, this.configurationService, this.languageService);
			this.configurations.set(languageId, result);
		}
		return result;
	}
};
LanguageConfigurationService = __decorate([__param(0, IConfigurationService), __param(1, ILanguageService)], LanguageConfigurationService);
function computeConfig(languageId, configurationService, languageService) {
	let languageConfig = LanguageConfigurationRegistry.getLanguageConfiguration(languageId);
	if (!languageConfig) {
		if (!languageService.isRegisteredLanguageId(languageId)) throw new Error(`Language id "${languageId}" is not configured nor known`);
		languageConfig = new ResolvedLanguageConfiguration(languageId, {});
	}
	const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);
	const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);
	return new ResolvedLanguageConfiguration(languageConfig.languageId, data);
}
const customizedLanguageConfigKeys = {
	brackets: "editor.language.brackets",
	colorizedBracketPairs: "editor.language.colorizedBracketPairs"
};
function getCustomizedLanguageConfig(languageId, configurationService) {
	const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, { overrideIdentifier: languageId });
	const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, { overrideIdentifier: languageId });
	return {
		brackets: validateBracketPairs(brackets),
		colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs)
	};
}
function validateBracketPairs(data) {
	if (!Array.isArray(data)) return;
	return data.map((pair) => {
		if (!Array.isArray(pair) || pair.length !== 2) return;
		return [pair[0], pair[1]];
	}).filter((p) => !!p);
}
var LanguageConfigurationChangeEvent = class {
	constructor(languageId) {
		this.languageId = languageId;
	}
};
var LanguageConfigurationRegistryImpl = class {
	constructor() {
		this._entries = /* @__PURE__ */ new Map();
		this._onDidChange = new Emitter();
		this.onDidChange = this._onDidChange.event;
	}
	/**
	* @param priority Use a higher number for higher priority
	*/
	register(languageId, configuration, priority = 0) {
		let entries = this._entries.get(languageId);
		if (!entries) {
			entries = new ComposedLanguageConfiguration(languageId);
			this._entries.set(languageId, entries);
		}
		const disposable = entries.register(configuration, priority);
		this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));
		return toDisposable(() => {
			disposable.dispose();
			this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));
		});
	}
	getLanguageConfiguration(languageId) {
		const entries = this._entries.get(languageId);
		return (entries === null || entries === void 0 ? void 0 : entries.getResolvedConfiguration()) || null;
	}
	getComments(languageId) {
		const value = this.getLanguageConfiguration(languageId);
		if (!value) return null;
		return value.comments || null;
	}
	getIndentRulesSupport(languageId) {
		const value = this.getLanguageConfiguration(languageId);
		if (!value) return null;
		return value.indentRulesSupport || null;
	}
	/**
	* Get nearest preceding line which doesn't match unIndentPattern or contains all whitespace.
	* Result:
	* -1: run into the boundary of embedded languages
	* 0: every line above are invalid
	* else: nearest preceding line of the same language
	*/
	getPrecedingValidLine(model, lineNumber, indentRulesSupport) {
		const languageId = model.getLanguageIdAtPosition(lineNumber, 0);
		if (lineNumber > 1) {
			let lastLineNumber;
			let resultLineNumber = -1;
			for (lastLineNumber = lineNumber - 1; lastLineNumber >= 1; lastLineNumber--) {
				if (model.getLanguageIdAtPosition(lastLineNumber, 0) !== languageId) return resultLineNumber;
				const text = model.getLineContent(lastLineNumber);
				if (indentRulesSupport.shouldIgnore(text) || /^\s+$/.test(text) || text === "") {
					resultLineNumber = lastLineNumber;
					continue;
				}
				return lastLineNumber;
			}
		}
		return -1;
	}
	/**
	* Get inherited indentation from above lines.
	* 1. Find the nearest preceding line which doesn't match unIndentedLinePattern.
	* 2. If this line matches indentNextLinePattern or increaseIndentPattern, it means that the indent level of `lineNumber` should be 1 greater than this line.
	* 3. If this line doesn't match any indent rules
	*   a. check whether the line above it matches indentNextLinePattern
	*   b. If not, the indent level of this line is the result
	*   c. If so, it means the indent of this line is *temporary*, go upward utill we find a line whose indent is not temporary (the same workflow a -> b -> c).
	* 4. Otherwise, we fail to get an inherited indent from aboves. Return null and we should not touch the indent of `lineNumber`
	*
	* This function only return the inherited indent based on above lines, it doesn't check whether current line should decrease or not.
	*/
	getInheritIndentForLine(autoIndent, model, lineNumber, honorIntentialIndent = true) {
		if (autoIndent < 4) return null;
		const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());
		if (!indentRulesSupport) return null;
		if (lineNumber <= 1) return {
			indentation: "",
			action: null
		};
		const precedingUnIgnoredLine = this.getPrecedingValidLine(model, lineNumber, indentRulesSupport);
		if (precedingUnIgnoredLine < 0) return null;
		else if (precedingUnIgnoredLine < 1) return {
			indentation: "",
			action: null
		};
		const precedingUnIgnoredLineContent = model.getLineContent(precedingUnIgnoredLine);
		if (indentRulesSupport.shouldIncrease(precedingUnIgnoredLineContent) || indentRulesSupport.shouldIndentNextLine(precedingUnIgnoredLineContent)) return {
			indentation: getLeadingWhitespace(precedingUnIgnoredLineContent),
			action: IndentAction.Indent,
			line: precedingUnIgnoredLine
		};
		else if (indentRulesSupport.shouldDecrease(precedingUnIgnoredLineContent)) return {
			indentation: getLeadingWhitespace(precedingUnIgnoredLineContent),
			action: null,
			line: precedingUnIgnoredLine
		};
		else {
			if (precedingUnIgnoredLine === 1) return {
				indentation: getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
				action: null,
				line: precedingUnIgnoredLine
			};
			const previousLine = precedingUnIgnoredLine - 1;
			const previousLineIndentMetadata = indentRulesSupport.getIndentMetadata(model.getLineContent(previousLine));
			if (!(previousLineIndentMetadata & 3) && previousLineIndentMetadata & 4) {
				let stopLine = 0;
				for (let i = previousLine - 1; i > 0; i--) {
					if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) continue;
					stopLine = i;
					break;
				}
				return {
					indentation: getLeadingWhitespace(model.getLineContent(stopLine + 1)),
					action: null,
					line: stopLine + 1
				};
			}
			if (honorIntentialIndent) return {
				indentation: getLeadingWhitespace(model.getLineContent(precedingUnIgnoredLine)),
				action: null,
				line: precedingUnIgnoredLine
			};
			else {
				for (let i = precedingUnIgnoredLine; i > 0; i--) {
					const lineContent = model.getLineContent(i);
					if (indentRulesSupport.shouldIncrease(lineContent)) return {
						indentation: getLeadingWhitespace(lineContent),
						action: IndentAction.Indent,
						line: i
					};
					else if (indentRulesSupport.shouldIndentNextLine(lineContent)) {
						let stopLine = 0;
						for (let j = i - 1; j > 0; j--) {
							if (indentRulesSupport.shouldIndentNextLine(model.getLineContent(i))) continue;
							stopLine = j;
							break;
						}
						return {
							indentation: getLeadingWhitespace(model.getLineContent(stopLine + 1)),
							action: null,
							line: stopLine + 1
						};
					} else if (indentRulesSupport.shouldDecrease(lineContent)) return {
						indentation: getLeadingWhitespace(lineContent),
						action: null,
						line: i
					};
				}
				return {
					indentation: getLeadingWhitespace(model.getLineContent(1)),
					action: null,
					line: 1
				};
			}
		}
	}
	getGoodIndentForLine(autoIndent, virtualModel, languageId, lineNumber, indentConverter) {
		if (autoIndent < 4) return null;
		const richEditSupport = this.getLanguageConfiguration(languageId);
		if (!richEditSupport) return null;
		const indentRulesSupport = this.getIndentRulesSupport(languageId);
		if (!indentRulesSupport) return null;
		const indent = this.getInheritIndentForLine(autoIndent, virtualModel, lineNumber);
		const lineContent = virtualModel.getLineContent(lineNumber);
		if (indent) {
			const inheritLine = indent.line;
			if (inheritLine !== void 0) {
				const enterResult = richEditSupport.onEnter(autoIndent, "", virtualModel.getLineContent(inheritLine), "");
				if (enterResult) {
					let indentation = getLeadingWhitespace(virtualModel.getLineContent(inheritLine));
					if (enterResult.removeText) indentation = indentation.substring(0, indentation.length - enterResult.removeText);
					if (enterResult.indentAction === IndentAction.Indent || enterResult.indentAction === IndentAction.IndentOutdent) indentation = indentConverter.shiftIndent(indentation);
					else if (enterResult.indentAction === IndentAction.Outdent) indentation = indentConverter.unshiftIndent(indentation);
					if (indentRulesSupport.shouldDecrease(lineContent)) indentation = indentConverter.unshiftIndent(indentation);
					if (enterResult.appendText) indentation += enterResult.appendText;
					return getLeadingWhitespace(indentation);
				}
			}
			if (indentRulesSupport.shouldDecrease(lineContent)) if (indent.action === IndentAction.Indent) return indent.indentation;
			else return indentConverter.unshiftIndent(indent.indentation);
			else if (indent.action === IndentAction.Indent) return indentConverter.shiftIndent(indent.indentation);
			else return indent.indentation;
		}
		return null;
	}
	getIndentForEnter(autoIndent, model, range, indentConverter) {
		if (autoIndent < 4) return null;
		model.forceTokenization(range.startLineNumber);
		const lineTokens = model.getLineTokens(range.startLineNumber);
		const scopedLineTokens = createScopedLineTokens(lineTokens, range.startColumn - 1);
		const scopedLineText = scopedLineTokens.getLineContent();
		let embeddedLanguage = false;
		let beforeEnterText;
		if (scopedLineTokens.firstCharOffset > 0 && lineTokens.getLanguageId(0) !== scopedLineTokens.languageId) {
			embeddedLanguage = true;
			beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
		} else beforeEnterText = lineTokens.getLineContent().substring(0, range.startColumn - 1);
		let afterEnterText;
		if (range.isEmpty()) afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
		else afterEnterText = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn).getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
		const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
		if (!indentRulesSupport) return null;
		const beforeEnterResult = beforeEnterText;
		const beforeEnterIndent = getLeadingWhitespace(beforeEnterText);
		const virtualModel = {
			getLineTokens: (lineNumber) => {
				return model.getLineTokens(lineNumber);
			},
			getLanguageId: () => {
				return model.getLanguageId();
			},
			getLanguageIdAtPosition: (lineNumber, column) => {
				return model.getLanguageIdAtPosition(lineNumber, column);
			},
			getLineContent: (lineNumber) => {
				if (lineNumber === range.startLineNumber) return beforeEnterResult;
				else return model.getLineContent(lineNumber);
			}
		};
		const currentLineIndent = getLeadingWhitespace(lineTokens.getLineContent());
		const afterEnterAction = this.getInheritIndentForLine(autoIndent, virtualModel, range.startLineNumber + 1);
		if (!afterEnterAction) {
			const beforeEnter = embeddedLanguage ? currentLineIndent : beforeEnterIndent;
			return {
				beforeEnter,
				afterEnter: beforeEnter
			};
		}
		let afterEnterIndent = embeddedLanguage ? currentLineIndent : afterEnterAction.indentation;
		if (afterEnterAction.action === IndentAction.Indent) afterEnterIndent = indentConverter.shiftIndent(afterEnterIndent);
		if (indentRulesSupport.shouldDecrease(afterEnterText)) afterEnterIndent = indentConverter.unshiftIndent(afterEnterIndent);
		return {
			beforeEnter: embeddedLanguage ? currentLineIndent : beforeEnterIndent,
			afterEnter: afterEnterIndent
		};
	}
	/**
	* We should always allow intentional indentation. It means, if users change the indentation of `lineNumber` and the content of
	* this line doesn't match decreaseIndentPattern, we should not adjust the indentation.
	*/
	getIndentActionForType(autoIndent, model, range, ch, indentConverter) {
		if (autoIndent < 4) return null;
		const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);
		if (scopedLineTokens.firstCharOffset) return null;
		const indentRulesSupport = this.getIndentRulesSupport(scopedLineTokens.languageId);
		if (!indentRulesSupport) return null;
		const scopedLineText = scopedLineTokens.getLineContent();
		const beforeTypeText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
		let afterTypeText;
		if (range.isEmpty()) afterTypeText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
		else afterTypeText = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn).getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
		if (!indentRulesSupport.shouldDecrease(beforeTypeText + afterTypeText) && indentRulesSupport.shouldDecrease(beforeTypeText + ch + afterTypeText)) {
			const r = this.getInheritIndentForLine(autoIndent, model, range.startLineNumber, false);
			if (!r) return null;
			let indentation = r.indentation;
			if (r.action !== IndentAction.Indent) indentation = indentConverter.unshiftIndent(indentation);
			return indentation;
		}
		return null;
	}
	getIndentMetadata(model, lineNumber) {
		const indentRulesSupport = this.getIndentRulesSupport(model.getLanguageId());
		if (!indentRulesSupport) return null;
		if (lineNumber < 1 || lineNumber > model.getLineCount()) return null;
		return indentRulesSupport.getIndentMetadata(model.getLineContent(lineNumber));
	}
	getEnterAction(autoIndent, model, range) {
		const scopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber, range.startColumn);
		const richEditSupport = this.getLanguageConfiguration(scopedLineTokens.languageId);
		if (!richEditSupport) return null;
		const scopedLineText = scopedLineTokens.getLineContent();
		const beforeEnterText = scopedLineText.substr(0, range.startColumn - 1 - scopedLineTokens.firstCharOffset);
		let afterEnterText;
		if (range.isEmpty()) afterEnterText = scopedLineText.substr(range.startColumn - 1 - scopedLineTokens.firstCharOffset);
		else afterEnterText = this.getScopedLineTokens(model, range.endLineNumber, range.endColumn).getLineContent().substr(range.endColumn - 1 - scopedLineTokens.firstCharOffset);
		let previousLineText = "";
		if (range.startLineNumber > 1 && scopedLineTokens.firstCharOffset === 0) {
			const oneLineAboveScopedLineTokens = this.getScopedLineTokens(model, range.startLineNumber - 1);
			if (oneLineAboveScopedLineTokens.languageId === scopedLineTokens.languageId) previousLineText = oneLineAboveScopedLineTokens.getLineContent();
		}
		const enterResult = richEditSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);
		if (!enterResult) return null;
		const indentAction = enterResult.indentAction;
		let appendText = enterResult.appendText;
		const removeText = enterResult.removeText || 0;
		if (!appendText) if (indentAction === IndentAction.Indent || indentAction === IndentAction.IndentOutdent) appendText = "	";
		else appendText = "";
		else if (indentAction === IndentAction.Indent) appendText = "	" + appendText;
		let indentation = this.getIndentationAtPosition(model, range.startLineNumber, range.startColumn);
		if (removeText) indentation = indentation.substring(0, indentation.length - removeText);
		return {
			indentAction,
			appendText,
			removeText,
			indentation
		};
	}
	getIndentationAtPosition(model, lineNumber, column) {
		const lineText = model.getLineContent(lineNumber);
		let indentation = getLeadingWhitespace(lineText);
		if (indentation.length > column - 1) indentation = indentation.substring(0, column - 1);
		return indentation;
	}
	getScopedLineTokens(model, lineNumber, columnNumber) {
		model.forceTokenization(lineNumber);
		return createScopedLineTokens(model.getLineTokens(lineNumber), typeof columnNumber === "undefined" ? model.getLineMaxColumn(lineNumber) - 1 : columnNumber - 1);
	}
};
/**
* @deprecated Use ILanguageConfigurationService instead.
*/
const LanguageConfigurationRegistry = new LanguageConfigurationRegistryImpl();
var ComposedLanguageConfiguration = class {
	constructor(languageId) {
		this.languageId = languageId;
		this._resolved = null;
		this._entries = [];
		this._order = 0;
		this._resolved = null;
	}
	register(configuration, priority) {
		const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);
		this._entries.push(entry);
		this._resolved = null;
		return toDisposable(() => {
			for (let i = 0; i < this._entries.length; i++) if (this._entries[i] === entry) {
				this._entries.splice(i, 1);
				this._resolved = null;
				break;
			}
		});
	}
	getResolvedConfiguration() {
		if (!this._resolved) {
			const config = this._resolve();
			if (config) this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);
		}
		return this._resolved;
	}
	_resolve() {
		if (this._entries.length === 0) return null;
		this._entries.sort(LanguageConfigurationContribution.cmp);
		return combineLanguageConfigurations(this._entries.map((e) => e.configuration));
	}
};
function combineLanguageConfigurations(configs) {
	let result = {
		comments: void 0,
		brackets: void 0,
		wordPattern: void 0,
		indentationRules: void 0,
		onEnterRules: void 0,
		autoClosingPairs: void 0,
		surroundingPairs: void 0,
		autoCloseBefore: void 0,
		folding: void 0,
		colorizedBracketPairs: void 0,
		__electricCharacterSupport: void 0
	};
	for (const entry of configs) result = {
		comments: entry.comments || result.comments,
		brackets: entry.brackets || result.brackets,
		wordPattern: entry.wordPattern || result.wordPattern,
		indentationRules: entry.indentationRules || result.indentationRules,
		onEnterRules: entry.onEnterRules || result.onEnterRules,
		autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,
		surroundingPairs: entry.surroundingPairs || result.surroundingPairs,
		autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,
		folding: entry.folding || result.folding,
		colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,
		__electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport
	};
	return result;
}
var LanguageConfigurationContribution = class {
	constructor(configuration, priority, order) {
		this.configuration = configuration;
		this.priority = priority;
		this.order = order;
	}
	static cmp(a, b) {
		if (a.priority === b.priority) return a.order - b.order;
		return a.priority - b.priority;
	}
};
/**
* Immutable.
*/
var ResolvedLanguageConfiguration = class ResolvedLanguageConfiguration {
	constructor(languageId, underlyingConfig) {
		this.languageId = languageId;
		this.underlyingConfig = underlyingConfig;
		this._brackets = null;
		this._electricCharacter = null;
		this._onEnterSupport = this.underlyingConfig.brackets || this.underlyingConfig.indentationRules || this.underlyingConfig.onEnterRules ? new OnEnterSupport(this.underlyingConfig) : null;
		this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);
		this.characterPair = new CharacterPairSupport(this.underlyingConfig);
		this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;
		this.indentationRules = this.underlyingConfig.indentationRules;
		if (this.underlyingConfig.indentationRules) this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);
		else this.indentRulesSupport = null;
		this.foldingRules = this.underlyingConfig.folding || {};
	}
	getWordDefinition() {
		return ensureValidWordDefinition(this.wordDefinition);
	}
	get brackets() {
		if (!this._brackets && this.underlyingConfig.brackets) this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);
		return this._brackets;
	}
	get electricCharacter() {
		if (!this._electricCharacter) this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);
		return this._electricCharacter;
	}
	onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {
		if (!this._onEnterSupport) return null;
		return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);
	}
	getAutoClosingPairs() {
		return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());
	}
	getAutoCloseBeforeSet() {
		return this.characterPair.getAutoCloseBeforeSet();
	}
	getSurroundingPairs() {
		return this.characterPair.getSurroundingPairs();
	}
	static _handleComments(conf) {
		const commentRule = conf.comments;
		if (!commentRule) return null;
		const comments = {};
		if (commentRule.lineComment) comments.lineCommentToken = commentRule.lineComment;
		if (commentRule.blockComment) {
			const [blockStart, blockEnd] = commentRule.blockComment;
			comments.blockCommentStartToken = blockStart;
			comments.blockCommentEndToken = blockEnd;
		}
		return comments;
	}
};
registerSingleton(ILanguageConfigurationService, LanguageConfigurationService);

//#endregion
//#region node_modules/.pnpm/monaco-editor@0.33.0/node_modules/monaco-editor/esm/vs/editor/common/commands/shiftCommand.js
const repeatCache = Object.create(null);
function cachedStringRepeat(str, count) {
	if (count <= 0) return "";
	if (!repeatCache[str]) repeatCache[str] = ["", str];
	const cache = repeatCache[str];
	for (let i = cache.length; i <= count; i++) cache[i] = cache[i - 1] + str;
	return cache[count];
}
var ShiftCommand = class ShiftCommand {
	constructor(range, opts) {
		this._opts = opts;
		this._selection = range;
		this._selectionId = null;
		this._useLastEditRangeForCursorEndPosition = false;
		this._selectionStartColumnStaysPut = false;
	}
	static unshiftIndent(line, column, tabSize, indentSize, insertSpaces) {
		const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);
		if (insertSpaces) return cachedStringRepeat(cachedStringRepeat(" ", indentSize), CursorColumns.prevIndentTabStop(contentStartVisibleColumn, indentSize) / indentSize);
		else return cachedStringRepeat("	", CursorColumns.prevRenderTabStop(contentStartVisibleColumn, tabSize) / tabSize);
	}
	static shiftIndent(line, column, tabSize, indentSize, insertSpaces) {
		const contentStartVisibleColumn = CursorColumns.visibleColumnFromColumn(line, column, tabSize);
		if (insertSpaces) return cachedStringRepeat(cachedStringRepeat(" ", indentSize), CursorColumns.nextIndentTabStop(contentStartVisibleColumn, indentSize) / indentSize);
		else return cachedStringRepeat("	", CursorColumns.nextRenderTabStop(contentStartVisibleColumn, tabSize) / tabSize);
	}
	_addEditOperation(builder, range, text) {
		if (this._useLastEditRangeForCursorEndPosition) builder.addTrackedEditOperation(range, text);
		else builder.addEditOperation(range, text);
	}
	getEditOperations(model, builder) {
		const startLine = this._selection.startLineNumber;
		let endLine = this._selection.endLineNumber;
		if (this._selection.endColumn === 1 && startLine !== endLine) endLine = endLine - 1;
		const { tabSize, indentSize, insertSpaces } = this._opts;
		const shouldIndentEmptyLines = startLine === endLine;
		if (this._opts.useTabStops) {
			if (this._selection.isEmpty()) {
				if (/^\s*$/.test(model.getLineContent(startLine))) this._useLastEditRangeForCursorEndPosition = true;
			}
			let previousLineExtraSpaces = 0, extraSpaces = 0;
			for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++, previousLineExtraSpaces = extraSpaces) {
				extraSpaces = 0;
				const lineText = model.getLineContent(lineNumber);
				let indentationEndIndex = firstNonWhitespaceIndex(lineText);
				if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) continue;
				if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) continue;
				if (indentationEndIndex === -1) indentationEndIndex = lineText.length;
				if (lineNumber > 1) {
					if (CursorColumns.visibleColumnFromColumn(lineText, indentationEndIndex + 1, tabSize) % indentSize !== 0) {
						if (model.isCheapToTokenize(lineNumber - 1)) {
							const enterAction = LanguageConfigurationRegistry.getEnterAction(this._opts.autoIndent, model, new Range$1(lineNumber - 1, model.getLineMaxColumn(lineNumber - 1), lineNumber - 1, model.getLineMaxColumn(lineNumber - 1)));
							if (enterAction) {
								extraSpaces = previousLineExtraSpaces;
								if (enterAction.appendText) for (let j = 0, lenJ = enterAction.appendText.length; j < lenJ && extraSpaces < indentSize; j++) if (enterAction.appendText.charCodeAt(j) === 32) extraSpaces++;
								else break;
								if (enterAction.removeText) extraSpaces = Math.max(0, extraSpaces - enterAction.removeText);
								for (let j = 0; j < extraSpaces; j++) {
									if (indentationEndIndex === 0 || lineText.charCodeAt(indentationEndIndex - 1) !== 32) break;
									indentationEndIndex--;
								}
							}
						}
					}
				}
				if (this._opts.isUnshift && indentationEndIndex === 0) continue;
				let desiredIndent;
				if (this._opts.isUnshift) desiredIndent = ShiftCommand.unshiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);
				else desiredIndent = ShiftCommand.shiftIndent(lineText, indentationEndIndex + 1, tabSize, indentSize, insertSpaces);
				this._addEditOperation(builder, new Range$1(lineNumber, 1, lineNumber, indentationEndIndex + 1), desiredIndent);
				if (lineNumber === startLine && !this._selection.isEmpty()) this._selectionStartColumnStaysPut = this._selection.startColumn <= indentationEndIndex + 1;
			}
		} else {
			if (!this._opts.isUnshift && this._selection.isEmpty() && model.getLineLength(startLine) === 0) this._useLastEditRangeForCursorEndPosition = true;
			const oneIndent = insertSpaces ? cachedStringRepeat(" ", indentSize) : "	";
			for (let lineNumber = startLine; lineNumber <= endLine; lineNumber++) {
				const lineText = model.getLineContent(lineNumber);
				let indentationEndIndex = firstNonWhitespaceIndex(lineText);
				if (this._opts.isUnshift && (lineText.length === 0 || indentationEndIndex === 0)) continue;
				if (!shouldIndentEmptyLines && !this._opts.isUnshift && lineText.length === 0) continue;
				if (indentationEndIndex === -1) indentationEndIndex = lineText.length;
				if (this._opts.isUnshift && indentationEndIndex === 0) continue;
				if (this._opts.isUnshift) {
					indentationEndIndex = Math.min(indentationEndIndex, indentSize);
					for (let i = 0; i < indentationEndIndex; i++) if (lineText.charCodeAt(i) === 9) {
						indentationEndIndex = i + 1;
						break;
					}
					this._addEditOperation(builder, new Range$1(lineNumber, 1, lineNumber, indentationEndIndex + 1), "");
				} else {
					this._addEditOperation(builder, new Range$1(lineNumber, 1, lineNumber, 1), oneIndent);
					if (lineNumber === startLine && !this._selection.isEmpty()) this._selectionStartColumnStaysPut = this._selection.startColumn === 1;
				}
			}
		}
		this._selectionId = builder.trackSelection(this._selection);
	}
	computeCursorState(model, helper) {
		if (this._useLastEditRangeForCursorEndPosition) {
			const lastOp = helper.getInverseEditOperations()[0];
			return new Selection$1(lastOp.range.endLineNumber, lastOp.range.endColumn, lastOp.range.endLineNumber, lastOp.range.endColumn);
		}
		const result = helper.getTrackedSelection(this._selectionId);
		if (this._selectionStartColumnStaysPut) {
			const initialStartColumn = this._selection.startColumn;
			if (result.startColumn <= initialStartColumn) return result;
			if (result.getDirection() === 0) return new Selection$1(result.startLineNumber, initialStartColumn, result.endLineNumber, result.endColumn);
			return new Selection$1(result.endLineNumber, result.endColumn, result.startLineNumber, initialStartColumn);
		}
		return result;
	}
};

//#endregion
//#region src/cm_adapter.ts
/**
* An adapter to make CodeMirror's vim bindings work with monaco
*/
var _CMAdapter;
const VerticalRevealType = { Bottom: 4 };
const EditorOptConstants = {
	readOnly: 65,
	cursorWidth: 20,
	fontInfo: 32
};
const nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
function isWordCharBasic(ch) {
	return /\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
}
function Pos$1(line, column) {
	if (!(this instanceof Pos$1)) return new Pos$1(line, column);
	this.line = line;
	this.ch = column;
}
function signal(cm, signal$1, args) {
	cm.dispatch(signal$1, args);
}
function dummy(key) {
	return function() {};
}
if (String.prototype.normalize) {}
var StringStream = function(string, tabSize) {
	this.pos = this.start = 0;
	this.string = string;
	this.tabSize = tabSize || 8;
	this.lastColumnPos = this.lastColumnValue = 0;
	this.lineStart = 0;
};
StringStream.prototype = {
	eol: function() {
		return this.pos >= this.string.length;
	},
	sol: function() {
		return this.pos == this.lineStart;
	},
	peek: function() {
		return this.string.charAt(this.pos) || void 0;
	},
	next: function() {
		if (this.pos < this.string.length) return this.string.charAt(this.pos++);
	},
	eat: function(match) {
		var ch = this.string.charAt(this.pos);
		if (typeof match == "string") var ok = ch == match;
		else var ok = ch && (match.test ? match.test(ch) : match(ch));
		if (ok) {
			++this.pos;
			return ch;
		}
	},
	eatWhile: function(match) {
		var start = this.pos;
		while (this.eat(match));
		return this.pos > start;
	},
	eatSpace: function() {
		var start = this.pos;
		while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;
		return this.pos > start;
	},
	skipToEnd: function() {
		this.pos = this.string.length;
	},
	skipTo: function(ch) {
		var found = this.string.indexOf(ch, this.pos);
		if (found > -1) {
			this.pos = found;
			return true;
		}
	},
	backUp: function(n) {
		this.pos -= n;
	},
	column: function() {
		throw "not implemented";
	},
	indentation: function() {
		throw "not implemented";
	},
	match: function(pattern, consume, caseInsensitive) {
		if (typeof pattern == "string") {
			var cased = function(str) {
				return caseInsensitive ? str.toLowerCase() : str;
			};
			if (cased(this.string.substr(this.pos, pattern.length)) == cased(pattern)) {
				if (consume !== false) this.pos += pattern.length;
				return true;
			}
		} else {
			var match = this.string.slice(this.pos).match(pattern);
			if (match && match.index > 0) return null;
			if (match && consume !== false) this.pos += match[0].length;
			return match;
		}
	},
	current: function() {
		return this.string.slice(this.start, this.pos);
	},
	hideFirstChars: function(n, inner) {
		this.lineStart += n;
		try {
			return inner();
		} finally {
			this.lineStart -= n;
		}
	}
};
function toCmPos(pos) {
	return new Pos$1(pos.lineNumber - 1, pos.column - 1);
}
function toMonacoPos(pos) {
	return new monaco_editor_esm_vs_editor_editor_api.Position(pos.line + 1, pos.ch + 1);
}
var Marker = class {
	constructor(cm, id, line, ch) {
		this.cm = cm;
		this.id = id;
		this.lineNumber = line + 1;
		this.column = ch + 1;
		cm.marks[this.id] = this;
	}
	clear() {
		delete this.cm.marks[this.id];
	}
	find() {
		return toCmPos(this);
	}
};
function monacoToCmKey(e, skip = false) {
	let addQuotes = true;
	let keyName = monaco_editor_esm_vs_editor_editor_api.KeyCode[e.keyCode];
	if (e.key) {
		keyName = e.key;
		addQuotes = false;
	}
	let key = keyName;
	let skipOnlyShiftCheck = skip;
	switch (e.keyCode) {
		case monaco_editor_esm_vs_editor_editor_api.KeyCode.Shift:
		case monaco_editor_esm_vs_editor_editor_api.KeyCode.Meta:
		case monaco_editor_esm_vs_editor_editor_api.KeyCode.Alt:
		case monaco_editor_esm_vs_editor_editor_api.KeyCode.Ctrl: return key;
		case monaco_editor_esm_vs_editor_editor_api.KeyCode.Escape:
			skipOnlyShiftCheck = true;
			key = "Esc";
			break;
		case monaco_editor_esm_vs_editor_editor_api.KeyCode.Space:
			skipOnlyShiftCheck = true;
			break;
	}
	if (keyName.startsWith("Key") || keyName.startsWith("KEY_")) key = keyName[keyName.length - 1].toLowerCase();
	else if (keyName.startsWith("Digit")) key = keyName.slice(5, 6);
	else if (keyName.startsWith("Numpad")) key = keyName.slice(6, 7);
	else if (keyName.endsWith("Arrow")) {
		skipOnlyShiftCheck = true;
		key = keyName.substring(0, keyName.length - 5);
	} else if (keyName.startsWith("US_") || keyName.startsWith("Bracket") || !key) key = e.browserEvent.key;
	if (!skipOnlyShiftCheck && !e.altKey && !e.ctrlKey && !e.metaKey) key = e.key || e.browserEvent.key;
	else {
		if (e.altKey) key = `Alt-${key}`;
		if (e.ctrlKey) key = `Ctrl-${key}`;
		if (e.metaKey) key = `Meta-${key}`;
		if (e.shiftKey) key = `Shift-${key}`;
	}
	if (key.length === 1 && addQuotes) key = `'${key}'`;
	return key;
}
var CMAdapter = class CMAdapter {
	constructor(editor) {
		this.handleKeyDown = (e) => {
			if (e.browserEvent.defaultPrevented & e.keyCode !== monaco_editor_esm_vs_editor_editor_api.KeyCode.Escape) return;
			if (!this.attached) return;
			const key = monacoToCmKey(e);
			if (this.replaceMode) this.handleReplaceMode(key, e);
			if (!key) return;
			const keymap = this.state.keyMap;
			if (CMAdapter.keyMap[keymap] && CMAdapter.keyMap[keymap].call) {
				const cmd = CMAdapter.keyMap[keymap].call(key, this);
				if (cmd) {
					e.preventDefault();
					e.stopPropagation();
					try {
						cmd();
					} catch (err) {
						console.error(err);
					}
				}
			}
		};
		this.handleCursorChange = (e) => {
			const { position, source } = e;
			const { editor: editor$1 } = this;
			const selection = editor$1.getSelection();
			if (!this.ctxInsert.get() && e.source === "mouse" && selection.isEmpty()) {
				const maxCol = editor$1.getModel().getLineMaxColumn(position.lineNumber);
				if (e.position.column === maxCol) {
					editor$1.setPosition(new monaco_editor_esm_vs_editor_editor_api.Position(e.position.lineNumber, maxCol - 1));
					return;
				}
			}
			this.dispatch("cursorActivity", this, e);
		};
		this.handleChange = (e) => {
			const { changes } = e;
			const change = {
				text: changes.reduce((acc, change$1) => {
					acc.push(change$1.text);
					return acc;
				}, []),
				origin: "+input"
			};
			const curOp = this.curOp = this.curOp || {};
			if (!curOp.changeHandlers) curOp.changeHandlers = this.listeners["change"] && this.listeners["change"].slice();
			if (this.virtualSelectionMode()) return;
			if (!curOp.lastChange) curOp.lastChange = curOp.change = change;
			else curOp.lastChange.next = curOp.lastChange = change;
			this.dispatch("change", this, change);
		};
		this.editor = editor;
		this.state = { keyMap: "vim" };
		this.marks = {};
		this.$uid = 0;
		this.disposables = [];
		this.listeners = {};
		this.curOp = {};
		this.attached = false;
		this.statusBar = null;
		this.options = {};
		this.addLocalListeners();
		this.ctxInsert = this.editor.createContextKey("insertMode", true);
	}
	attach() {
		CMAdapter.keyMap.vim.attach(this);
	}
	addLocalListeners() {
		this.disposables.push(this.editor.onDidChangeCursorPosition(this.handleCursorChange), this.editor.onDidChangeModelContent(this.handleChange), this.editor.onKeyDown(this.handleKeyDown));
	}
	handleReplaceMode(key, e) {
		let fromReplace = false;
		let char = key;
		const pos = this.editor.getPosition();
		let range = new monaco_editor_esm_vs_editor_editor_api.Range(pos.lineNumber, pos.column, pos.lineNumber, pos.column + 1);
		let forceMoveMarkers = true;
		if (key.startsWith("'")) char = key[1];
		else if (char === "Enter") char = "\n";
		else if (char === "Backspace") {
			const lastItem = this.replaceStack.pop();
			if (!lastItem) return;
			fromReplace = true;
			char = lastItem;
			range = new monaco_editor_esm_vs_editor_editor_api.Range(pos.lineNumber, pos.column, pos.lineNumber, pos.column - 1);
		} else return;
		e.preventDefault();
		e.stopPropagation();
		if (!this.replaceStack) this.replaceStack = [];
		if (!fromReplace) this.replaceStack.push(this.editor.getModel().getValueInRange(range));
		this.editor.executeEdits("vim", [{
			text: char,
			range,
			forceMoveMarkers
		}]);
		if (fromReplace) this.editor.setPosition(range.getStartPosition());
	}
	setOption(key, value) {
		this.state[key] = value;
		if (key === "theme") monaco_editor_esm_vs_editor_editor_api.editor.setTheme(value);
	}
	getConfiguration() {
		const { editor } = this;
		let opts = EditorOptConstants;
		if (typeof editor.getConfiguration === "function") return editor.getConfiguration();
		else if ("EditorOption" in monaco_editor_esm_vs_editor_editor_api.editor) opts = monaco_editor_esm_vs_editor_editor_api.editor.EditorOption;
		return {
			readOnly: editor.getOption(opts.readOnly),
			viewInfo: { cursorWidth: editor.getOption(opts.cursorWidth) },
			fontInfo: editor.getOption(opts.fontInfo)
		};
	}
	getOption(key) {
		if (key === "readOnly") return this.getConfiguration().readOnly;
		else if (key === "firstLineNumber") return this.firstLine() + 1;
		else if (key === "indentWithTabs") return !this.editor.getModel().getOptions().insertSpaces;
		else {
			if (typeof this.editor.getConfiguration === "function") return this.editor.getRawConfiguration()[key];
			return this.editor.getRawOptions()[key];
		}
	}
	dispatch(signal$1, ...args) {
		const listeners = this.listeners[signal$1];
		if (!listeners) return;
		listeners.forEach((handler) => handler(...args));
	}
	on(event, handler) {
		if (!this.listeners[event]) this.listeners[event] = [];
		this.listeners[event].push(handler);
	}
	off(event, handler) {
		const listeners = this.listeners[event];
		if (!listeners) return;
		this.listeners[event] = listeners.filter((l) => l !== handler);
	}
	firstLine() {
		return 0;
	}
	lastLine() {
		return this.lineCount() - 1;
	}
	lineCount() {
		return this.editor.getModel().getLineCount();
	}
	defaultTextHeight() {
		return 1;
	}
	getLine(line) {
		if (line < 0) return "";
		const maxLines = this.editor.getModel().getLineCount();
		if (line + 1 > maxLines) line = maxLines - 1;
		return this.editor.getModel().getLineContent(line + 1);
	}
	getAnchorForSelection(selection) {
		if (selection.isEmpty()) return selection.getPosition();
		return selection.getDirection() === monaco_editor_esm_vs_editor_editor_api.SelectionDirection.LTR ? selection.getStartPosition() : selection.getEndPosition();
	}
	getHeadForSelection(selection) {
		if (selection.isEmpty()) return selection.getPosition();
		return selection.getDirection() === monaco_editor_esm_vs_editor_editor_api.SelectionDirection.LTR ? selection.getEndPosition() : selection.getStartPosition();
	}
	getCursor(type = null) {
		if (!type) return toCmPos(this.editor.getPosition());
		const sel = this.editor.getSelection();
		let pos;
		if (sel.isEmpty()) pos = sel.getPosition();
		else if (type === "anchor") pos = this.getAnchorForSelection(sel);
		else pos = this.getHeadForSelection(sel);
		return toCmPos(pos);
	}
	getRange(start, end) {
		const p1 = toMonacoPos(start);
		const p2 = toMonacoPos(end);
		return this.editor.getModel().getValueInRange(monaco_editor_esm_vs_editor_editor_api.Range.fromPositions(p1, p2));
	}
	getSelection() {
		var list = [];
		var editor = this.editor;
		editor.getSelections().map(function(sel) {
			list.push(editor.getModel().getValueInRange(sel));
		});
		return list.join("\n");
	}
	replaceRange(text, start, end) {
		const p1 = toMonacoPos(start);
		const p2 = !end ? p1 : toMonacoPos(end);
		this.editor.executeEdits("vim", [{
			text,
			range: monaco_editor_esm_vs_editor_editor_api.Range.fromPositions(p1, p2)
		}]);
		this.pushUndoStop();
	}
	pushUndoStop() {
		this.editor.pushUndoStop();
	}
	setCursor(line, ch) {
		let pos = line;
		if (typeof line !== "object") {
			pos = {};
			pos.line = line;
			pos.ch = ch;
		}
		const monacoPos = this.editor.getModel().validatePosition(toMonacoPos(pos));
		this.editor.setPosition(toMonacoPos(pos));
		this.editor.revealPosition(monacoPos);
	}
	somethingSelected() {
		return !this.editor.getSelection().isEmpty();
	}
	operation(fn, force) {
		return fn();
	}
	listSelections() {
		const selections = this.editor.getSelections();
		if (!selections.length || this.inVirtualSelectionMode) return [{
			anchor: this.getCursor("anchor"),
			head: this.getCursor("head")
		}];
		return selections.map((sel) => {
			sel.getPosition();
			sel.getStartPosition();
			sel.getEndPosition();
			return {
				anchor: this.clipPos(toCmPos(this.getAnchorForSelection(sel))),
				head: this.clipPos(toCmPos(this.getHeadForSelection(sel)))
			};
		});
	}
	focus() {
		this.editor.focus();
	}
	setSelections(selections, primIndex) {
		const hasSel = !!this.editor.getSelections().length;
		const sels = selections.map((sel$1, index) => {
			const { anchor, head } = sel$1;
			if (hasSel) return monaco_editor_esm_vs_editor_editor_api.Selection.fromPositions(toMonacoPos(anchor), toMonacoPos(head));
			else return monaco_editor_esm_vs_editor_editor_api.Selection.fromPositions(toMonacoPos(head), toMonacoPos(anchor));
		});
		if (!primIndex) {} else if (sels[primIndex]) sels.push(sels.splice(primIndex, 1)[0]);
		if (!sels.length) return;
		const sel = sels[0];
		let posToReveal;
		if (sel.getDirection() === monaco_editor_esm_vs_editor_editor_api.SelectionDirection.LTR) posToReveal = sel.getEndPosition();
		else posToReveal = sel.getStartPosition();
		this.editor.setSelections(sels);
		this.editor.revealPosition(posToReveal);
	}
	setSelection(frm, to) {
		const range = monaco_editor_esm_vs_editor_editor_api.Range.fromPositions(toMonacoPos(frm), toMonacoPos(to));
		this.editor.setSelection(range);
	}
	getSelections() {
		const { editor } = this;
		return editor.getSelections().map((sel) => editor.getModel().getValueInRange(sel));
	}
	replaceSelections(texts) {
		const { editor } = this;
		editor.getSelections().forEach((sel, index) => {
			editor.executeEdits("vim", [{
				range: sel,
				text: texts[index],
				forceMoveMarkers: false
			}]);
		});
	}
	toggleOverwrite(toggle) {
		if (toggle) {
			this.enterVimMode();
			this.replaceMode = true;
		} else {
			this.leaveVimMode();
			this.replaceMode = false;
			this.replaceStack = [];
		}
	}
	charCoords(pos, mode) {
		return {
			top: pos.line,
			left: pos.ch
		};
	}
	coordsChar(pos, mode) {
		if (mode === "local") {}
	}
	clipPos(p) {
		return toCmPos(this.editor.getModel().validatePosition(toMonacoPos(p)));
	}
	setBookmark(cursor, options) {
		const bm = new Marker(this, this.$uid++, cursor.line, cursor.ch);
		if (!options || !options.insertLeft) bm.$insertRight = true;
		this.marks[bm.id] = bm;
		return bm;
	}
	getScrollInfo() {
		const { editor } = this;
		const [range] = editor.getVisibleRanges();
		return {
			left: 0,
			top: range.startLineNumber - 1,
			height: editor.getModel().getLineCount(),
			clientHeight: range.endLineNumber - range.startLineNumber + 1
		};
	}
	triggerEditorAction(action) {
		this.editor.trigger("vim", action);
	}
	dispose() {
		this.dispatch("dispose");
		this.removeOverlay();
		if (CMAdapter.keyMap.vim) CMAdapter.keyMap.vim.detach(this);
		this.disposables.forEach((d) => d.dispose());
	}
	getInputField() {}
	getWrapperElement() {}
	enterVimMode(toVim = true) {
		this.ctxInsert.set(false);
		const config = this.getConfiguration();
		this.initialCursorWidth = config.viewInfo.cursorWidth || 0;
		this.editor.updateOptions({
			cursorWidth: config.fontInfo.typicalFullwidthCharacterWidth,
			cursorBlinking: "solid",
			cursorStyle: "block"
		});
	}
	leaveVimMode() {
		this.ctxInsert.set(true);
		this.editor.updateOptions({
			cursorWidth: this.initialCursorWidth || 0,
			cursorBlinking: "blink",
			cursorStyle: "line"
		});
	}
	virtualSelectionMode() {
		return this.inVirtualSelectionMode;
	}
	markText() {
		return {
			clear: function() {},
			find: function() {}
		};
	}
	getUserVisibleLines() {
		const ranges = this.editor.getVisibleRanges();
		if (!ranges.length) return {
			top: 0,
			bottom: 0
		};
		const res = {
			top: Infinity,
			bottom: 0
		};
		ranges.reduce((acc, range) => {
			if (range.startLineNumber < acc.top) acc.top = range.startLineNumber;
			if (range.endLineNumber > acc.bottom) acc.bottom = range.endLineNumber;
			return acc;
		}, res);
		res.top -= 1;
		res.bottom -= 1;
		return res;
	}
	findPosV(startPos, amount, unit) {
		const { editor } = this;
		let finalAmount = amount;
		let finalUnit = unit;
		const pos = toMonacoPos(startPos);
		if (unit === "page") {
			const editorHeight = editor.getLayoutInfo().height;
			const lineHeight = this.getConfiguration().fontInfo.lineHeight;
			finalAmount = finalAmount * Math.floor(editorHeight / lineHeight);
			finalUnit = "line";
		}
		if (finalUnit === "line") pos.lineNumber += finalAmount;
		return toCmPos(pos);
	}
	findMatchingBracket(pos) {
		const mPos = toMonacoPos(pos);
		const model = this.editor.getModel();
		let res;
		if (model.bracketPairs) res = model.bracketPairs.matchBracket(mPos);
		else {
			var _model$matchBracket;
			res = (_model$matchBracket = model.matchBracket) === null || _model$matchBracket === void 0 ? void 0 : _model$matchBracket.call(model, mPos);
		}
		if (!res || !(res.length === 2)) return { to: null };
		return { to: toCmPos(res[1].getStartPosition()) };
	}
	findFirstNonWhiteSpaceCharacter(line) {
		return this.editor.getModel().getLineFirstNonWhitespaceColumn(line + 1) - 1;
	}
	scrollTo(x, y) {
		if (!x && !y) return;
		if (!x) {
			if (y < 0) y = this.editor.getPosition().lineNumber - y;
			this.editor.setScrollTop(this.editor.getTopForLineNumber(y + 1));
		}
	}
	moveCurrentLineTo(viewPosition) {
		const { editor } = this;
		const pos = editor.getPosition();
		const range = monaco_editor_esm_vs_editor_editor_api.Range.fromPositions(pos, pos);
		switch (viewPosition) {
			case "top":
				editor.revealRangeAtTop(range);
				return;
			case "center":
				editor.revealRangeInCenter(range);
				return;
			case "bottom":
				var _editor$_revealRange;
				(_editor$_revealRange = editor._revealRange) === null || _editor$_revealRange === void 0 || _editor$_revealRange.call(editor, range, VerticalRevealType.Bottom);
				return;
		}
	}
	getSearchCursor(query, pos) {
		let matchCase = false;
		let isRegex = false;
		if (query instanceof RegExp && !query.global) {
			matchCase = !query.ignoreCase;
			query = query.source;
			isRegex = true;
		}
		if (pos.ch == void 0) pos.ch = Number.MAX_VALUE;
		const monacoPos = toMonacoPos(pos);
		const context = this;
		const { editor } = this;
		let lastSearch = null;
		const model = editor.getModel();
		const matches = model.findMatches(query, false, isRegex, matchCase) || [];
		return {
			getMatches() {
				return matches;
			},
			findNext() {
				return this.find(false);
			},
			findPrevious() {
				return this.find(true);
			},
			jumpTo(index) {
				if (!matches || !matches.length) return false;
				lastSearch = matches[index].range;
				context.highlightRanges([lastSearch], "currentFindMatch");
				context.highlightRanges(matches.map((m) => m.range).filter((r) => !r.equalsRange(lastSearch)));
				return lastSearch;
			},
			find(back) {
				if (!matches || !matches.length) return false;
				let match;
				if (back) {
					const pos$1 = lastSearch ? lastSearch.getStartPosition() : monacoPos;
					match = model.findPreviousMatch(query, pos$1, isRegex, matchCase);
					if (!match || !match.range.getStartPosition().isBeforeOrEqual(pos$1)) return false;
				} else {
					const pos$1 = lastSearch ? model.getPositionAt(model.getOffsetAt(lastSearch.getEndPosition()) + 1) : monacoPos;
					match = model.findNextMatch(query, pos$1, isRegex, matchCase);
					if (!match || !pos$1.isBeforeOrEqual(match.range.getStartPosition())) return false;
				}
				lastSearch = match.range;
				context.highlightRanges([lastSearch], "currentFindMatch");
				context.highlightRanges(matches.map((m) => m.range).filter((r) => !r.equalsRange(lastSearch)));
				return lastSearch;
			},
			from() {
				return lastSearch && toCmPos(lastSearch.getStartPosition());
			},
			to() {
				return lastSearch && toCmPos(lastSearch.getEndPosition());
			},
			replace(text) {
				if (lastSearch) {
					editor.executeEdits("vim", [{
						range: lastSearch,
						text,
						forceMoveMarkers: true
					}], function(edits) {
						const { endLineNumber, endColumn } = edits[0].range;
						lastSearch = lastSearch.setEndPosition(endLineNumber, endColumn);
					});
					editor.setPosition(lastSearch.getStartPosition());
				}
			}
		};
	}
	highlightRanges(ranges, className = "findMatch") {
		const decorationKey = `decoration${className}`;
		this[decorationKey] = this.editor.deltaDecorations(this[decorationKey] || [], ranges.map((range) => ({
			range,
			options: {
				stickiness: monaco_editor_esm_vs_editor_editor_api.editor.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges,
				zIndex: 13,
				className,
				showIfCollapsed: true
			}
		})));
		return this[decorationKey];
	}
	addOverlay({ query }, hasBoundary, style) {
		let matchCase = false;
		let isRegex = false;
		if (query && query instanceof RegExp && !query.global) {
			isRegex = true;
			matchCase = !query.ignoreCase;
			query = query.source;
		}
		const match = this.editor.getModel().findNextMatch(query, this.editor.getPosition(), isRegex, matchCase);
		if (!match || !match.range) return;
		this.highlightRanges([match.range]);
	}
	removeOverlay() {
		["currentFindMatch", "findMatch"].forEach((key) => {
			this.editor.deltaDecorations(this[`decoration${key}`] || [], []);
		});
	}
	scrollIntoView(pos) {
		if (!pos) return;
		this.editor.revealPosition(toMonacoPos(pos));
	}
	moveH(units, type) {
		if (type !== "char") return;
		const pos = this.editor.getPosition();
		this.editor.setPosition(new monaco_editor_esm_vs_editor_editor_api.Position(pos.lineNumber, pos.column + units));
	}
	scanForBracket(pos, dir, dd, config) {
		const { bracketRegex } = config;
		let mPos = toMonacoPos(pos);
		const model = this.editor.getModel();
		const searchFunc = (dir === -1 ? model.findPreviousMatch : model.findNextMatch).bind(model);
		const stack = [];
		let iterations = 0;
		while (true) {
			if (iterations > 10) return;
			const match = searchFunc(bracketRegex.source, mPos, true, true, null, true);
			const thisBracket = match.matches[0];
			if (match === void 0) return;
			const matchingBracket = CMAdapter.matchingBrackets[thisBracket];
			if (matchingBracket && matchingBracket.charAt(1) === ">" == dir > 0) stack.push(thisBracket);
			else if (stack.length === 0) return { pos: toCmPos(match.range.getStartPosition()) };
			else stack.pop();
			mPos = model.getPositionAt(model.getOffsetAt(match.range.getStartPosition()) + dir);
			iterations += 1;
		}
	}
	indexFromPos(pos) {
		return this.editor.getModel().getOffsetAt(toMonacoPos(pos));
	}
	posFromIndex(offset) {
		return toCmPos(this.editor.getModel().getPositionAt(offset));
	}
	indentLine(line, indentRight = true) {
		const { editor } = this;
		let cursorConfig;
		if (editor._getViewModel) cursorConfig = editor._getViewModel().cursorConfig;
		else cursorConfig = editor._getCursors().context.config;
		const pos = new monaco_editor_esm_vs_editor_editor_api.Position(line + 1, 1);
		const sel = monaco_editor_esm_vs_editor_editor_api.Selection.fromPositions(pos, pos);
		editor.executeCommand("vim", new ShiftCommand(sel, {
			isUnshift: !indentRight,
			tabSize: cursorConfig.tabSize,
			indentSize: cursorConfig.indentSize,
			insertSpaces: cursorConfig.insertSpaces,
			useTabStops: cursorConfig.useTabStops,
			autoIndent: cursorConfig.autoIndent
		}));
	}
	setStatusBar(statusBar) {
		this.statusBar = statusBar;
	}
	openDialog(html, callback, options) {
		if (!this.statusBar) return;
		return this.statusBar.setSec(html, callback, options);
	}
	openNotification(html) {
		if (!this.statusBar) return;
		this.statusBar.showNotification(html);
	}
	smartIndent() {
		this.editor.getAction("editor.action.formatSelection").run();
	}
	moveCursorTo(to) {
		const newPos = this.editor.getPosition();
		if (to === "start") newPos.column = 1;
		else if (to === "end") newPos.column = this.editor.getModel().getLineMaxColumn(newPos.lineNumber);
		this.editor.setPosition(newPos);
	}
	execCommand(command) {
		switch (command) {
			case "goLineLeft":
				this.moveCursorTo("start");
				break;
			case "goLineRight":
				this.moveCursorTo("end");
				break;
			case "indentAuto":
				this.smartIndent();
				break;
		}
	}
};
_CMAdapter = CMAdapter;
CMAdapter.Pos = Pos$1;
CMAdapter.signal = signal;
CMAdapter.on = dummy("on");
CMAdapter.off = dummy("off");
CMAdapter.addClass = dummy("addClass");
CMAdapter.rmClass = dummy("rmClass");
CMAdapter.defineOption = dummy("defineOption");
CMAdapter.keyMap = { default: function(key) {
	return function(cm) {
		return true;
	};
} };
CMAdapter.matchingBrackets = {
	"(": ")>",
	")": "(<",
	"[": "]>",
	"]": "[<",
	"{": "}>",
	"}": "{<",
	"<": ">>",
	">": "<<"
};
CMAdapter.isWordChar = isWordCharBasic;
CMAdapter.keyName = monacoToCmKey;
CMAdapter.StringStream = StringStream;
CMAdapter.e_stop = function(e) {
	if (e.stopPropagation) e.stopPropagation();
	else e.cancelBubble = true;
	_CMAdapter.e_preventDefault(e);
	return false;
};
CMAdapter.e_preventDefault = function(e) {
	if (e.preventDefault) {
		e.preventDefault();
		if (e.browserEvent) e.browserEvent.preventDefault();
	} else e.returnValue = false;
	return false;
};
CMAdapter.commands = {
	redo: function(cm) {
		cm.editor.getModel().redo();
	},
	undo: function(cm) {
		cm.editor.getModel().undo();
	},
	newlineAndIndent: function(cm) {
		cm.triggerEditorAction("editor.action.insertLineAfter");
	}
};
CMAdapter.lookupKey = function lookupKey(key, map, handle) {
	if (typeof map === "string") map = _CMAdapter.keyMap[map];
	const found = typeof map == "function" ? map(key) : map[key];
	if (found === false) return "nothing";
	if (found === "...") return "multi";
	if (found != null && handle(found)) return "handled";
	if (map.fallthrough) {
		if (!Array.isArray(map.fallthrough)) return lookupKey(key, map.fallthrough, handle);
		for (var i = 0; i < map.fallthrough.length; i++) {
			var result = lookupKey(key, map.fallthrough[i], handle);
			if (result) return result;
		}
	}
};
CMAdapter.defineExtension = function(name, fn) {
	_CMAdapter.prototype[name] = fn;
};
var cm_adapter_default = CMAdapter;

//#endregion
//#region src/cm/keymap_vim.ts
/**
MIT License

Copyright (C) 2017 by Marijn Haverbeke <marijnh@gmail.com> and others

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/
var Pos = cm_adapter_default.Pos;
function transformCursor(cm, range) {
	var vim = cm.state.vim;
	if (!vim || vim.insertMode) return range.head;
	var head = vim.sel.head;
	if (!head) return range.head;
	if (vim.visualBlock) {
		if (range.head.line != head.line) return;
	}
	if (range.from() == range.anchor && !range.empty()) {
		if (range.head.line == head.line && range.head.ch != head.ch) return new Pos(range.head.line, range.head.ch - 1);
	}
	return range.head;
}
var defaultKeymap = [
	{
		keys: "<Left>",
		type: "keyToKey",
		toKeys: "h"
	},
	{
		keys: "<Right>",
		type: "keyToKey",
		toKeys: "l"
	},
	{
		keys: "<Up>",
		type: "keyToKey",
		toKeys: "k"
	},
	{
		keys: "<Down>",
		type: "keyToKey",
		toKeys: "j"
	},
	{
		keys: "g<Up>",
		type: "keyToKey",
		toKeys: "gk"
	},
	{
		keys: "g<Down>",
		type: "keyToKey",
		toKeys: "gj"
	},
	{
		keys: "<Space>",
		type: "keyToKey",
		toKeys: "l"
	},
	{
		keys: "<BS>",
		type: "keyToKey",
		toKeys: "h",
		context: "normal"
	},
	{
		keys: "<Del>",
		type: "keyToKey",
		toKeys: "x",
		context: "normal"
	},
	{
		keys: "<C-Space>",
		type: "keyToKey",
		toKeys: "W"
	},
	{
		keys: "<C-BS>",
		type: "keyToKey",
		toKeys: "B",
		context: "normal"
	},
	{
		keys: "<S-Space>",
		type: "keyToKey",
		toKeys: "w"
	},
	{
		keys: "<S-BS>",
		type: "keyToKey",
		toKeys: "b",
		context: "normal"
	},
	{
		keys: "<C-n>",
		type: "keyToKey",
		toKeys: "j"
	},
	{
		keys: "<C-p>",
		type: "keyToKey",
		toKeys: "k"
	},
	{
		keys: "<C-[>",
		type: "keyToKey",
		toKeys: "<Esc>"
	},
	{
		keys: "<C-c>",
		type: "keyToKey",
		toKeys: "<Esc>"
	},
	{
		keys: "<C-[>",
		type: "keyToKey",
		toKeys: "<Esc>",
		context: "insert"
	},
	{
		keys: "<C-c>",
		type: "keyToKey",
		toKeys: "<Esc>",
		context: "insert"
	},
	{
		keys: "s",
		type: "keyToKey",
		toKeys: "cl",
		context: "normal"
	},
	{
		keys: "s",
		type: "keyToKey",
		toKeys: "c",
		context: "visual"
	},
	{
		keys: "S",
		type: "keyToKey",
		toKeys: "cc",
		context: "normal"
	},
	{
		keys: "S",
		type: "keyToKey",
		toKeys: "VdO",
		context: "visual"
	},
	{
		keys: "<Home>",
		type: "keyToKey",
		toKeys: "0"
	},
	{
		keys: "<End>",
		type: "keyToKey",
		toKeys: "$"
	},
	{
		keys: "<PageUp>",
		type: "keyToKey",
		toKeys: "<C-b>"
	},
	{
		keys: "<PageDown>",
		type: "keyToKey",
		toKeys: "<C-f>"
	},
	{
		keys: "<CR>",
		type: "keyToKey",
		toKeys: "j^",
		context: "normal"
	},
	{
		keys: "<Ins>",
		type: "keyToKey",
		toKeys: "i",
		context: "normal"
	},
	{
		keys: "<Ins>",
		type: "action",
		action: "toggleOverwrite",
		context: "insert"
	},
	{
		keys: "H",
		type: "motion",
		motion: "moveToTopLine",
		motionArgs: {
			linewise: true,
			toJumplist: true
		}
	},
	{
		keys: "M",
		type: "motion",
		motion: "moveToMiddleLine",
		motionArgs: {
			linewise: true,
			toJumplist: true
		}
	},
	{
		keys: "L",
		type: "motion",
		motion: "moveToBottomLine",
		motionArgs: {
			linewise: true,
			toJumplist: true
		}
	},
	{
		keys: "h",
		type: "motion",
		motion: "moveByCharacters",
		motionArgs: { forward: false }
	},
	{
		keys: "l",
		type: "motion",
		motion: "moveByCharacters",
		motionArgs: { forward: true }
	},
	{
		keys: "j",
		type: "motion",
		motion: "moveByLines",
		motionArgs: {
			forward: true,
			linewise: true
		}
	},
	{
		keys: "k",
		type: "motion",
		motion: "moveByLines",
		motionArgs: {
			forward: false,
			linewise: true
		}
	},
	{
		keys: "gj",
		type: "motion",
		motion: "moveByDisplayLines",
		motionArgs: { forward: true }
	},
	{
		keys: "gk",
		type: "motion",
		motion: "moveByDisplayLines",
		motionArgs: { forward: false }
	},
	{
		keys: "w",
		type: "motion",
		motion: "moveByWords",
		motionArgs: {
			forward: true,
			wordEnd: false
		}
	},
	{
		keys: "W",
		type: "motion",
		motion: "moveByWords",
		motionArgs: {
			forward: true,
			wordEnd: false,
			bigWord: true
		}
	},
	{
		keys: "e",
		type: "motion",
		motion: "moveByWords",
		motionArgs: {
			forward: true,
			wordEnd: true,
			inclusive: true
		}
	},
	{
		keys: "E",
		type: "motion",
		motion: "moveByWords",
		motionArgs: {
			forward: true,
			wordEnd: true,
			bigWord: true,
			inclusive: true
		}
	},
	{
		keys: "b",
		type: "motion",
		motion: "moveByWords",
		motionArgs: {
			forward: false,
			wordEnd: false
		}
	},
	{
		keys: "B",
		type: "motion",
		motion: "moveByWords",
		motionArgs: {
			forward: false,
			wordEnd: false,
			bigWord: true
		}
	},
	{
		keys: "ge",
		type: "motion",
		motion: "moveByWords",
		motionArgs: {
			forward: false,
			wordEnd: true,
			inclusive: true
		}
	},
	{
		keys: "gE",
		type: "motion",
		motion: "moveByWords",
		motionArgs: {
			forward: false,
			wordEnd: true,
			bigWord: true,
			inclusive: true
		}
	},
	{
		keys: "{",
		type: "motion",
		motion: "moveByParagraph",
		motionArgs: {
			forward: false,
			toJumplist: true
		}
	},
	{
		keys: "}",
		type: "motion",
		motion: "moveByParagraph",
		motionArgs: {
			forward: true,
			toJumplist: true
		}
	},
	{
		keys: "(",
		type: "motion",
		motion: "moveBySentence",
		motionArgs: { forward: false }
	},
	{
		keys: ")",
		type: "motion",
		motion: "moveBySentence",
		motionArgs: { forward: true }
	},
	{
		keys: "<C-f>",
		type: "motion",
		motion: "moveByPage",
		motionArgs: { forward: true }
	},
	{
		keys: "<C-b>",
		type: "motion",
		motion: "moveByPage",
		motionArgs: { forward: false }
	},
	{
		keys: "<C-d>",
		type: "motion",
		motion: "moveByScroll",
		motionArgs: {
			forward: true,
			explicitRepeat: true
		}
	},
	{
		keys: "<C-u>",
		type: "motion",
		motion: "moveByScroll",
		motionArgs: {
			forward: false,
			explicitRepeat: true
		}
	},
	{
		keys: "gg",
		type: "motion",
		motion: "moveToLineOrEdgeOfDocument",
		motionArgs: {
			forward: false,
			explicitRepeat: true,
			linewise: true,
			toJumplist: true
		}
	},
	{
		keys: "G",
		type: "motion",
		motion: "moveToLineOrEdgeOfDocument",
		motionArgs: {
			forward: true,
			explicitRepeat: true,
			linewise: true,
			toJumplist: true
		}
	},
	{
		keys: "g$",
		type: "motion",
		motion: "moveToEndOfDisplayLine"
	},
	{
		keys: "g^",
		type: "motion",
		motion: "moveToStartOfDisplayLine"
	},
	{
		keys: "g0",
		type: "motion",
		motion: "moveToStartOfDisplayLine"
	},
	{
		keys: "0",
		type: "motion",
		motion: "moveToStartOfLine"
	},
	{
		keys: "^",
		type: "motion",
		motion: "moveToFirstNonWhiteSpaceCharacter"
	},
	{
		keys: "+",
		type: "motion",
		motion: "moveByLines",
		motionArgs: {
			forward: true,
			toFirstChar: true
		}
	},
	{
		keys: "-",
		type: "motion",
		motion: "moveByLines",
		motionArgs: {
			forward: false,
			toFirstChar: true
		}
	},
	{
		keys: "_",
		type: "motion",
		motion: "moveByLines",
		motionArgs: {
			forward: true,
			toFirstChar: true,
			repeatOffset: -1
		}
	},
	{
		keys: "$",
		type: "motion",
		motion: "moveToEol",
		motionArgs: { inclusive: true }
	},
	{
		keys: "%",
		type: "motion",
		motion: "moveToMatchedSymbol",
		motionArgs: {
			inclusive: true,
			toJumplist: true
		}
	},
	{
		keys: "f<character>",
		type: "motion",
		motion: "moveToCharacter",
		motionArgs: {
			forward: true,
			inclusive: true
		}
	},
	{
		keys: "F<character>",
		type: "motion",
		motion: "moveToCharacter",
		motionArgs: { forward: false }
	},
	{
		keys: "t<character>",
		type: "motion",
		motion: "moveTillCharacter",
		motionArgs: {
			forward: true,
			inclusive: true
		}
	},
	{
		keys: "T<character>",
		type: "motion",
		motion: "moveTillCharacter",
		motionArgs: { forward: false }
	},
	{
		keys: ";",
		type: "motion",
		motion: "repeatLastCharacterSearch",
		motionArgs: { forward: true }
	},
	{
		keys: ",",
		type: "motion",
		motion: "repeatLastCharacterSearch",
		motionArgs: { forward: false }
	},
	{
		keys: "'<character>",
		type: "motion",
		motion: "goToMark",
		motionArgs: {
			toJumplist: true,
			linewise: true
		}
	},
	{
		keys: "`<character>",
		type: "motion",
		motion: "goToMark",
		motionArgs: { toJumplist: true }
	},
	{
		keys: "]`",
		type: "motion",
		motion: "jumpToMark",
		motionArgs: { forward: true }
	},
	{
		keys: "[`",
		type: "motion",
		motion: "jumpToMark",
		motionArgs: { forward: false }
	},
	{
		keys: "]'",
		type: "motion",
		motion: "jumpToMark",
		motionArgs: {
			forward: true,
			linewise: true
		}
	},
	{
		keys: "['",
		type: "motion",
		motion: "jumpToMark",
		motionArgs: {
			forward: false,
			linewise: true
		}
	},
	{
		keys: "]p",
		type: "action",
		action: "paste",
		isEdit: true,
		actionArgs: {
			after: true,
			isEdit: true,
			matchIndent: true
		}
	},
	{
		keys: "[p",
		type: "action",
		action: "paste",
		isEdit: true,
		actionArgs: {
			after: false,
			isEdit: true,
			matchIndent: true
		}
	},
	{
		keys: "]<character>",
		type: "motion",
		motion: "moveToSymbol",
		motionArgs: {
			forward: true,
			toJumplist: true
		}
	},
	{
		keys: "[<character>",
		type: "motion",
		motion: "moveToSymbol",
		motionArgs: {
			forward: false,
			toJumplist: true
		}
	},
	{
		keys: "|",
		type: "motion",
		motion: "moveToColumn"
	},
	{
		keys: "o",
		type: "motion",
		motion: "moveToOtherHighlightedEnd",
		context: "visual"
	},
	{
		keys: "O",
		type: "motion",
		motion: "moveToOtherHighlightedEnd",
		motionArgs: { sameLine: true },
		context: "visual"
	},
	{
		keys: "d",
		type: "operator",
		operator: "delete"
	},
	{
		keys: "y",
		type: "operator",
		operator: "yank"
	},
	{
		keys: "c",
		type: "operator",
		operator: "change"
	},
	{
		keys: "=",
		type: "operator",
		operator: "indentAuto"
	},
	{
		keys: ">",
		type: "operator",
		operator: "indent",
		operatorArgs: { indentRight: true }
	},
	{
		keys: "<",
		type: "operator",
		operator: "indent",
		operatorArgs: { indentRight: false }
	},
	{
		keys: "g~",
		type: "operator",
		operator: "changeCase"
	},
	{
		keys: "gu",
		type: "operator",
		operator: "changeCase",
		operatorArgs: { toLower: true },
		isEdit: true
	},
	{
		keys: "gU",
		type: "operator",
		operator: "changeCase",
		operatorArgs: { toLower: false },
		isEdit: true
	},
	{
		keys: "n",
		type: "motion",
		motion: "findNext",
		motionArgs: {
			forward: true,
			toJumplist: true
		}
	},
	{
		keys: "N",
		type: "motion",
		motion: "findNext",
		motionArgs: {
			forward: false,
			toJumplist: true
		}
	},
	{
		keys: "gn",
		type: "motion",
		motion: "findAndSelectNextInclusive",
		motionArgs: { forward: true }
	},
	{
		keys: "gN",
		type: "motion",
		motion: "findAndSelectNextInclusive",
		motionArgs: { forward: false }
	},
	{
		keys: "x",
		type: "operatorMotion",
		operator: "delete",
		motion: "moveByCharacters",
		motionArgs: { forward: true },
		operatorMotionArgs: { visualLine: false }
	},
	{
		keys: "X",
		type: "operatorMotion",
		operator: "delete",
		motion: "moveByCharacters",
		motionArgs: { forward: false },
		operatorMotionArgs: { visualLine: true }
	},
	{
		keys: "D",
		type: "operatorMotion",
		operator: "delete",
		motion: "moveToEol",
		motionArgs: { inclusive: true },
		context: "normal"
	},
	{
		keys: "D",
		type: "operator",
		operator: "delete",
		operatorArgs: { linewise: true },
		context: "visual"
	},
	{
		keys: "Y",
		type: "operatorMotion",
		operator: "yank",
		motion: "expandToLine",
		motionArgs: { linewise: true },
		context: "normal"
	},
	{
		keys: "Y",
		type: "operator",
		operator: "yank",
		operatorArgs: { linewise: true },
		context: "visual"
	},
	{
		keys: "C",
		type: "operatorMotion",
		operator: "change",
		motion: "moveToEol",
		motionArgs: { inclusive: true },
		context: "normal"
	},
	{
		keys: "C",
		type: "operator",
		operator: "change",
		operatorArgs: { linewise: true },
		context: "visual"
	},
	{
		keys: "~",
		type: "operatorMotion",
		operator: "changeCase",
		motion: "moveByCharacters",
		motionArgs: { forward: true },
		operatorArgs: { shouldMoveCursor: true },
		context: "normal"
	},
	{
		keys: "~",
		type: "operator",
		operator: "changeCase",
		context: "visual"
	},
	{
		keys: "<C-u>",
		type: "operatorMotion",
		operator: "delete",
		motion: "moveToStartOfLine",
		context: "insert"
	},
	{
		keys: "<C-w>",
		type: "operatorMotion",
		operator: "delete",
		motion: "moveByWords",
		motionArgs: {
			forward: false,
			wordEnd: false
		},
		context: "insert"
	},
	{
		keys: "<C-w>",
		type: "idle",
		context: "normal"
	},
	{
		keys: "<C-i>",
		type: "action",
		action: "jumpListWalk",
		actionArgs: { forward: true }
	},
	{
		keys: "<C-o>",
		type: "action",
		action: "jumpListWalk",
		actionArgs: { forward: false }
	},
	{
		keys: "<C-e>",
		type: "action",
		action: "scroll",
		actionArgs: {
			forward: true,
			linewise: true
		}
	},
	{
		keys: "<C-y>",
		type: "action",
		action: "scroll",
		actionArgs: {
			forward: false,
			linewise: true
		}
	},
	{
		keys: "a",
		type: "action",
		action: "enterInsertMode",
		isEdit: true,
		actionArgs: { insertAt: "charAfter" },
		context: "normal"
	},
	{
		keys: "A",
		type: "action",
		action: "enterInsertMode",
		isEdit: true,
		actionArgs: { insertAt: "eol" },
		context: "normal"
	},
	{
		keys: "A",
		type: "action",
		action: "enterInsertMode",
		isEdit: true,
		actionArgs: { insertAt: "endOfSelectedArea" },
		context: "visual"
	},
	{
		keys: "i",
		type: "action",
		action: "enterInsertMode",
		isEdit: true,
		actionArgs: { insertAt: "inplace" },
		context: "normal"
	},
	{
		keys: "gi",
		type: "action",
		action: "enterInsertMode",
		isEdit: true,
		actionArgs: { insertAt: "lastEdit" },
		context: "normal"
	},
	{
		keys: "I",
		type: "action",
		action: "enterInsertMode",
		isEdit: true,
		actionArgs: { insertAt: "firstNonBlank" },
		context: "normal"
	},
	{
		keys: "gI",
		type: "action",
		action: "enterInsertMode",
		isEdit: true,
		actionArgs: { insertAt: "bol" },
		context: "normal"
	},
	{
		keys: "I",
		type: "action",
		action: "enterInsertMode",
		isEdit: true,
		actionArgs: { insertAt: "startOfSelectedArea" },
		context: "visual"
	},
	{
		keys: "o",
		type: "action",
		action: "newLineAndEnterInsertMode",
		isEdit: true,
		interlaceInsertRepeat: true,
		actionArgs: { after: true },
		context: "normal"
	},
	{
		keys: "O",
		type: "action",
		action: "newLineAndEnterInsertMode",
		isEdit: true,
		interlaceInsertRepeat: true,
		actionArgs: { after: false },
		context: "normal"
	},
	{
		keys: "v",
		type: "action",
		action: "toggleVisualMode"
	},
	{
		keys: "V",
		type: "action",
		action: "toggleVisualMode",
		actionArgs: { linewise: true }
	},
	{
		keys: "<C-v>",
		type: "action",
		action: "toggleVisualMode",
		actionArgs: { blockwise: true }
	},
	{
		keys: "<C-q>",
		type: "action",
		action: "toggleVisualMode",
		actionArgs: { blockwise: true }
	},
	{
		keys: "gv",
		type: "action",
		action: "reselectLastSelection"
	},
	{
		keys: "J",
		type: "action",
		action: "joinLines",
		isEdit: true
	},
	{
		keys: "gJ",
		type: "action",
		action: "joinLines",
		actionArgs: { keepSpaces: true },
		isEdit: true
	},
	{
		keys: "p",
		type: "action",
		action: "paste",
		isEdit: true,
		actionArgs: {
			after: true,
			isEdit: true
		}
	},
	{
		keys: "P",
		type: "action",
		action: "paste",
		isEdit: true,
		actionArgs: {
			after: false,
			isEdit: true
		}
	},
	{
		keys: "r<character>",
		type: "action",
		action: "replace",
		isEdit: true
	},
	{
		keys: "@<character>",
		type: "action",
		action: "replayMacro"
	},
	{
		keys: "q<character>",
		type: "action",
		action: "enterMacroRecordMode"
	},
	{
		keys: "R",
		type: "action",
		action: "enterInsertMode",
		isEdit: true,
		actionArgs: { replace: true },
		context: "normal"
	},
	{
		keys: "R",
		type: "operator",
		operator: "change",
		operatorArgs: {
			linewise: true,
			fullLine: true
		},
		context: "visual",
		exitVisualBlock: true
	},
	{
		keys: "u",
		type: "action",
		action: "undo",
		context: "normal"
	},
	{
		keys: "u",
		type: "operator",
		operator: "changeCase",
		operatorArgs: { toLower: true },
		context: "visual",
		isEdit: true
	},
	{
		keys: "U",
		type: "operator",
		operator: "changeCase",
		operatorArgs: { toLower: false },
		context: "visual",
		isEdit: true
	},
	{
		keys: "<C-r>",
		type: "action",
		action: "redo"
	},
	{
		keys: "m<character>",
		type: "action",
		action: "setMark"
	},
	{
		keys: "\"<character>",
		type: "action",
		action: "setRegister"
	},
	{
		keys: "zz",
		type: "action",
		action: "scrollToCursor",
		actionArgs: { position: "center" }
	},
	{
		keys: "z.",
		type: "action",
		action: "scrollToCursor",
		actionArgs: { position: "center" },
		motion: "moveToFirstNonWhiteSpaceCharacter"
	},
	{
		keys: "zt",
		type: "action",
		action: "scrollToCursor",
		actionArgs: { position: "top" }
	},
	{
		keys: "z<CR>",
		type: "action",
		action: "scrollToCursor",
		actionArgs: { position: "top" },
		motion: "moveToFirstNonWhiteSpaceCharacter"
	},
	{
		keys: "z-",
		type: "action",
		action: "scrollToCursor",
		actionArgs: { position: "bottom" }
	},
	{
		keys: "zb",
		type: "action",
		action: "scrollToCursor",
		actionArgs: { position: "bottom" },
		motion: "moveToFirstNonWhiteSpaceCharacter"
	},
	{
		keys: ".",
		type: "action",
		action: "repeatLastEdit"
	},
	{
		keys: "<C-a>",
		type: "action",
		action: "incrementNumberToken",
		isEdit: true,
		actionArgs: {
			increase: true,
			backtrack: false
		}
	},
	{
		keys: "<C-x>",
		type: "action",
		action: "incrementNumberToken",
		isEdit: true,
		actionArgs: {
			increase: false,
			backtrack: false
		}
	},
	{
		keys: "<C-t>",
		type: "action",
		action: "indent",
		actionArgs: { indentRight: true },
		context: "insert"
	},
	{
		keys: "<C-d>",
		type: "action",
		action: "indent",
		actionArgs: { indentRight: false },
		context: "insert"
	},
	{
		keys: "a<character>",
		type: "motion",
		motion: "textObjectManipulation"
	},
	{
		keys: "i<character>",
		type: "motion",
		motion: "textObjectManipulation",
		motionArgs: { textObjectInner: true }
	},
	{
		keys: "/",
		type: "search",
		searchArgs: {
			forward: true,
			querySrc: "prompt",
			toJumplist: true
		}
	},
	{
		keys: "?",
		type: "search",
		searchArgs: {
			forward: false,
			querySrc: "prompt",
			toJumplist: true
		}
	},
	{
		keys: "*",
		type: "search",
		searchArgs: {
			forward: true,
			querySrc: "wordUnderCursor",
			wholeWordOnly: true,
			toJumplist: true
		}
	},
	{
		keys: "#",
		type: "search",
		searchArgs: {
			forward: false,
			querySrc: "wordUnderCursor",
			wholeWordOnly: true,
			toJumplist: true
		}
	},
	{
		keys: "g*",
		type: "search",
		searchArgs: {
			forward: true,
			querySrc: "wordUnderCursor",
			toJumplist: true
		}
	},
	{
		keys: "g#",
		type: "search",
		searchArgs: {
			forward: false,
			querySrc: "wordUnderCursor",
			toJumplist: true
		}
	},
	{
		keys: ":",
		type: "ex"
	}
];
var defaultKeymapLength = defaultKeymap.length;
/**
* Ex commands
* Care must be taken when adding to the default Ex command map. For any
* pair of commands that have a shared prefix, at least one of their
* shortNames must not match the prefix of the other command.
*/
var defaultExCommandMap = [
	{
		name: "colorscheme",
		shortName: "colo"
	},
	{ name: "map" },
	{
		name: "imap",
		shortName: "im"
	},
	{
		name: "nmap",
		shortName: "nm"
	},
	{
		name: "vmap",
		shortName: "vm"
	},
	{ name: "unmap" },
	{
		name: "write",
		shortName: "w"
	},
	{
		name: "undo",
		shortName: "u"
	},
	{
		name: "redo",
		shortName: "red"
	},
	{
		name: "set",
		shortName: "se"
	},
	{
		name: "setlocal",
		shortName: "setl"
	},
	{
		name: "setglobal",
		shortName: "setg"
	},
	{
		name: "sort",
		shortName: "sor"
	},
	{
		name: "substitute",
		shortName: "s",
		possiblyAsync: true
	},
	{
		name: "nohlsearch",
		shortName: "noh"
	},
	{
		name: "yank",
		shortName: "y"
	},
	{
		name: "delmarks",
		shortName: "delm"
	},
	{
		name: "registers",
		shortName: "reg",
		excludeFromCommandHistory: true
	},
	{
		name: "vglobal",
		shortName: "v"
	},
	{
		name: "global",
		shortName: "g"
	}
];
var Vim = function() {
	function enterVimMode(cm) {
		cm.setOption("disableInput", true);
		cm.setOption("showCursorWhenSelecting", false);
		cm_adapter_default.signal(cm, "vim-mode-change", { mode: "normal" });
		cm.on("cursorActivity", onCursorActivity);
		maybeInitVimState(cm);
		cm.enterVimMode();
	}
	function leaveVimMode(cm) {
		cm.setOption("disableInput", false);
		cm.off("cursorActivity", onCursorActivity);
		cm.state.vim = null;
		if (highlightTimeout) clearTimeout(highlightTimeout);
		cm.leaveVimMode();
	}
	function detachVimMap(cm, next) {
		cm.attached = false;
		if (this == cm_adapter_default.keyMap.vim) cm.options.$customCursor = null;
		if (!next || next.attach != attachVimMap) leaveVimMode(cm);
	}
	function attachVimMap(cm, prev) {
		if (this == cm_adapter_default.keyMap.vim) {
			cm.attached = true;
			if (cm.curOp) cm.curOp.selectionChanged = true;
			cm.options.$customCursor = transformCursor;
		}
		if (!prev || prev.attach != attachVimMap) enterVimMode(cm);
	}
	cm_adapter_default.defineOption("vimMode", false, function(cm, val, prev) {
		if (val && cm.getOption("keyMap") != "vim") cm.setOption("keyMap", "vim");
		else if (!val && prev != cm_adapter_default.Init && /^vim/.test(cm.getOption("keyMap"))) cm.setOption("keyMap", "default");
	});
	function cmKey(key, cm) {
		if (!cm) return;
		if (this[key]) return this[key];
		var vimKey = cmKeyToVimKey(key);
		if (!vimKey) return false;
		var cmd = vimApi.findKey(cm, vimKey);
		if (typeof cmd == "function") cm_adapter_default.signal(cm, "vim-keypress", vimKey);
		return cmd;
	}
	var modifiers = {
		Shift: "S",
		Ctrl: "C",
		Alt: "A",
		Cmd: "D",
		Mod: "A",
		CapsLock: ""
	};
	var specialKeys = {
		Enter: "CR",
		Backspace: "BS",
		Delete: "Del",
		Insert: "Ins"
	};
	function cmKeyToVimKey(key) {
		if (key.charAt(0) == "'") return key.charAt(1);
		if (key === "AltGraph") return false;
		var pieces = key.split(/-(?!$)/);
		var lastPiece = pieces[pieces.length - 1];
		if (pieces.length == 1 && pieces[0].length == 1) return false;
		else if (pieces.length == 2 && pieces[0] == "Shift" && lastPiece.length == 1) return false;
		var hasCharacter = false;
		for (var i = 0; i < pieces.length; i++) {
			var piece = pieces[i];
			if (piece in modifiers) pieces[i] = modifiers[piece];
			else hasCharacter = true;
			if (piece in specialKeys) pieces[i] = specialKeys[piece];
		}
		if (!hasCharacter) return false;
		if (isUpperCase(lastPiece)) pieces[pieces.length - 1] = lastPiece.toLowerCase();
		return "<" + pieces.join("-") + ">";
	}
	var numberRegex = /[\d]/;
	var wordCharTest = [cm_adapter_default.isWordChar, function(ch) {
		return ch && !cm_adapter_default.isWordChar(ch) && !/\s/.test(ch);
	}], bigWordCharTest = [function(ch) {
		return /\S/.test(ch);
	}];
	function makeKeyRange(start, size) {
		var keys = [];
		for (var i = start; i < start + size; i++) keys.push(String.fromCharCode(i));
		return keys;
	}
	var upperCaseAlphabet = makeKeyRange(65, 26);
	var lowerCaseAlphabet = makeKeyRange(97, 26);
	var numbers = makeKeyRange(48, 10);
	var validMarks = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, ["<", ">"]);
	var validRegisters = [].concat(upperCaseAlphabet, lowerCaseAlphabet, numbers, [
		"-",
		"\"",
		".",
		":",
		"_",
		"/"
	]);
	var upperCaseChars;
	try {
		upperCaseChars = new RegExp("^[\\p{Lu}]$", "u");
	} catch (_) {
		upperCaseChars = /^[A-Z]$/;
	}
	function isLine(cm, line) {
		return line >= cm.firstLine() && line <= cm.lastLine();
	}
	function isLowerCase(k) {
		return /^[a-z]$/.test(k);
	}
	function isNumber(k) {
		return numberRegex.test(k);
	}
	function isUpperCase(k) {
		return upperCaseChars.test(k);
	}
	function isWhiteSpaceString(k) {
		return /^\s*$/.test(k);
	}
	function isEndOfSentenceSymbol(k) {
		return ".?!".indexOf(k) != -1;
	}
	function inArray(val, arr) {
		for (var i = 0; i < arr.length; i++) if (arr[i] == val) return true;
		return false;
	}
	var options = {};
	function defineOption(name, defaultValue, type, aliases, callback) {
		if (defaultValue === void 0 && !callback) throw Error("defaultValue is required unless callback is provided");
		if (!type) type = "string";
		options[name] = {
			type,
			defaultValue,
			callback
		};
		if (aliases) for (var i = 0; i < aliases.length; i++) options[aliases[i]] = options[name];
		if (defaultValue) setOption(name, defaultValue);
	}
	function setOption(name, value, cm, cfg) {
		var option = options[name];
		cfg = cfg || {};
		var scope = cfg.scope;
		if (!option) return /* @__PURE__ */ new Error("Unknown option: " + name);
		if (option.type == "boolean") {
			if (value && value !== true) return /* @__PURE__ */ new Error("Invalid argument: " + name + "=" + value);
			else if (value !== false) value = true;
		}
		if (option.callback) {
			if (scope !== "local") option.callback(value, void 0);
			if (scope !== "global" && cm) option.callback(value, cm);
		} else {
			if (scope !== "local") option.value = option.type == "boolean" ? !!value : value;
			if (scope !== "global" && cm) cm.state.vim.options[name] = { value };
		}
	}
	function getOption(name, cm, cfg) {
		var option = options[name];
		cfg = cfg || {};
		var scope = cfg.scope;
		if (!option) return /* @__PURE__ */ new Error("Unknown option: " + name);
		if (option.callback) {
			var local = cm && option.callback(void 0, cm);
			if (scope !== "global" && local !== void 0) return local;
			if (scope !== "local") return option.callback();
			return;
		} else {
			var local = scope !== "global" && cm && cm.state.vim.options[name];
			return (local || scope !== "local" && option || {}).value;
		}
	}
	defineOption("filetype", void 0, "string", ["ft"], function(name, cm) {
		if (cm === void 0) return;
		if (name === void 0) {
			var mode = cm.getOption("mode");
			return mode == "null" ? "" : mode;
		} else {
			var mode = name == "" ? "null" : name;
			cm.setOption("mode", mode);
		}
	});
	var createCircularJumpList = function() {
		var size = 100;
		var pointer = -1;
		var head = 0;
		var tail = 0;
		var buffer = new Array(size);
		function add(cm, oldCur, newCur) {
			var curMark = buffer[pointer % size];
			function useNextSlot(cursor) {
				var next = ++pointer % size;
				var trashMark = buffer[next];
				if (trashMark) trashMark.clear();
				buffer[next] = cm.setBookmark(cursor);
			}
			if (curMark) {
				var markPos = curMark.find();
				if (markPos && !cursorEqual(markPos, oldCur)) useNextSlot(oldCur);
			} else useNextSlot(oldCur);
			useNextSlot(newCur);
			head = pointer;
			tail = pointer - size + 1;
			if (tail < 0) tail = 0;
		}
		function move(cm, offset) {
			pointer += offset;
			if (pointer > head) pointer = head;
			else if (pointer < tail) pointer = tail;
			var mark = buffer[(size + pointer) % size];
			if (mark && !mark.find()) {
				var inc = offset > 0 ? 1 : -1;
				var newCur;
				var oldCur = cm.getCursor();
				do {
					pointer += inc;
					mark = buffer[(size + pointer) % size];
					if (mark && (newCur = mark.find()) && !cursorEqual(oldCur, newCur)) break;
				} while (pointer < head && pointer > tail);
			}
			return mark;
		}
		function find(cm, offset) {
			var oldPointer = pointer;
			var mark = move(cm, offset);
			pointer = oldPointer;
			return mark && mark.find();
		}
		return {
			cachedCursor: void 0,
			add,
			find,
			move
		};
	};
	var createInsertModeChanges = function(c) {
		if (c) return {
			changes: c.changes,
			expectCursorActivityForChange: c.expectCursorActivityForChange
		};
		return {
			changes: [],
			expectCursorActivityForChange: false
		};
	};
	function MacroModeState() {
		this.latestRegister = void 0;
		this.isPlaying = false;
		this.isRecording = false;
		this.replaySearchQueries = [];
		this.onRecordingDone = void 0;
		this.lastInsertModeChanges = createInsertModeChanges();
	}
	MacroModeState.prototype = {
		exitMacroRecordMode: function() {
			var macroModeState = vimGlobalState.macroModeState;
			if (macroModeState.onRecordingDone) macroModeState.onRecordingDone();
			macroModeState.onRecordingDone = void 0;
			macroModeState.isRecording = false;
		},
		enterMacroRecordMode: function(cm, registerName) {
			var register = vimGlobalState.registerController.getRegister(registerName);
			if (register) {
				register.clear();
				this.latestRegister = registerName;
				if (cm.openDialog) this.onRecordingDone = cm.openDialog(document.createTextNode("(recording)[" + registerName + "]"), null, { bottom: true });
				this.isRecording = true;
			}
		}
	};
	function maybeInitVimState(cm) {
		if (!cm.state.vim) cm.state.vim = {
			inputState: new InputState(),
			lastEditInputState: void 0,
			lastEditActionCommand: void 0,
			lastHPos: -1,
			lastHSPos: -1,
			lastMotion: null,
			marks: {},
			insertMode: false,
			insertModeRepeat: void 0,
			visualMode: false,
			visualLine: false,
			visualBlock: false,
			lastSelection: null,
			lastPastedText: null,
			sel: {},
			options: {}
		};
		return cm.state.vim;
	}
	var vimGlobalState;
	function resetVimGlobalState() {
		vimGlobalState = {
			searchQuery: null,
			searchIsReversed: false,
			lastSubstituteReplacePart: void 0,
			jumpList: createCircularJumpList(),
			macroModeState: new MacroModeState(),
			lastCharacterSearch: {
				increment: 0,
				forward: true,
				selectedCharacter: ""
			},
			registerController: new RegisterController({}),
			searchHistoryController: new HistoryController(),
			exCommandHistoryController: new HistoryController()
		};
		for (var optionName in options) {
			var option = options[optionName];
			option.value = option.defaultValue;
		}
	}
	var lastInsertModeKeyTimer;
	var vimApi = {
		buildKeyMap: function() {},
		getRegisterController: function() {
			return vimGlobalState.registerController;
		},
		resetVimGlobalState_: resetVimGlobalState,
		getVimGlobalState_: function() {
			return vimGlobalState;
		},
		maybeInitVimState_: maybeInitVimState,
		suppressErrorLogging: false,
		InsertModeKey,
		map: function(lhs, rhs, ctx) {
			exCommandDispatcher.map(lhs, rhs, ctx);
		},
		unmap: function(lhs, ctx) {
			return exCommandDispatcher.unmap(lhs, ctx);
		},
		noremap: function(lhs, rhs, ctx) {
			function toCtxArray(ctx$1) {
				return ctx$1 ? [ctx$1] : [
					"normal",
					"insert",
					"visual"
				];
			}
			var ctxsToMap = toCtxArray(ctx);
			var actualLength = defaultKeymap.length;
			for (var i = actualLength - defaultKeymapLength; i < actualLength && ctxsToMap.length; i++) {
				var mapping = defaultKeymap[i];
				if (mapping.keys == rhs && (!ctx || !mapping.context || mapping.context === ctx) && mapping.type.substr(0, 2) !== "ex" && mapping.type.substr(0, 3) !== "key") {
					var newMapping = {};
					for (var key in mapping) newMapping[key] = mapping[key];
					newMapping.keys = lhs;
					if (ctx && !newMapping.context) newMapping.context = ctx;
					this._mapCommand(newMapping);
					var mappedCtxs = toCtxArray(mapping.context);
					ctxsToMap = ctxsToMap.filter(function(el) {
						return mappedCtxs.indexOf(el) === -1;
					});
				}
			}
		},
		mapclear: function(ctx) {
			var actualLength = defaultKeymap.length, origLength = defaultKeymapLength;
			var userKeymap = defaultKeymap.slice(0, actualLength - origLength);
			defaultKeymap = defaultKeymap.slice(actualLength - origLength);
			if (ctx) for (var i = userKeymap.length - 1; i >= 0; i--) {
				var mapping = userKeymap[i];
				if (ctx !== mapping.context) if (mapping.context) this._mapCommand(mapping);
				else {
					var contexts = [
						"normal",
						"insert",
						"visual"
					];
					for (var j in contexts) if (contexts[j] !== ctx) {
						var newMapping = {};
						for (var key in mapping) newMapping[key] = mapping[key];
						newMapping.context = contexts[j];
						this._mapCommand(newMapping);
					}
				}
			}
		},
		setOption,
		getOption,
		defineOption,
		defineEx: function(name, prefix, func) {
			if (!prefix) prefix = name;
			else if (name.indexOf(prefix) !== 0) throw new Error("(Vim.defineEx) \"" + prefix + "\" is not a prefix of \"" + name + "\", command not registered");
			exCommands[name] = func;
			exCommandDispatcher.commandMap_[prefix] = {
				name,
				shortName: prefix,
				type: "api"
			};
		},
		handleKey: function(cm, key, origin) {
			var command = this.findKey(cm, key, origin);
			if (typeof command === "function") return command();
		},
		findKey: function(cm, key, origin) {
			var vim = maybeInitVimState(cm);
			function handleMacroRecording() {
				var macroModeState = vimGlobalState.macroModeState;
				if (macroModeState.isRecording) {
					if (key == "q") {
						macroModeState.exitMacroRecordMode();
						clearInputState(cm);
						return true;
					}
					if (origin != "mapping") logKey(macroModeState, key);
				}
			}
			function handleEsc() {
				if (key == "<Esc>") {
					if (vim.visualMode) exitVisualMode(cm);
					else if (vim.insertMode) exitInsertMode(cm);
					else return;
					clearInputState(cm);
					return true;
				}
			}
			function doKeyToKey(keys) {
				var match;
				while (keys) {
					match = /<\w+-.+?>|<\w+>|./.exec(keys);
					key = match[0];
					keys = keys.substring(match.index + key.length);
					vimApi.handleKey(cm, key, "mapping");
				}
			}
			function handleKeyInsertMode() {
				if (handleEsc()) return true;
				var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
				var keysAreChars = key.length == 1;
				var match = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, "insert");
				while (keys.length > 1 && match.type != "full") {
					var keys = vim.inputState.keyBuffer = keys.slice(1);
					var thisMatch = commandDispatcher.matchCommand(keys, defaultKeymap, vim.inputState, "insert");
					if (thisMatch.type != "none") match = thisMatch;
				}
				if (match.type == "none") {
					clearInputState(cm);
					return false;
				} else if (match.type == "partial") {
					if (lastInsertModeKeyTimer) window.clearTimeout(lastInsertModeKeyTimer);
					lastInsertModeKeyTimer = window.setTimeout(function() {
						if (vim.insertMode && vim.inputState.keyBuffer) clearInputState(cm);
					}, getOption("insertModeEscKeysTimeout"));
					return !keysAreChars;
				}
				if (lastInsertModeKeyTimer) window.clearTimeout(lastInsertModeKeyTimer);
				if (keysAreChars) {
					var selections = cm.listSelections();
					for (var i = 0; i < selections.length; i++) {
						var here = selections[i].head;
						cm.replaceRange("", offsetCursor(here, 0, -(keys.length - 1)), here, "+input");
					}
					vimGlobalState.macroModeState.lastInsertModeChanges.changes.pop();
				}
				clearInputState(cm);
				return match.command;
			}
			function handleKeyNonInsertMode() {
				if (handleMacroRecording() || handleEsc()) return true;
				var keys = vim.inputState.keyBuffer = vim.inputState.keyBuffer + key;
				if (/^[1-9]\d*$/.test(keys)) return true;
				var keysMatcher = /^(\d*)(.*)$/.exec(keys);
				if (!keysMatcher) {
					clearInputState(cm);
					return false;
				}
				var context = vim.visualMode ? "visual" : "normal";
				var mainKey = keysMatcher[2] || keysMatcher[1];
				if (vim.inputState.operatorShortcut && vim.inputState.operatorShortcut.slice(-1) == mainKey) mainKey = vim.inputState.operatorShortcut;
				var match = commandDispatcher.matchCommand(mainKey, defaultKeymap, vim.inputState, context);
				if (match.type == "none") {
					clearInputState(cm);
					return false;
				} else if (match.type == "partial") return true;
				vim.inputState.keyBuffer = "";
				var keysMatcher = /^(\d*)(.*)$/.exec(keys);
				if (keysMatcher[1] && keysMatcher[1] != "0") vim.inputState.pushRepeatDigit(keysMatcher[1]);
				return match.command;
			}
			var command;
			if (vim.insertMode) command = handleKeyInsertMode();
			else command = handleKeyNonInsertMode();
			if (command === false) return !vim.insertMode && key.length === 1 ? function() {
				return true;
			} : void 0;
			else if (command === true) return function() {
				return true;
			};
			else return function() {
				return cm.operation(function() {
					cm.curOp.isVimOp = true;
					try {
						if (command.type == "keyToKey") doKeyToKey(command.toKeys);
						else commandDispatcher.processCommand(cm, vim, command);
					} catch (e) {
						cm.state.vim = void 0;
						maybeInitVimState(cm);
						if (!vimApi.suppressErrorLogging) console["log"](e);
						throw e;
					}
					return true;
				});
			};
		},
		handleEx: function(cm, input) {
			exCommandDispatcher.processCommand(cm, input);
		},
		defineMotion,
		defineAction,
		defineOperator,
		mapCommand,
		_mapCommand,
		defineRegister,
		exitVisualMode,
		exitInsertMode
	};
	function InputState() {
		this.prefixRepeat = [];
		this.motionRepeat = [];
		this.operator = null;
		this.operatorArgs = null;
		this.motion = null;
		this.motionArgs = null;
		this.keyBuffer = [];
		this.registerName = null;
	}
	InputState.prototype.pushRepeatDigit = function(n) {
		if (!this.operator) this.prefixRepeat = this.prefixRepeat.concat(n);
		else this.motionRepeat = this.motionRepeat.concat(n);
	};
	InputState.prototype.getRepeat = function() {
		var repeat = 0;
		if (this.prefixRepeat.length > 0 || this.motionRepeat.length > 0) {
			repeat = 1;
			if (this.prefixRepeat.length > 0) repeat *= parseInt(this.prefixRepeat.join(""), 10);
			if (this.motionRepeat.length > 0) repeat *= parseInt(this.motionRepeat.join(""), 10);
		}
		return repeat;
	};
	function clearInputState(cm, reason) {
		cm.state.vim.inputState = new InputState();
		cm_adapter_default.signal(cm, "vim-command-done", reason);
	}
	function Register(text, linewise, blockwise) {
		this.clear();
		this.keyBuffer = [text || ""];
		this.insertModeChanges = [];
		this.searchQueries = [];
		this.linewise = !!linewise;
		this.blockwise = !!blockwise;
	}
	Register.prototype = {
		setText: function(text, linewise, blockwise) {
			this.keyBuffer = [text || ""];
			this.linewise = !!linewise;
			this.blockwise = !!blockwise;
		},
		pushText: function(text, linewise) {
			if (linewise) {
				if (!this.linewise) this.keyBuffer.push("\n");
				this.linewise = true;
			}
			this.keyBuffer.push(text);
		},
		pushInsertModeChanges: function(changes) {
			this.insertModeChanges.push(createInsertModeChanges(changes));
		},
		pushSearchQuery: function(query) {
			this.searchQueries.push(query);
		},
		clear: function() {
			this.keyBuffer = [];
			this.insertModeChanges = [];
			this.searchQueries = [];
			this.linewise = false;
		},
		toString: function() {
			return this.keyBuffer.join("");
		}
	};
	/**
	* Defines an external register.
	*
	* The name should be a single character that will be used to reference the register.
	* The register should support setText, pushText, clear, and toString(). See Register
	* for a reference implementation.
	*/
	function defineRegister(name, register) {
		var registers = vimGlobalState.registerController.registers;
		if (!name || name.length != 1) throw Error("Register name must be 1 character");
		if (registers[name]) throw Error("Register already defined " + name);
		registers[name] = register;
		validRegisters.push(name);
	}
	function RegisterController(registers) {
		this.registers = registers;
		this.unnamedRegister = registers["\""] = new Register();
		registers["."] = new Register();
		registers[":"] = new Register();
		registers["/"] = new Register();
	}
	RegisterController.prototype = {
		pushText: function(registerName, operator, text, linewise, blockwise) {
			if (registerName === "_") return;
			if (linewise && text.charAt(text.length - 1) !== "\n") text += "\n";
			var register = this.isValidRegister(registerName) ? this.getRegister(registerName) : null;
			if (!register) {
				switch (operator) {
					case "yank":
						this.registers["0"] = new Register(text, linewise, blockwise);
						break;
					case "delete":
					case "change":
						if (text.indexOf("\n") == -1) this.registers["-"] = new Register(text, linewise);
						else {
							this.shiftNumericRegisters_();
							this.registers["1"] = new Register(text, linewise);
						}
						break;
				}
				this.unnamedRegister.setText(text, linewise, blockwise);
				return;
			}
			if (isUpperCase(registerName)) register.pushText(text, linewise);
			else register.setText(text, linewise, blockwise);
			this.unnamedRegister.setText(register.toString(), linewise);
		},
		getRegister: function(name) {
			if (!this.isValidRegister(name)) return this.unnamedRegister;
			name = name.toLowerCase();
			if (!this.registers[name]) this.registers[name] = new Register();
			return this.registers[name];
		},
		isValidRegister: function(name) {
			return name && inArray(name, validRegisters);
		},
		shiftNumericRegisters_: function() {
			for (var i = 9; i >= 2; i--) this.registers[i] = this.getRegister("" + (i - 1));
		}
	};
	function HistoryController() {
		this.historyBuffer = [];
		this.iterator = 0;
		this.initialPrefix = null;
	}
	HistoryController.prototype = {
		nextMatch: function(input, up) {
			var historyBuffer = this.historyBuffer;
			var dir = up ? -1 : 1;
			if (this.initialPrefix === null) this.initialPrefix = input;
			for (var i = this.iterator + dir; up ? i >= 0 : i < historyBuffer.length; i += dir) {
				var element = historyBuffer[i];
				for (var j = 0; j <= element.length; j++) if (this.initialPrefix == element.substring(0, j)) {
					this.iterator = i;
					return element;
				}
			}
			if (i >= historyBuffer.length) {
				this.iterator = historyBuffer.length;
				return this.initialPrefix;
			}
			if (i < 0) return input;
		},
		pushInput: function(input) {
			var index = this.historyBuffer.indexOf(input);
			if (index > -1) this.historyBuffer.splice(index, 1);
			if (input.length) this.historyBuffer.push(input);
		},
		reset: function() {
			this.initialPrefix = null;
			this.iterator = this.historyBuffer.length;
		}
	};
	var commandDispatcher = {
		matchCommand: function(keys, keyMap, inputState, context) {
			var matches = commandMatches(keys, keyMap, context, inputState);
			if (!matches.full && !matches.partial) return { type: "none" };
			else if (!matches.full && matches.partial) return { type: "partial" };
			var bestMatch;
			for (var i = 0; i < matches.full.length; i++) {
				var match = matches.full[i];
				if (!bestMatch) bestMatch = match;
			}
			if (bestMatch.keys.slice(-11) == "<character>") {
				var character = lastChar(keys);
				if (!character) return { type: "none" };
				inputState.selectedCharacter = character;
			}
			return {
				type: "full",
				command: bestMatch
			};
		},
		processCommand: function(cm, vim, command) {
			vim.inputState.repeatOverride = command.repeatOverride;
			switch (command.type) {
				case "motion":
					this.processMotion(cm, vim, command);
					break;
				case "operator":
					this.processOperator(cm, vim, command);
					break;
				case "operatorMotion":
					this.processOperatorMotion(cm, vim, command);
					break;
				case "action":
					this.processAction(cm, vim, command);
					break;
				case "search":
					this.processSearch(cm, vim, command);
					break;
				case "ex":
				case "keyToEx":
					this.processEx(cm, vim, command);
					break;
				default: break;
			}
		},
		processMotion: function(cm, vim, command) {
			vim.inputState.motion = command.motion;
			vim.inputState.motionArgs = copyArgs(command.motionArgs);
			this.evalInput(cm, vim);
		},
		processOperator: function(cm, vim, command) {
			var inputState = vim.inputState;
			if (inputState.operator) if (inputState.operator == command.operator) {
				inputState.motion = "expandToLine";
				inputState.motionArgs = { linewise: true };
				this.evalInput(cm, vim);
				return;
			} else clearInputState(cm);
			inputState.operator = command.operator;
			inputState.operatorArgs = copyArgs(command.operatorArgs);
			if (command.keys.length > 1) inputState.operatorShortcut = command.keys;
			if (command.exitVisualBlock) {
				vim.visualBlock = false;
				updateCmSelection(cm);
			}
			if (vim.visualMode) this.evalInput(cm, vim);
		},
		processOperatorMotion: function(cm, vim, command) {
			var visualMode = vim.visualMode;
			var operatorMotionArgs = copyArgs(command.operatorMotionArgs);
			if (operatorMotionArgs) {
				if (visualMode && operatorMotionArgs.visualLine) vim.visualLine = true;
			}
			this.processOperator(cm, vim, command);
			if (!visualMode) this.processMotion(cm, vim, command);
		},
		processAction: function(cm, vim, command) {
			var inputState = vim.inputState;
			var repeat = inputState.getRepeat();
			var repeatIsExplicit = !!repeat;
			var actionArgs = copyArgs(command.actionArgs) || {};
			if (inputState.selectedCharacter) actionArgs.selectedCharacter = inputState.selectedCharacter;
			if (command.operator) this.processOperator(cm, vim, command);
			if (command.motion) this.processMotion(cm, vim, command);
			if (command.motion || command.operator) this.evalInput(cm, vim);
			actionArgs.repeat = repeat || 1;
			actionArgs.repeatIsExplicit = repeatIsExplicit;
			actionArgs.registerName = inputState.registerName;
			clearInputState(cm);
			vim.lastMotion = null;
			if (command.isEdit) this.recordLastEdit(vim, inputState, command);
			actions[command.action](cm, actionArgs, vim);
		},
		processSearch: function(cm, vim, command) {
			if (!cm.getSearchCursor) return;
			var forward = command.searchArgs.forward;
			var wholeWordOnly = command.searchArgs.wholeWordOnly;
			getSearchState(cm).setReversed(!forward);
			var promptPrefix = forward ? "/" : "?";
			var originalQuery = getSearchState(cm).getQuery();
			var originalScrollPos = cm.getScrollInfo();
			function handleQuery(query$1, ignoreCase, smartCase) {
				vimGlobalState.searchHistoryController.pushInput(query$1);
				vimGlobalState.searchHistoryController.reset();
				try {
					updateSearchQuery(cm, query$1, ignoreCase, smartCase);
				} catch (e) {
					showConfirm(cm, "Invalid regex: " + query$1);
					clearInputState(cm);
					return;
				}
				commandDispatcher.processMotion(cm, vim, {
					type: "motion",
					motion: "findNext",
					motionArgs: {
						forward: true,
						toJumplist: command.searchArgs.toJumplist
					}
				});
			}
			function onPromptClose(query$1) {
				cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
				handleQuery(
					query$1,
					true,
					true
					/** smartCase */
				);
				var macroModeState$1 = vimGlobalState.macroModeState;
				if (macroModeState$1.isRecording) logSearchQuery(macroModeState$1, query$1);
			}
			function onPromptKeyUp(e, query$1, close) {
				var keyName = cm_adapter_default.keyName(e), up, offset;
				if (keyName == "Up" || keyName == "Down") {
					up = keyName == "Up" ? true : false;
					offset = e.target ? e.target.selectionEnd : 0;
					query$1 = vimGlobalState.searchHistoryController.nextMatch(query$1, up) || "";
					close(query$1);
					if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
				} else if (keyName != "Left" && keyName != "Right" && keyName != "Ctrl" && keyName != "Alt" && keyName != "Shift") vimGlobalState.searchHistoryController.reset();
				var parsedQuery;
				try {
					parsedQuery = updateSearchQuery(cm, query$1, true, true);
				} catch (e$1) {}
				if (parsedQuery) cm.scrollIntoView(findNext(cm, !forward, parsedQuery), 30);
				else {
					clearSearchHighlight(cm);
					cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
				}
			}
			function onPromptKeyDown(e, query$1, close) {
				var keyName = cm_adapter_default.keyName(e);
				if (keyName == "Esc" || keyName == "Ctrl-C" || keyName == "Ctrl-[" || keyName == "Backspace" && query$1 == "") {
					vimGlobalState.searchHistoryController.pushInput(query$1);
					vimGlobalState.searchHistoryController.reset();
					updateSearchQuery(cm, originalQuery);
					clearSearchHighlight(cm);
					cm.scrollTo(originalScrollPos.left, originalScrollPos.top);
					cm_adapter_default.e_stop(e);
					clearInputState(cm);
					close();
					cm.focus();
				} else if (keyName == "Up" || keyName == "Down") cm_adapter_default.e_stop(e);
				else if (keyName == "Ctrl-U") {
					cm_adapter_default.e_stop(e);
					close("");
				}
			}
			switch (command.searchArgs.querySrc) {
				case "prompt":
					var macroModeState = vimGlobalState.macroModeState;
					if (macroModeState.isPlaying) {
						var query = macroModeState.replaySearchQueries.shift();
						handleQuery(
							query,
							true,
							false
							/** smartCase */
						);
					} else showPrompt(cm, {
						onClose: onPromptClose,
						prefix: promptPrefix,
						desc: "(JavaScript regexp)",
						onKeyUp: onPromptKeyUp,
						onKeyDown: onPromptKeyDown
					});
					break;
				case "wordUnderCursor":
					var word = expandWordUnderCursor(cm, false, true, false, true);
					var isKeyword = true;
					if (!word) {
						word = expandWordUnderCursor(cm, false, true, false, false);
						isKeyword = false;
					}
					if (!word) return;
					var query = cm.getLine(word.start.line).substring(word.start.ch, word.end.ch);
					if (isKeyword && wholeWordOnly) query = "\\b" + query + "\\b";
					else query = escapeRegex(query);
					vimGlobalState.jumpList.cachedCursor = cm.getCursor();
					cm.setCursor(word.start);
					handleQuery(
						query,
						true,
						false
						/** smartCase */
					);
					break;
			}
		},
		processEx: function(cm, vim, command) {
			function onPromptClose(input) {
				vimGlobalState.exCommandHistoryController.pushInput(input);
				vimGlobalState.exCommandHistoryController.reset();
				exCommandDispatcher.processCommand(cm, input);
			}
			function onPromptKeyDown(e, input, close) {
				var keyName = cm_adapter_default.keyName(e), up, offset;
				if (keyName == "Esc" || keyName == "Ctrl-C" || keyName == "Ctrl-[" || keyName == "Backspace" && input == "") {
					vimGlobalState.exCommandHistoryController.pushInput(input);
					vimGlobalState.exCommandHistoryController.reset();
					cm_adapter_default.e_stop(e);
					clearInputState(cm);
					close();
					cm.focus();
				}
				if (keyName == "Up" || keyName == "Down") {
					cm_adapter_default.e_stop(e);
					up = keyName == "Up" ? true : false;
					offset = e.target ? e.target.selectionEnd : 0;
					input = vimGlobalState.exCommandHistoryController.nextMatch(input, up) || "";
					close(input);
					if (offset && e.target) e.target.selectionEnd = e.target.selectionStart = Math.min(offset, e.target.value.length);
				} else if (keyName == "Ctrl-U") {
					cm_adapter_default.e_stop(e);
					close("");
				} else if (keyName != "Left" && keyName != "Right" && keyName != "Ctrl" && keyName != "Alt" && keyName != "Shift") vimGlobalState.exCommandHistoryController.reset();
			}
			if (command.type == "keyToEx") exCommandDispatcher.processCommand(cm, command.exArgs.input);
			else if (vim.visualMode) showPrompt(cm, {
				onClose: onPromptClose,
				prefix: ":",
				value: "'<,'>",
				onKeyDown: onPromptKeyDown,
				selectValueOnOpen: false
			});
			else showPrompt(cm, {
				onClose: onPromptClose,
				prefix: ":",
				onKeyDown: onPromptKeyDown
			});
		},
		evalInput: function(cm, vim) {
			var inputState = vim.inputState;
			var motion = inputState.motion;
			var motionArgs = inputState.motionArgs || {};
			var operator = inputState.operator;
			var operatorArgs = inputState.operatorArgs || {};
			var registerName = inputState.registerName;
			var sel = vim.sel;
			var origHead = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.head) : cm.getCursor("head"));
			var origAnchor = copyCursor(vim.visualMode ? clipCursorToContent(cm, sel.anchor) : cm.getCursor("anchor"));
			var oldHead = copyCursor(origHead);
			var oldAnchor = copyCursor(origAnchor);
			var newHead, newAnchor;
			var repeat;
			if (operator) this.recordLastEdit(vim, inputState);
			if (inputState.repeatOverride !== void 0) repeat = inputState.repeatOverride;
			else repeat = inputState.getRepeat();
			if (repeat > 0 && motionArgs.explicitRepeat) motionArgs.repeatIsExplicit = true;
			else if (motionArgs.noRepeat || !motionArgs.explicitRepeat && repeat === 0) {
				repeat = 1;
				motionArgs.repeatIsExplicit = false;
			}
			if (inputState.selectedCharacter) motionArgs.selectedCharacter = operatorArgs.selectedCharacter = inputState.selectedCharacter;
			motionArgs.repeat = repeat;
			clearInputState(cm);
			if (motion) {
				var motionResult = motions[motion](cm, origHead, motionArgs, vim, inputState);
				vim.lastMotion = motions[motion];
				if (!motionResult) return;
				if (motionArgs.toJumplist) {
					var jumpList = vimGlobalState.jumpList;
					var cachedCursor = jumpList.cachedCursor;
					if (cachedCursor) {
						recordJumpPosition(cm, cachedCursor, motionResult);
						delete jumpList.cachedCursor;
					} else recordJumpPosition(cm, origHead, motionResult);
				}
				if (motionResult instanceof Array) {
					newAnchor = motionResult[0];
					newHead = motionResult[1];
				} else newHead = motionResult;
				if (!newHead) newHead = copyCursor(origHead);
				if (vim.visualMode) {
					if (!(vim.visualBlock && newHead.ch === Infinity)) newHead = clipCursorToContent(cm, newHead);
					if (newAnchor) newAnchor = clipCursorToContent(cm, newAnchor);
					newAnchor = newAnchor || oldAnchor;
					sel.anchor = newAnchor;
					sel.head = newHead;
					updateCmSelection(cm);
					updateMark(cm, vim, "<", cursorIsBefore(newAnchor, newHead) ? newAnchor : newHead);
					updateMark(cm, vim, ">", cursorIsBefore(newAnchor, newHead) ? newHead : newAnchor);
				} else if (!operator) {
					newHead = clipCursorToContent(cm, newHead);
					cm.setCursor(newHead.line, newHead.ch);
				}
			}
			if (operator) {
				if (operatorArgs.lastSel) {
					newAnchor = oldAnchor;
					var lastSel = operatorArgs.lastSel;
					var lineOffset = Math.abs(lastSel.head.line - lastSel.anchor.line);
					var chOffset = Math.abs(lastSel.head.ch - lastSel.anchor.ch);
					if (lastSel.visualLine) newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
					else if (lastSel.visualBlock) newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch + chOffset);
					else if (lastSel.head.line == lastSel.anchor.line) newHead = new Pos(oldAnchor.line, oldAnchor.ch + chOffset);
					else newHead = new Pos(oldAnchor.line + lineOffset, oldAnchor.ch);
					vim.visualMode = true;
					vim.visualLine = lastSel.visualLine;
					vim.visualBlock = lastSel.visualBlock;
					sel = vim.sel = {
						anchor: newAnchor,
						head: newHead
					};
					updateCmSelection(cm);
				} else if (vim.visualMode) operatorArgs.lastSel = {
					anchor: copyCursor(sel.anchor),
					head: copyCursor(sel.head),
					visualBlock: vim.visualBlock,
					visualLine: vim.visualLine
				};
				var curStart, curEnd, linewise, mode;
				var cmSel;
				if (vim.visualMode) {
					curStart = cursorMin(sel.head, sel.anchor);
					curEnd = cursorMax(sel.head, sel.anchor);
					linewise = vim.visualLine || operatorArgs.linewise;
					mode = vim.visualBlock ? "block" : linewise ? "line" : "char";
					cmSel = makeCmSelection(cm, {
						anchor: curStart,
						head: curEnd
					}, mode);
					if (linewise) {
						var ranges = cmSel.ranges;
						if (mode == "block") for (var i = 0; i < ranges.length; i++) ranges[i].head.ch = lineLength(cm, ranges[i].head.line);
						else if (mode == "line") ranges[0].head = new Pos(ranges[0].head.line + 1, 0);
					}
				} else {
					curStart = copyCursor(newAnchor || oldAnchor);
					curEnd = copyCursor(newHead || oldHead);
					if (cursorIsBefore(curEnd, curStart)) {
						var tmp = curStart;
						curStart = curEnd;
						curEnd = tmp;
					}
					linewise = motionArgs.linewise || operatorArgs.linewise;
					if (linewise) expandSelectionToLine(cm, curStart, curEnd);
					else if (motionArgs.forward) clipToLine(cm, curStart, curEnd);
					mode = "char";
					var exclusive = !motionArgs.inclusive || linewise;
					cmSel = makeCmSelection(cm, {
						anchor: curStart,
						head: curEnd
					}, mode, exclusive);
				}
				cm.setSelections(cmSel.ranges, cmSel.primary);
				vim.lastMotion = null;
				operatorArgs.repeat = repeat;
				operatorArgs.registerName = registerName;
				operatorArgs.linewise = linewise;
				var operatorMoveTo = operators[operator](cm, operatorArgs, cmSel.ranges, oldAnchor, newHead);
				if (vim.visualMode) exitVisualMode(cm, operatorMoveTo != null);
				if (operatorMoveTo) cm.setCursor(operatorMoveTo);
			}
		},
		recordLastEdit: function(vim, inputState, actionCommand) {
			var macroModeState = vimGlobalState.macroModeState;
			if (macroModeState.isPlaying) return;
			vim.lastEditInputState = inputState;
			vim.lastEditActionCommand = actionCommand;
			macroModeState.lastInsertModeChanges.changes = [];
			macroModeState.lastInsertModeChanges.expectCursorActivityForChange = false;
			macroModeState.lastInsertModeChanges.visualBlock = vim.visualBlock ? vim.sel.head.line - vim.sel.anchor.line : 0;
		}
	};
	/**
	* typedef {Object{line:number,ch:number}} Cursor An object containing the
	*     position of the cursor.
	*/
	var motions = {
		moveToTopLine: function(cm, _head, motionArgs) {
			var line = getUserVisibleLines(cm).top + motionArgs.repeat - 1;
			return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
		},
		moveToMiddleLine: function(cm) {
			var range = getUserVisibleLines(cm);
			var line = Math.floor((range.top + range.bottom) * .5);
			return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
		},
		moveToBottomLine: function(cm, _head, motionArgs) {
			var line = getUserVisibleLines(cm).bottom - motionArgs.repeat + 1;
			return new Pos(line, findFirstNonWhiteSpaceCharacter(cm.getLine(line)));
		},
		expandToLine: function(_cm, head, motionArgs) {
			return new Pos(head.line + motionArgs.repeat - 1, Infinity);
		},
		findNext: function(cm, _head, motionArgs) {
			var state = getSearchState(cm);
			var query = state.getQuery();
			if (!query) return;
			var prev = !motionArgs.forward;
			prev = state.isReversed() ? !prev : prev;
			highlightSearchMatches(cm, query);
			return findNext(cm, prev, query, motionArgs.repeat);
		},
		findAndSelectNextInclusive: function(cm, _head, motionArgs, vim, prevInputState) {
			var state = getSearchState(cm);
			var query = state.getQuery();
			if (!query) return;
			var prev = !motionArgs.forward;
			prev = state.isReversed() ? !prev : prev;
			var next = findNextFromAndToInclusive(cm, prev, query, motionArgs.repeat, vim);
			if (!next) return;
			if (prevInputState.operator) return next;
			var from = next[0];
			var to = new Pos(next[1].line, next[1].ch - 1);
			if (vim.visualMode) {
				if (vim.visualLine || vim.visualBlock) {
					vim.visualLine = false;
					vim.visualBlock = false;
					cm_adapter_default.signal(cm, "vim-mode-change", {
						mode: "visual",
						subMode: ""
					});
				}
				var anchor = vim.sel.anchor;
				if (anchor) if (state.isReversed()) {
					if (motionArgs.forward) return [anchor, from];
					return [anchor, to];
				} else {
					if (motionArgs.forward) return [anchor, to];
					return [anchor, from];
				}
			} else {
				vim.visualMode = true;
				vim.visualLine = false;
				vim.visualBlock = false;
				cm_adapter_default.signal(cm, "vim-mode-change", {
					mode: "visual",
					subMode: ""
				});
			}
			return prev ? [to, from] : [from, to];
		},
		goToMark: function(cm, _head, motionArgs, vim) {
			var pos = getMarkPos(cm, vim, motionArgs.selectedCharacter);
			if (pos) return motionArgs.linewise ? {
				line: pos.line,
				ch: findFirstNonWhiteSpaceCharacter(cm.getLine(pos.line))
			} : pos;
			return null;
		},
		moveToOtherHighlightedEnd: function(cm, _head, motionArgs, vim) {
			if (vim.visualBlock && motionArgs.sameLine) {
				var sel = vim.sel;
				return [clipCursorToContent(cm, new Pos(sel.anchor.line, sel.head.ch)), clipCursorToContent(cm, new Pos(sel.head.line, sel.anchor.ch))];
			} else return [vim.sel.head, vim.sel.anchor];
		},
		jumpToMark: function(cm, head, motionArgs, vim) {
			var best = head;
			for (var i = 0; i < motionArgs.repeat; i++) {
				var cursor = best;
				for (var key in vim.marks) {
					if (!isLowerCase(key)) continue;
					var mark = vim.marks[key].find();
					if (motionArgs.forward ? cursorIsBefore(mark, cursor) : cursorIsBefore(cursor, mark)) continue;
					if (motionArgs.linewise && mark.line == cursor.line) continue;
					var equal = cursorEqual(cursor, best);
					var between = motionArgs.forward ? cursorIsBetween(cursor, mark, best) : cursorIsBetween(best, mark, cursor);
					if (equal || between) best = mark;
				}
			}
			if (motionArgs.linewise) best = new Pos(best.line, findFirstNonWhiteSpaceCharacter(cm.getLine(best.line)));
			return best;
		},
		moveByCharacters: function(_cm, head, motionArgs) {
			var cur = head;
			var repeat = motionArgs.repeat;
			var ch = motionArgs.forward ? cur.ch + repeat : cur.ch - repeat;
			return new Pos(cur.line, ch);
		},
		moveByLines: function(cm, head, motionArgs, vim) {
			var cur = head;
			var endCh = cur.ch;
			switch (vim.lastMotion) {
				case this.moveByLines:
				case this.moveByDisplayLines:
				case this.moveByScroll:
				case this.moveToColumn:
				case this.moveToEol:
					endCh = vim.lastHPos;
					break;
				default: vim.lastHPos = endCh;
			}
			var repeat = motionArgs.repeat + (motionArgs.repeatOffset || 0);
			var line = motionArgs.forward ? cur.line + repeat : cur.line - repeat;
			var first = cm.firstLine();
			var last = cm.lastLine();
			var posV = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, "line", vim.lastHSPos);
			if (motionArgs.forward ? posV.line > line : posV.line < line) {
				line = posV.line;
				endCh = posV.ch;
			}
			if (line < first && cur.line == first) return this.moveToStartOfLine(cm, head, motionArgs, vim);
			else if (line > last && cur.line == last) return moveToEol(cm, head, motionArgs, vim, true);
			if (motionArgs.toFirstChar) {
				endCh = findFirstNonWhiteSpaceCharacter(cm.getLine(line));
				vim.lastHPos = endCh;
			}
			vim.lastHSPos = cm.charCoords(new Pos(line, endCh), "div").left;
			return new Pos(line, endCh);
		},
		moveByDisplayLines: function(cm, head, motionArgs, vim) {
			var cur = head;
			switch (vim.lastMotion) {
				case this.moveByDisplayLines:
				case this.moveByScroll:
				case this.moveByLines:
				case this.moveToColumn:
				case this.moveToEol: break;
				default: vim.lastHSPos = cm.charCoords(cur, "div").left;
			}
			var repeat = motionArgs.repeat;
			var res = cm.findPosV(cur, motionArgs.forward ? repeat : -repeat, "line", vim.lastHSPos);
			if (res.hitSide) if (motionArgs.forward) {
				var goalCoords = {
					top: cm.charCoords(res, "div").top + 8,
					left: vim.lastHSPos
				};
				var res = cm.coordsChar(goalCoords, "div");
			} else {
				var resCoords = cm.charCoords(new Pos(cm.firstLine(), 0), "div");
				resCoords.left = vim.lastHSPos;
				res = cm.coordsChar(resCoords, "div");
			}
			vim.lastHPos = res.ch;
			return res;
		},
		moveByPage: function(cm, head, motionArgs) {
			var curStart = head;
			var repeat = motionArgs.repeat;
			return cm.findPosV(curStart, motionArgs.forward ? repeat : -repeat, "page");
		},
		moveByParagraph: function(cm, head, motionArgs) {
			var dir = motionArgs.forward ? 1 : -1;
			return findParagraph(cm, head, motionArgs.repeat, dir);
		},
		moveBySentence: function(cm, head, motionArgs) {
			var dir = motionArgs.forward ? 1 : -1;
			return findSentence(cm, head, motionArgs.repeat, dir);
		},
		moveByScroll: function(cm, head, motionArgs, vim) {
			var scrollbox = cm.getScrollInfo();
			var curEnd = null;
			var repeat = motionArgs.repeat;
			if (!repeat) repeat = scrollbox.clientHeight / (2 * cm.defaultTextHeight());
			var orig = cm.charCoords(head, "local");
			motionArgs.repeat = repeat;
			var curEnd = motions.moveByDisplayLines(cm, head, motionArgs, vim);
			if (!curEnd) return null;
			var dest = cm.charCoords(curEnd, "local");
			cm.scrollTo(null, scrollbox.top + dest.top - orig.top);
			return curEnd;
		},
		moveByWords: function(cm, head, motionArgs) {
			return moveToWord(cm, head, motionArgs.repeat, !!motionArgs.forward, !!motionArgs.wordEnd, !!motionArgs.bigWord);
		},
		moveTillCharacter: function(cm, _head, motionArgs) {
			var repeat = motionArgs.repeat;
			var curEnd = moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter);
			var increment = motionArgs.forward ? -1 : 1;
			recordLastCharacterSearch(increment, motionArgs);
			if (!curEnd) return null;
			curEnd.ch += increment;
			return curEnd;
		},
		moveToCharacter: function(cm, head, motionArgs) {
			var repeat = motionArgs.repeat;
			recordLastCharacterSearch(0, motionArgs);
			return moveToCharacter(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;
		},
		moveToSymbol: function(cm, head, motionArgs) {
			var repeat = motionArgs.repeat;
			return findSymbol(cm, repeat, motionArgs.forward, motionArgs.selectedCharacter) || head;
		},
		moveToColumn: function(cm, head, motionArgs, vim) {
			var repeat = motionArgs.repeat;
			vim.lastHPos = repeat - 1;
			vim.lastHSPos = cm.charCoords(head, "div").left;
			return moveToColumn(cm, repeat);
		},
		moveToEol: function(cm, head, motionArgs, vim) {
			return moveToEol(cm, head, motionArgs, vim, false);
		},
		moveToFirstNonWhiteSpaceCharacter: function(cm, head) {
			var cursor = head;
			return new Pos(cursor.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cursor.line)));
		},
		moveToMatchedSymbol: function(cm, head) {
			var cursor = head;
			var line = cursor.line;
			var ch = cursor.ch;
			if (ch < cm.getLine(line).length) {
				var re = ch === "<" || ch === ">" ? /[(){}[\]<>]/ : /[(){}[\]]/;
				return cm.findMatchingBracket(new Pos(line, ch), { bracketRegex: re }).to;
			} else return cursor;
		},
		moveToStartOfLine: function(_cm, head) {
			return new Pos(head.line, 0);
		},
		moveToLineOrEdgeOfDocument: function(cm, _head, motionArgs) {
			var lineNum = motionArgs.forward ? cm.lastLine() : cm.firstLine();
			if (motionArgs.repeatIsExplicit) lineNum = motionArgs.repeat - cm.getOption("firstLineNumber");
			return new Pos(lineNum, findFirstNonWhiteSpaceCharacter(cm.getLine(lineNum)));
		},
		moveToStartOfDisplayLine: function(cm) {
			cm.execCommand("goLineLeft");
			return cm.getCursor();
		},
		moveToEndOfDisplayLine: function(cm) {
			cm.execCommand("goLineRight");
			var head = cm.getCursor();
			if (head.sticky == "before") head.ch--;
			return head;
		},
		textObjectManipulation: function(cm, head, motionArgs, vim) {
			var mirroredPairs = {
				"(": ")",
				")": "(",
				"{": "}",
				"}": "{",
				"[": "]",
				"]": "[",
				"<": ">",
				">": "<"
			};
			var selfPaired = {
				"'": true,
				"\"": true,
				"`": true
			};
			var character = motionArgs.selectedCharacter;
			if (character == "b") character = "(";
			else if (character == "B") character = "{";
			var inclusive = !motionArgs.textObjectInner;
			var tmp;
			if (mirroredPairs[character]) tmp = selectCompanionObject(cm, head, character, inclusive);
			else if (selfPaired[character]) tmp = findBeginningAndEnd(cm, head, character, inclusive);
			else if (character === "W") tmp = expandWordUnderCursor(cm, inclusive, true, true);
			else if (character === "w") tmp = expandWordUnderCursor(cm, inclusive, true, false);
			else if (character === "p") {
				tmp = findParagraph(cm, head, motionArgs.repeat, 0, inclusive);
				motionArgs.linewise = true;
				if (vim.visualMode) {
					if (!vim.visualLine) vim.visualLine = true;
				} else {
					var operatorArgs = vim.inputState.operatorArgs;
					if (operatorArgs) operatorArgs.linewise = true;
					tmp.end.line--;
				}
			} else if (character === "t") tmp = expandTagUnderCursor(cm, head, inclusive);
			else return null;
			if (!cm.state.vim.visualMode) return [tmp.start, tmp.end];
			else return expandSelection(cm, tmp.start, tmp.end);
		},
		repeatLastCharacterSearch: function(cm, head, motionArgs) {
			var lastSearch = vimGlobalState.lastCharacterSearch;
			var repeat = motionArgs.repeat;
			var forward = motionArgs.forward === lastSearch.forward;
			var increment = (lastSearch.increment ? 1 : 0) * (forward ? -1 : 1);
			cm.moveH(-increment, "char");
			motionArgs.inclusive = forward ? true : false;
			var curEnd = moveToCharacter(cm, repeat, forward, lastSearch.selectedCharacter);
			if (!curEnd) {
				cm.moveH(increment, "char");
				return head;
			}
			curEnd.ch += increment;
			return curEnd;
		}
	};
	function defineMotion(name, fn) {
		motions[name] = fn;
	}
	function fillArray(val, times) {
		var arr = [];
		for (var i = 0; i < times; i++) arr.push(val);
		return arr;
	}
	/**
	* An operator acts on a text selection. It receives the list of selections
	* as input. The corresponding CodeMirror selection is guaranteed to
	* match the input selection.
	*/
	var operators = {
		change: function(cm, args, ranges) {
			var finalHead, text;
			var vim = cm.state.vim;
			var anchor = ranges[0].anchor, head = ranges[0].head;
			if (!vim.visualMode) {
				text = cm.getRange(anchor, head);
				var lastState = vim.lastEditInputState || {};
				if (lastState.motion == "moveByWords" && !isWhiteSpaceString(text)) {
					var match = /\s+$/.exec(text);
					if (match && lastState.motionArgs && lastState.motionArgs.forward) {
						head = offsetCursor(head, 0, -match[0].length);
						text = text.slice(0, -match[0].length);
					}
				}
				var prevLineEnd = new Pos(anchor.line - 1, Number.MAX_VALUE);
				var wasLastLine = cm.firstLine() == cm.lastLine();
				if (head.line > cm.lastLine() && args.linewise && !wasLastLine) cm.replaceRange("", prevLineEnd, head);
				else cm.replaceRange("", anchor, head);
				if (args.linewise) {
					if (!wasLastLine) {
						cm.setCursor(prevLineEnd);
						cm_adapter_default.commands.newlineAndIndent(cm);
					}
					anchor.ch = Number.MAX_VALUE;
				}
				finalHead = anchor;
			} else if (args.fullLine) {
				head.ch = Number.MAX_VALUE;
				head.line--;
				cm.setSelection(anchor, head);
				text = cm.getSelection();
				cm.replaceSelections("");
				finalHead = anchor;
			} else {
				text = cm.getSelection();
				var replacement = fillArray("", ranges.length);
				cm.replaceSelections(replacement);
				finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
			}
			vimGlobalState.registerController.pushText(args.registerName, "change", text, args.linewise, ranges.length > 1);
			actions.enterInsertMode(cm, { head: finalHead }, cm.state.vim);
		},
		delete: function(cm, args, ranges) {
			cm.pushUndoStop();
			var finalHead, text;
			var vim = cm.state.vim;
			if (!vim.visualBlock) {
				var anchor = ranges[0].anchor, head = ranges[0].head;
				if (args.linewise && head.line != cm.firstLine() && anchor.line == cm.lastLine() && anchor.line == head.line - 1) if (anchor.line == cm.firstLine()) anchor.ch = 0;
				else anchor = new Pos(anchor.line - 1, lineLength(cm, anchor.line - 1));
				text = cm.getRange(anchor, head);
				cm.replaceRange("", anchor, head);
				finalHead = anchor;
				if (args.linewise) finalHead = motions.moveToFirstNonWhiteSpaceCharacter(cm, anchor);
			} else {
				text = cm.getSelection();
				var replacement = fillArray("", ranges.length);
				cm.replaceSelections(replacement);
				finalHead = cursorMin(ranges[0].head, ranges[0].anchor);
			}
			vimGlobalState.registerController.pushText(args.registerName, "delete", text, args.linewise, vim.visualBlock);
			return clipCursorToContent(cm, finalHead);
		},
		indent: function(cm, args, ranges) {
			var vim = cm.state.vim;
			var startLine = ranges[0].anchor.line;
			var endLine = vim.visualBlock ? ranges[ranges.length - 1].anchor.line : ranges[0].head.line;
			var repeat = vim.visualMode ? args.repeat : 1;
			if (args.linewise) endLine--;
			cm.pushUndoStop();
			for (var i = startLine; i <= endLine; i++) for (var j = 0; j < repeat; j++) cm.indentLine(i, args.indentRight);
			cm.pushUndoStop();
			return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
		},
		indentAuto: function(cm, _args, ranges) {
			cm.execCommand("indentAuto");
			return motions.moveToFirstNonWhiteSpaceCharacter(cm, ranges[0].anchor);
		},
		changeCase: function(cm, args, ranges, oldAnchor, newHead) {
			var selections = cm.getSelections();
			var swapped = [];
			var toLower = args.toLower;
			for (var j = 0; j < selections.length; j++) {
				var toSwap = selections[j];
				var text = "";
				if (toLower === true) text = toSwap.toLowerCase();
				else if (toLower === false) text = toSwap.toUpperCase();
				else for (var i = 0; i < toSwap.length; i++) {
					var character = toSwap.charAt(i);
					text += isUpperCase(character) ? character.toLowerCase() : character.toUpperCase();
				}
				swapped.push(text);
			}
			cm.replaceSelections(swapped);
			if (args.shouldMoveCursor) return newHead;
			else if (!cm.state.vim.visualMode && args.linewise && ranges[0].anchor.line + 1 == ranges[0].head.line) return motions.moveToFirstNonWhiteSpaceCharacter(cm, oldAnchor);
			else if (args.linewise) return oldAnchor;
			else return cursorMin(ranges[0].anchor, ranges[0].head);
		},
		yank: function(cm, args, ranges, oldAnchor) {
			var vim = cm.state.vim;
			var text = cm.getSelection();
			var endPos = vim.visualMode ? cursorMin(vim.sel.anchor, vim.sel.head, ranges[0].head, ranges[0].anchor) : oldAnchor;
			vimGlobalState.registerController.pushText(args.registerName, "yank", text, args.linewise, vim.visualBlock);
			return endPos;
		}
	};
	function defineOperator(name, fn) {
		operators[name] = fn;
	}
	var actions = {
		jumpListWalk: function(cm, actionArgs, vim) {
			if (vim.visualMode) return;
			var repeat = actionArgs.repeat;
			var forward = actionArgs.forward;
			var mark = vimGlobalState.jumpList.move(cm, forward ? repeat : -repeat);
			var markPos = mark ? mark.find() : void 0;
			markPos = markPos ? markPos : cm.getCursor();
			cm.setCursor(markPos);
		},
		scroll: function(cm, actionArgs, vim) {
			if (vim.visualMode) return;
			var repeat = actionArgs.repeat || 1;
			var lineHeight = cm.defaultTextHeight();
			var top = cm.getScrollInfo().top;
			var delta = lineHeight * repeat;
			var newPos = actionArgs.forward ? top + delta : top - delta;
			var cursor = copyCursor(cm.getCursor());
			var cursorCoords = cm.charCoords(cursor, "local");
			if (actionArgs.forward) if (newPos > cursorCoords.top) {
				cursor.line += (newPos - cursorCoords.top) / lineHeight;
				cursor.line = Math.ceil(cursor.line);
				cm.setCursor(cursor);
				cursorCoords = cm.charCoords(cursor, "local");
				cm.scrollTo(null, cursorCoords.top);
			} else cm.scrollTo(null, newPos);
			else {
				var newBottom = newPos + cm.getScrollInfo().clientHeight;
				if (newBottom < cursorCoords.bottom) {
					cursor.line -= (cursorCoords.bottom - newBottom) / lineHeight;
					cursor.line = Math.floor(cursor.line);
					cm.setCursor(cursor);
					cursorCoords = cm.charCoords(cursor, "local");
					cm.scrollTo(null, cursorCoords.bottom - cm.getScrollInfo().clientHeight);
				} else cm.scrollTo(null, newPos);
			}
		},
		scrollToCursor: function(cm, actionArgs) {
			var lineNum = cm.getCursor().line;
			var charCoords = cm.charCoords(new Pos(lineNum, 0), "local");
			var height = cm.getScrollInfo().clientHeight;
			var y = charCoords.top;
			var lineHeight = charCoords.bottom - y;
			switch (actionArgs.position) {
				case "center":
					y = y - height / 2 + lineHeight;
					break;
				case "bottom":
					y = y - height + lineHeight;
					break;
			}
			cm.moveCurrentLineTo(y);
		},
		replayMacro: function(cm, actionArgs, vim) {
			var registerName = actionArgs.selectedCharacter;
			var repeat = actionArgs.repeat;
			var macroModeState = vimGlobalState.macroModeState;
			if (registerName == "@") registerName = macroModeState.latestRegister;
			else macroModeState.latestRegister = registerName;
			while (repeat--) executeMacroRegister(cm, vim, macroModeState, registerName);
		},
		enterMacroRecordMode: function(cm, actionArgs) {
			var macroModeState = vimGlobalState.macroModeState;
			var registerName = actionArgs.selectedCharacter;
			if (vimGlobalState.registerController.isValidRegister(registerName)) macroModeState.enterMacroRecordMode(cm, registerName);
		},
		toggleOverwrite: function(cm) {
			if (!cm.state.overwrite) {
				cm.toggleOverwrite(true);
				cm.setOption("keyMap", "vim-replace");
				cm_adapter_default.signal(cm, "vim-mode-change", { mode: "replace" });
			} else {
				cm.toggleOverwrite(false);
				cm.setOption("keyMap", "vim-insert");
				cm_adapter_default.signal(cm, "vim-mode-change", { mode: "insert" });
			}
		},
		enterInsertMode: function(cm, actionArgs, vim) {
			if (cm.getOption("readOnly")) return;
			vim.insertMode = true;
			vim.insertModeRepeat = actionArgs && actionArgs.repeat || 1;
			var insertAt = actionArgs ? actionArgs.insertAt : null;
			var sel = vim.sel;
			var head = actionArgs.head || cm.getCursor("head");
			var height = cm.listSelections().length;
			if (insertAt == "eol") head = new Pos(head.line, lineLength(cm, head.line));
			else if (insertAt == "bol") head = new Pos(head.line, 0);
			else if (insertAt == "charAfter") head = offsetCursor(head, 0, 1);
			else if (insertAt == "firstNonBlank") head = motions.moveToFirstNonWhiteSpaceCharacter(cm, head);
			else if (insertAt == "startOfSelectedArea") {
				if (!vim.visualMode) return;
				if (!vim.visualBlock) if (sel.head.line < sel.anchor.line) head = sel.head;
				else head = new Pos(sel.anchor.line, 0);
				else {
					head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.min(sel.head.ch, sel.anchor.ch));
					height = Math.abs(sel.head.line - sel.anchor.line) + 1;
				}
			} else if (insertAt == "endOfSelectedArea") {
				if (!vim.visualMode) return;
				if (!vim.visualBlock) if (sel.head.line >= sel.anchor.line) head = offsetCursor(sel.head, 0, 1);
				else head = new Pos(sel.anchor.line, 0);
				else {
					head = new Pos(Math.min(sel.head.line, sel.anchor.line), Math.max(sel.head.ch, sel.anchor.ch) + 1);
					height = Math.abs(sel.head.line - sel.anchor.line) + 1;
				}
			} else if (insertAt == "inplace") {
				if (vim.visualMode) return;
			} else if (insertAt == "lastEdit") head = getLastEditPos(cm) || head;
			cm.setOption("disableInput", false);
			if (actionArgs && actionArgs.replace) {
				cm.toggleOverwrite(true);
				cm.setOption("keyMap", "vim-replace");
				cm_adapter_default.signal(cm, "vim-mode-change", { mode: "replace" });
			} else {
				cm.toggleOverwrite(false);
				cm.setOption("keyMap", "vim-insert");
				cm_adapter_default.signal(cm, "vim-mode-change", { mode: "insert" });
			}
			if (!vimGlobalState.macroModeState.isPlaying) {
				cm.on("change", onChange);
				cm_adapter_default.on(cm.getInputField(), "keydown", onKeyEventTargetKeyDown);
			}
			if (vim.visualMode) exitVisualMode(cm);
			selectForInsert(cm, head, height);
		},
		toggleVisualMode: function(cm, actionArgs, vim) {
			var repeat = actionArgs.repeat;
			var anchor = cm.getCursor();
			var head;
			if (!vim.visualMode) {
				vim.visualMode = true;
				vim.visualLine = !!actionArgs.linewise;
				vim.visualBlock = !!actionArgs.blockwise;
				head = clipCursorToContent(cm, new Pos(anchor.line, anchor.ch + repeat - 1));
				vim.sel = {
					anchor,
					head
				};
				cm_adapter_default.signal(cm, "vim-mode-change", {
					mode: "visual",
					subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""
				});
				updateCmSelection(cm);
				updateMark(cm, vim, "<", cursorMin(anchor, head));
				updateMark(cm, vim, ">", cursorMax(anchor, head));
			} else if (vim.visualLine ^ actionArgs.linewise || vim.visualBlock ^ actionArgs.blockwise) {
				vim.visualLine = !!actionArgs.linewise;
				vim.visualBlock = !!actionArgs.blockwise;
				cm_adapter_default.signal(cm, "vim-mode-change", {
					mode: "visual",
					subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""
				});
				updateCmSelection(cm);
			} else exitVisualMode(cm);
		},
		reselectLastSelection: function(cm, _actionArgs, vim) {
			var lastSelection = vim.lastSelection;
			if (vim.visualMode) updateLastSelection(cm, vim);
			if (lastSelection) {
				var anchor = lastSelection.anchorMark.find();
				var head = lastSelection.headMark.find();
				if (!anchor || !head) return;
				vim.sel = {
					anchor,
					head
				};
				vim.visualMode = true;
				vim.visualLine = lastSelection.visualLine;
				vim.visualBlock = lastSelection.visualBlock;
				updateCmSelection(cm);
				updateMark(cm, vim, "<", cursorMin(anchor, head));
				updateMark(cm, vim, ">", cursorMax(anchor, head));
				cm_adapter_default.signal(cm, "vim-mode-change", {
					mode: "visual",
					subMode: vim.visualLine ? "linewise" : vim.visualBlock ? "blockwise" : ""
				});
			}
		},
		joinLines: function(cm, actionArgs, vim) {
			var curStart, curEnd;
			if (vim.visualMode) {
				curStart = cm.getCursor("anchor");
				curEnd = cm.getCursor("head");
				if (cursorIsBefore(curEnd, curStart)) {
					var tmp = curEnd;
					curEnd = curStart;
					curStart = tmp;
				}
				curEnd.ch = lineLength(cm, curEnd.line) - 1;
			} else {
				var repeat = Math.max(actionArgs.repeat, 2);
				curStart = cm.getCursor();
				curEnd = clipCursorToContent(cm, new Pos(curStart.line + repeat - 1, Infinity));
			}
			var finalCh = 0;
			for (var i = curStart.line; i < curEnd.line; i++) {
				finalCh = lineLength(cm, curStart.line);
				var tmp = new Pos(curStart.line + 1, lineLength(cm, curStart.line + 1));
				var text = cm.getRange(curStart, tmp);
				text = actionArgs.keepSpaces ? text.replace(/\n\r?/g, "") : text.replace(/\n\s*/g, " ");
				cm.replaceRange(text, curStart, tmp);
			}
			var curFinalPos = new Pos(curStart.line, finalCh);
			if (vim.visualMode) exitVisualMode(cm, false);
			cm.setCursor(curFinalPos);
		},
		newLineAndEnterInsertMode: function(cm, actionArgs, vim) {
			if (cm.getOption("readOnly")) return;
			vim.insertMode = true;
			var insertAt = copyCursor(cm.getCursor());
			if (insertAt.line === cm.firstLine() && !actionArgs.after) {
				cm.replaceRange("\n", new Pos(cm.firstLine(), 0));
				cm.setCursor(cm.firstLine(), 0);
			} else {
				insertAt.line = actionArgs.after ? insertAt.line : insertAt.line - 1;
				insertAt.ch = lineLength(cm, insertAt.line);
				cm.setCursor(insertAt);
				(cm_adapter_default.commands.newlineAndIndentContinueComment || cm_adapter_default.commands.newlineAndIndent)(cm);
			}
			this.enterInsertMode(cm, { repeat: actionArgs.repeat }, vim);
		},
		paste: function(cm, actionArgs, vim) {
			var cur = copyCursor(cm.getCursor());
			var register = vimGlobalState.registerController.getRegister(actionArgs.registerName);
			var text = register.toString();
			if (!text) return;
			if (actionArgs.matchIndent) {
				var tabSize = cm.getOption("tabSize");
				var whitespaceLength = function(str) {
					var tabs = str.split("	").length - 1;
					var spaces = str.split(" ").length - 1;
					return tabs * tabSize + spaces * 1;
				};
				var indent = whitespaceLength(cm.getLine(cm.getCursor().line).match(/^\s*/)[0]);
				var chompedText = text.replace(/\n$/, "");
				var wasChomped = text !== chompedText;
				var firstIndent = whitespaceLength(text.match(/^\s*/)[0]);
				var text = chompedText.replace(/^\s*/gm, function(wspace) {
					var newIndent = indent + (whitespaceLength(wspace) - firstIndent);
					if (newIndent < 0) return "";
					else if (cm.getOption("indentWithTabs")) {
						var quotient = Math.floor(newIndent / tabSize);
						return Array(quotient + 1).join("	");
					} else return Array(newIndent + 1).join(" ");
				});
				text += wasChomped ? "\n" : "";
			}
			if (actionArgs.repeat > 1) var text = Array(actionArgs.repeat + 1).join(text);
			var linewise = register.linewise;
			var blockwise = register.blockwise;
			if (blockwise) {
				text = text.split("\n");
				if (linewise) text.pop();
				for (var i = 0; i < text.length; i++) text[i] = text[i] == "" ? " " : text[i];
				cur.ch += actionArgs.after ? 1 : 0;
				cur.ch = Math.min(lineLength(cm, cur.line), cur.ch);
			} else if (linewise) if (vim.visualMode) text = vim.visualLine ? text.slice(0, -1) : "\n" + text.slice(0, text.length - 1) + "\n";
			else if (actionArgs.after) {
				text = "\n" + text.slice(0, text.length - 1);
				cur.ch = lineLength(cm, cur.line);
			} else cur.ch = 0;
			else cur.ch += actionArgs.after ? 1 : 0;
			var curPosFinal;
			var idx;
			if (vim.visualMode) {
				vim.lastPastedText = text;
				var lastSelectionCurEnd;
				var selectedArea = getSelectedAreaRange(cm, vim);
				var selectionStart = selectedArea[0];
				var selectionEnd = selectedArea[1];
				var selectedText = cm.getSelection();
				var selections = cm.listSelections();
				var emptyStrings = new Array(selections.length).join("1").split("1");
				if (vim.lastSelection) lastSelectionCurEnd = vim.lastSelection.headMark.find();
				vimGlobalState.registerController.unnamedRegister.setText(selectedText);
				if (blockwise) {
					cm.replaceSelections(emptyStrings);
					selectionEnd = new Pos(selectionStart.line + text.length - 1, selectionStart.ch);
					cm.setCursor(selectionStart);
					selectBlock(cm, selectionEnd);
					cm.replaceSelections(text);
					curPosFinal = selectionStart;
				} else if (vim.visualBlock) {
					cm.replaceSelections(emptyStrings);
					cm.setCursor(selectionStart);
					cm.replaceRange(text, selectionStart, selectionStart);
					curPosFinal = selectionStart;
				} else {
					cm.replaceRange(text, selectionStart, selectionEnd);
					curPosFinal = cm.posFromIndex(cm.indexFromPos(selectionStart) + text.length - 1);
				}
				if (lastSelectionCurEnd) vim.lastSelection.headMark = cm.setBookmark(lastSelectionCurEnd);
				if (linewise) curPosFinal.ch = 0;
			} else if (blockwise) {
				cm.setCursor(cur);
				for (var i = 0; i < text.length; i++) {
					var line = cur.line + i;
					if (line > cm.lastLine()) cm.replaceRange("\n", new Pos(line, 0));
					if (lineLength(cm, line) < cur.ch) extendLineToColumn(cm, line, cur.ch);
				}
				cm.setCursor(cur);
				selectBlock(cm, new Pos(cur.line + text.length - 1, cur.ch));
				cm.replaceSelections(text);
				curPosFinal = cur;
			} else {
				cm.replaceRange(text, cur);
				if (linewise && actionArgs.after) curPosFinal = new Pos(cur.line + 1, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line + 1)));
				else if (linewise && !actionArgs.after) curPosFinal = new Pos(cur.line, findFirstNonWhiteSpaceCharacter(cm.getLine(cur.line)));
				else if (!linewise && actionArgs.after) {
					idx = cm.indexFromPos(cur);
					curPosFinal = cm.posFromIndex(idx + text.length - 1);
				} else {
					idx = cm.indexFromPos(cur);
					curPosFinal = cm.posFromIndex(idx + text.length);
				}
			}
			if (vim.visualMode) exitVisualMode(cm, false);
			cm.setCursor(curPosFinal);
		},
		undo: function(cm, actionArgs) {
			cm.operation(function() {
				repeatFn(cm, cm_adapter_default.commands.undo, actionArgs.repeat)();
				cm.setCursor(cm.getCursor("anchor"));
			});
		},
		redo: function(cm, actionArgs) {
			repeatFn(cm, cm_adapter_default.commands.redo, actionArgs.repeat)();
		},
		setRegister: function(_cm, actionArgs, vim) {
			vim.inputState.registerName = actionArgs.selectedCharacter;
		},
		setMark: function(cm, actionArgs, vim) {
			var markName = actionArgs.selectedCharacter;
			updateMark(cm, vim, markName, cm.getCursor());
		},
		replace: function(cm, actionArgs, vim) {
			var replaceWith = actionArgs.selectedCharacter;
			var curStart = cm.getCursor();
			var replaceTo;
			var curEnd;
			var selections = cm.listSelections();
			if (vim.visualMode) {
				curStart = cm.getCursor("start");
				curEnd = cm.getCursor("end");
			} else {
				var line = cm.getLine(curStart.line);
				replaceTo = curStart.ch + actionArgs.repeat;
				if (replaceTo > line.length) replaceTo = line.length;
				curEnd = new Pos(curStart.line, replaceTo);
			}
			if (replaceWith == "\n") {
				if (!vim.visualMode) cm.replaceRange("", curStart, curEnd);
				(cm_adapter_default.commands.newlineAndIndentContinueComment || cm_adapter_default.commands.newlineAndIndent)(cm);
			} else {
				var replaceWithStr = cm.getRange(curStart, curEnd);
				replaceWithStr = replaceWithStr.replace(/[^\n]/g, replaceWith);
				if (vim.visualBlock) {
					var spaces = new Array(cm.getOption("tabSize") + 1).join(" ");
					replaceWithStr = cm.getSelection();
					replaceWithStr = replaceWithStr.replace(/\t/g, spaces).replace(/[^\n]/g, replaceWith).split("\n");
					cm.replaceSelections(replaceWithStr);
				} else cm.replaceRange(replaceWithStr, curStart, curEnd);
				if (vim.visualMode) {
					curStart = cursorIsBefore(selections[0].anchor, selections[0].head) ? selections[0].anchor : selections[0].head;
					cm.setCursor(curStart);
					exitVisualMode(cm, false);
				} else cm.setCursor(offsetCursor(curEnd, 0, -1));
			}
		},
		incrementNumberToken: function(cm, actionArgs) {
			var cur = cm.getCursor();
			var lineStr = cm.getLine(cur.line);
			var re = /(-?)(?:(0x)([\da-f]+)|(0b|0|)(\d+))/gi;
			var match;
			var start;
			var end;
			var numberStr;
			while ((match = re.exec(lineStr)) !== null) {
				start = match.index;
				end = start + match[0].length;
				if (cur.ch < end) break;
			}
			if (!actionArgs.backtrack && end <= cur.ch) return;
			if (match) {
				var baseStr = match[2] || match[4];
				var digits = match[3] || match[5];
				var increment = actionArgs.increase ? 1 : -1;
				var base = {
					"0b": 2,
					0: 8,
					"": 10,
					"0x": 16
				}[baseStr.toLowerCase()];
				numberStr = (parseInt(match[1] + digits, base) + increment * actionArgs.repeat).toString(base);
				var zeroPadding = baseStr ? new Array(digits.length - numberStr.length + 1 + match[1].length).join("0") : "";
				if (numberStr.charAt(0) === "-") numberStr = "-" + baseStr + zeroPadding + numberStr.substr(1);
				else numberStr = baseStr + zeroPadding + numberStr;
				var from = new Pos(cur.line, start);
				var to = new Pos(cur.line, end);
				cm.replaceRange(numberStr, from, to);
			} else return;
			cm.setCursor(new Pos(cur.line, start + numberStr.length - 1));
		},
		repeatLastEdit: function(cm, actionArgs, vim) {
			if (!vim.lastEditInputState) return;
			var repeat = actionArgs.repeat;
			if (repeat && actionArgs.repeatIsExplicit) vim.lastEditInputState.repeatOverride = repeat;
			else repeat = vim.lastEditInputState.repeatOverride || repeat;
			repeatLastEdit(
				cm,
				vim,
				repeat,
				false
				/** repeatForInsert */
			);
		},
		indent: function(cm, actionArgs) {
			cm.indentLine(cm.getCursor().line, actionArgs.indentRight);
		},
		exitInsertMode
	};
	function defineAction(name, fn) {
		actions[name] = fn;
	}
	/**
	* Clips cursor to ensure that line is within the buffer's range
	* If includeLineBreak is true, then allow cur.ch == lineLength.
	*/
	function clipCursorToContent(cm, cur) {
		var vim = cm.state.vim;
		var includeLineBreak = vim.insertMode || vim.visualMode;
		var line = Math.min(Math.max(cm.firstLine(), cur.line), cm.lastLine());
		var maxCh = lineLength(cm, line) - 1 + !!includeLineBreak;
		return new Pos(line, Math.min(Math.max(0, cur.ch), maxCh));
	}
	function copyArgs(args) {
		var ret = {};
		for (var prop in args) if (args.hasOwnProperty(prop)) ret[prop] = args[prop];
		return ret;
	}
	function offsetCursor(cur, offsetLine, offsetCh) {
		if (typeof offsetLine === "object") {
			offsetCh = offsetLine.ch;
			offsetLine = offsetLine.line;
		}
		return new Pos(cur.line + offsetLine, cur.ch + offsetCh);
	}
	function commandMatches(keys, keyMap, context, inputState) {
		var match, partial = [], full = [];
		for (var i = 0; i < keyMap.length; i++) {
			var command = keyMap[i];
			if (context == "insert" && command.context != "insert" || command.context && command.context != context || inputState.operator && command.type == "action" || !(match = commandMatch(keys, command.keys))) continue;
			if (match == "partial") partial.push(command);
			if (match == "full") full.push(command);
		}
		return {
			partial: partial.length && partial,
			full: full.length && full
		};
	}
	function commandMatch(pressed, mapped) {
		if (mapped.slice(-11) == "<character>") {
			var prefixLen = mapped.length - 11;
			var pressedPrefix = pressed.slice(0, prefixLen);
			var mappedPrefix = mapped.slice(0, prefixLen);
			return pressedPrefix == mappedPrefix && pressed.length > prefixLen ? "full" : mappedPrefix.indexOf(pressedPrefix) == 0 ? "partial" : false;
		} else return pressed == mapped ? "full" : mapped.indexOf(pressed) == 0 ? "partial" : false;
	}
	function lastChar(keys) {
		var match = /^.*(<[^>]+>)$/.exec(keys);
		var selectedCharacter = match ? match[1] : keys.slice(-1);
		if (selectedCharacter.length > 1) switch (selectedCharacter) {
			case "<CR>":
				selectedCharacter = "\n";
				break;
			case "<Space>":
				selectedCharacter = " ";
				break;
			default:
				selectedCharacter = "";
				break;
		}
		return selectedCharacter;
	}
	function repeatFn(cm, fn, repeat) {
		return function() {
			for (var i = 0; i < repeat; i++) fn(cm);
		};
	}
	function copyCursor(cur) {
		return new Pos(cur.line, cur.ch);
	}
	function cursorEqual(cur1, cur2) {
		return cur1.ch == cur2.ch && cur1.line == cur2.line;
	}
	function cursorIsBefore(cur1, cur2) {
		if (cur1.line < cur2.line) return true;
		if (cur1.line == cur2.line && cur1.ch < cur2.ch) return true;
		return false;
	}
	function cursorMin(cur1, cur2) {
		if (arguments.length > 2) cur2 = cursorMin.apply(void 0, Array.prototype.slice.call(arguments, 1));
		return cursorIsBefore(cur1, cur2) ? cur1 : cur2;
	}
	function cursorMax(cur1, cur2) {
		if (arguments.length > 2) cur2 = cursorMax.apply(void 0, Array.prototype.slice.call(arguments, 1));
		return cursorIsBefore(cur1, cur2) ? cur2 : cur1;
	}
	function cursorIsBetween(cur1, cur2, cur3) {
		var cur1before2 = cursorIsBefore(cur1, cur2);
		var cur2before3 = cursorIsBefore(cur2, cur3);
		return cur1before2 && cur2before3;
	}
	function lineLength(cm, lineNum) {
		return cm.getLine(lineNum).length;
	}
	function trim(s) {
		if (s.trim) return s.trim();
		return s.replace(/^\s+|\s+$/g, "");
	}
	function escapeRegex(s) {
		return s.replace(/([.?*+$\[\]\/\\(){}|\-])/g, "\\$1");
	}
	function extendLineToColumn(cm, lineNum, column) {
		var endCh = lineLength(cm, lineNum);
		var spaces = new Array(column - endCh + 1).join(" ");
		cm.setCursor(new Pos(lineNum, endCh));
		cm.replaceRange(spaces, cm.getCursor());
	}
	function selectBlock(cm, selectionEnd) {
		var selections = [], ranges = cm.listSelections();
		var head = copyCursor(cm.clipPos(selectionEnd));
		var isClipped = !cursorEqual(selectionEnd, head);
		var primIndex = getIndex(ranges, cm.getCursor("head"));
		var wasClipped = cursorEqual(ranges[primIndex].head, ranges[primIndex].anchor);
		var max = ranges.length - 1;
		var index = max - primIndex > primIndex ? max : 0;
		var base = ranges[index].anchor;
		var firstLine = Math.min(base.line, head.line);
		var lastLine = Math.max(base.line, head.line);
		var baseCh = base.ch, headCh = head.ch;
		var dir = ranges[index].head.ch - baseCh;
		var newDir = headCh - baseCh;
		if (dir > 0 && newDir <= 0) {
			baseCh++;
			if (!isClipped) headCh--;
		} else if (dir < 0 && newDir >= 0) {
			baseCh--;
			if (!wasClipped) headCh++;
		} else if (dir < 0 && newDir == -1) {
			baseCh--;
			headCh++;
		}
		for (var line = firstLine; line <= lastLine; line++) {
			var range = {
				anchor: new Pos(line, baseCh),
				head: new Pos(line, headCh)
			};
			selections.push(range);
		}
		cm.setSelections(selections);
		selectionEnd.ch = headCh;
		base.ch = baseCh;
		return base;
	}
	function selectForInsert(cm, head, height) {
		var sel = [];
		for (var i = 0; i < height; i++) {
			var lineHead = offsetCursor(head, i, 0);
			sel.push({
				anchor: lineHead,
				head: lineHead
			});
		}
		cm.setSelections(sel, 0);
	}
	function getIndex(ranges, cursor, end) {
		for (var i = 0; i < ranges.length; i++) {
			var atAnchor = end != "head" && cursorEqual(ranges[i].anchor, cursor);
			var atHead = end != "anchor" && cursorEqual(ranges[i].head, cursor);
			if (atAnchor || atHead) return i;
		}
		return -1;
	}
	function getSelectedAreaRange(cm, vim) {
		var lastSelection = vim.lastSelection;
		var getCurrentSelectedAreaRange = function() {
			var selections = cm.listSelections();
			var start = selections[0];
			var end = selections[selections.length - 1];
			return [cursorIsBefore(start.anchor, start.head) ? start.anchor : start.head, cursorIsBefore(end.anchor, end.head) ? end.head : end.anchor];
		};
		var getLastSelectedAreaRange = function() {
			var selectionStart = cm.getCursor();
			var selectionEnd = cm.getCursor();
			var block = lastSelection.visualBlock;
			if (block) {
				var width = block.width;
				var height = block.height;
				selectionEnd = new Pos(selectionStart.line + height, selectionStart.ch + width);
				var selections = [];
				for (var i = selectionStart.line; i < selectionEnd.line; i++) {
					var range = {
						anchor: new Pos(i, selectionStart.ch),
						head: new Pos(i, selectionEnd.ch)
					};
					selections.push(range);
				}
				cm.setSelections(selections);
			} else {
				var start = lastSelection.anchorMark.find();
				var end = lastSelection.headMark.find();
				var line = end.line - start.line;
				var ch = end.ch - start.ch;
				selectionEnd = {
					line: selectionEnd.line + line,
					ch: line ? selectionEnd.ch : ch + selectionEnd.ch
				};
				if (lastSelection.visualLine) {
					selectionStart = new Pos(selectionStart.line, 0);
					selectionEnd = new Pos(selectionEnd.line, lineLength(cm, selectionEnd.line));
				}
				cm.setSelection(selectionStart, selectionEnd);
			}
			return [selectionStart, selectionEnd];
		};
		if (!vim.visualMode) return getLastSelectedAreaRange();
		else return getCurrentSelectedAreaRange();
	}
	function updateLastSelection(cm, vim) {
		var anchor = vim.sel.anchor;
		var head = vim.sel.head;
		if (vim.lastPastedText) {
			head = cm.posFromIndex(cm.indexFromPos(anchor) + vim.lastPastedText.length);
			vim.lastPastedText = null;
		}
		vim.lastSelection = {
			anchorMark: cm.setBookmark(anchor),
			headMark: cm.setBookmark(head),
			anchor: copyCursor(anchor),
			head: copyCursor(head),
			visualMode: vim.visualMode,
			visualLine: vim.visualLine,
			visualBlock: vim.visualBlock
		};
	}
	function expandSelection(cm, start, end) {
		var sel = cm.state.vim.sel;
		var head = sel.head;
		var anchor = sel.anchor;
		var tmp;
		if (cursorIsBefore(end, start)) {
			tmp = end;
			end = start;
			start = tmp;
		}
		if (cursorIsBefore(head, anchor)) {
			head = cursorMin(start, head);
			anchor = cursorMax(anchor, end);
		} else {
			anchor = cursorMin(start, anchor);
			head = cursorMax(head, end);
			head = offsetCursor(head, 0, -1);
			if (head.ch == -1 && head.line != cm.firstLine()) head = new Pos(head.line - 1, lineLength(cm, head.line - 1));
		}
		return [anchor, head];
	}
	/**
	* Updates the CodeMirror selection to match the provided vim selection.
	* If no arguments are given, it uses the current vim selection state.
	*/
	function updateCmSelection(cm, sel, mode) {
		var vim = cm.state.vim;
		sel = sel || vim.sel;
		var mode = mode || vim.visualLine ? "line" : vim.visualBlock ? "block" : "char";
		var cmSel = makeCmSelection(cm, sel, mode);
		cm.setSelections(cmSel.ranges, cmSel.primary);
	}
	function makeCmSelection(cm, sel, mode, exclusive) {
		var head = copyCursor(sel.head);
		var anchor = copyCursor(sel.anchor);
		if (mode == "char") {
			var headOffset = !exclusive && !cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
			var anchorOffset = cursorIsBefore(sel.head, sel.anchor) ? 1 : 0;
			head = offsetCursor(sel.head, 0, headOffset);
			anchor = offsetCursor(sel.anchor, 0, anchorOffset);
			return {
				ranges: [{
					anchor,
					head
				}],
				primary: 0
			};
		} else if (mode == "line") {
			if (!cursorIsBefore(sel.head, sel.anchor)) {
				anchor.ch = 0;
				var lastLine = cm.lastLine();
				if (head.line > lastLine) head.line = lastLine;
				head.ch = lineLength(cm, head.line);
			} else {
				head.ch = 0;
				anchor.ch = lineLength(cm, anchor.line);
			}
			return {
				ranges: [{
					anchor,
					head
				}],
				primary: 0
			};
		} else if (mode == "block") {
			var top = Math.min(anchor.line, head.line), fromCh = anchor.ch, bottom = Math.max(anchor.line, head.line), toCh = head.ch;
			if (fromCh < toCh) toCh += 1;
			else fromCh += 1;
			var height = bottom - top + 1;
			var primary = head.line == top ? 0 : height - 1;
			var ranges = [];
			for (var i = 0; i < height; i++) ranges.push({
				anchor: new Pos(top + i, fromCh),
				head: new Pos(top + i, toCh)
			});
			return {
				ranges,
				primary
			};
		}
	}
	function getHead(cm) {
		var cur = cm.getCursor("head");
		if (cm.getSelection().length == 1) cur = cursorMin(cur, cm.getCursor("anchor"));
		return cur;
	}
	/**
	* If moveHead is set to false, the CodeMirror selection will not be
	* touched. The caller assumes the responsibility of putting the cursor
	* in the right place.
	*/
	function exitVisualMode(cm, moveHead) {
		var vim = cm.state.vim;
		if (moveHead !== false) cm.setCursor(clipCursorToContent(cm, vim.sel.head));
		updateLastSelection(cm, vim);
		vim.visualMode = false;
		vim.visualLine = false;
		vim.visualBlock = false;
		if (!vim.insertMode) cm_adapter_default.signal(cm, "vim-mode-change", { mode: "normal" });
	}
	function clipToLine(cm, curStart, curEnd) {
		var selection = cm.getRange(curStart, curEnd);
		if (/\n\s*$/.test(selection)) {
			var lines = selection.split("\n");
			lines.pop();
			var line;
			for (var line = lines.pop(); lines.length > 0 && line && isWhiteSpaceString(line); line = lines.pop()) {
				curEnd.line--;
				curEnd.ch = 0;
			}
			if (line) {
				curEnd.line--;
				curEnd.ch = lineLength(cm, curEnd.line);
			} else curEnd.ch = 0;
		}
	}
	function expandSelectionToLine(_cm, curStart, curEnd) {
		curStart.ch = 0;
		curEnd.ch = 0;
		curEnd.line++;
	}
	function findFirstNonWhiteSpaceCharacter(text) {
		if (!text) return 0;
		var firstNonWS = text.search(/\S/);
		return firstNonWS == -1 ? text.length : firstNonWS;
	}
	function expandWordUnderCursor(cm, inclusive, _forward, bigWord, noSymbol) {
		var cur = getHead(cm);
		var line = cm.getLine(cur.line);
		var idx = cur.ch;
		var test = noSymbol ? wordCharTest[0] : bigWordCharTest[0];
		while (!test(line.charAt(idx))) {
			idx++;
			if (idx >= line.length) return null;
		}
		if (bigWord) test = bigWordCharTest[0];
		else {
			test = wordCharTest[0];
			if (!test(line.charAt(idx))) test = wordCharTest[1];
		}
		var end = idx, start = idx;
		while (test(line.charAt(end)) && end < line.length) end++;
		while (test(line.charAt(start)) && start >= 0) start--;
		start++;
		if (inclusive) {
			var wordEnd = end;
			while (/\s/.test(line.charAt(end)) && end < line.length) end++;
			if (wordEnd == end) {
				var wordStart = start;
				while (/\s/.test(line.charAt(start - 1)) && start > 0) start--;
				if (!start) start = wordStart;
			}
		}
		return {
			start: new Pos(cur.line, start),
			end: new Pos(cur.line, end)
		};
	}
	/**
	* Depends on the following:
	*
	* - editor mode should be htmlmixedmode / xml
	* - mode/xml/xml.js should be loaded
	* - addon/fold/xml-fold.js should be loaded
	*
	* If any of the above requirements are not true, this function noops.
	*
	* This is _NOT_ a 100% accurate implementation of vim tag text objects.
	* The following caveats apply (based off cursory testing, I'm sure there
	* are other discrepancies):
	*
	* - Does not work inside comments:
	*   ```
	*   <!-- <div>broken</div> -->
	*   ```
	* - Does not work when tags have different cases:
	*   ```
	*   <div>broken</DIV>
	*   ```
	* - Does not work when cursor is inside a broken tag:
	*   ```
	*   <div><brok><en></div>
	*   ```
	*/
	function expandTagUnderCursor(cm, head, inclusive) {
		var cur = head;
		if (!cm_adapter_default.findMatchingTag || !cm_adapter_default.findEnclosingTag) return {
			start: cur,
			end: cur
		};
		var tags = cm_adapter_default.findMatchingTag(cm, head) || cm_adapter_default.findEnclosingTag(cm, head);
		if (!tags || !tags.open || !tags.close) return {
			start: cur,
			end: cur
		};
		if (inclusive) return {
			start: tags.open.from,
			end: tags.close.to
		};
		return {
			start: tags.open.to,
			end: tags.close.from
		};
	}
	function recordJumpPosition(cm, oldCur, newCur) {
		if (!cursorEqual(oldCur, newCur)) vimGlobalState.jumpList.add(cm, oldCur, newCur);
	}
	function recordLastCharacterSearch(increment, args) {
		vimGlobalState.lastCharacterSearch.increment = increment;
		vimGlobalState.lastCharacterSearch.forward = args.forward;
		vimGlobalState.lastCharacterSearch.selectedCharacter = args.selectedCharacter;
	}
	var symbolToMode = {
		"(": "bracket",
		")": "bracket",
		"{": "bracket",
		"}": "bracket",
		"[": "section",
		"]": "section",
		"*": "comment",
		"/": "comment",
		m: "method",
		M: "method",
		"#": "preprocess"
	};
	var findSymbolModes = {
		bracket: { isComplete: function(state) {
			if (state.nextCh === state.symb) {
				state.depth++;
				if (state.depth >= 1) return true;
			} else if (state.nextCh === state.reverseSymb) state.depth--;
			return false;
		} },
		section: {
			init: function(state) {
				state.curMoveThrough = true;
				state.symb = (state.forward ? "]" : "[") === state.symb ? "{" : "}";
			},
			isComplete: function(state) {
				return state.index === 0 && state.nextCh === state.symb;
			}
		},
		comment: { isComplete: function(state) {
			var found = state.lastCh === "*" && state.nextCh === "/";
			state.lastCh = state.nextCh;
			return found;
		} },
		method: {
			init: function(state) {
				state.symb = state.symb === "m" ? "{" : "}";
				state.reverseSymb = state.symb === "{" ? "}" : "{";
			},
			isComplete: function(state) {
				if (state.nextCh === state.symb) return true;
				return false;
			}
		},
		preprocess: {
			init: function(state) {
				state.index = 0;
			},
			isComplete: function(state) {
				if (state.nextCh === "#") {
					var token = state.lineText.match(/^#(\w+)/)[1];
					if (token === "endif") {
						if (state.forward && state.depth === 0) return true;
						state.depth++;
					} else if (token === "if") {
						if (!state.forward && state.depth === 0) return true;
						state.depth--;
					}
					if (token === "else" && state.depth === 0) return true;
				}
				return false;
			}
		}
	};
	function findSymbol(cm, repeat, forward, symb) {
		var cur = copyCursor(cm.getCursor());
		var increment = forward ? 1 : -1;
		var endLine = forward ? cm.lineCount() : -1;
		var curCh = cur.ch;
		var line = cur.line;
		var lineText = cm.getLine(line);
		var state = {
			lineText,
			nextCh: lineText.charAt(curCh),
			lastCh: null,
			index: curCh,
			symb,
			reverseSymb: (forward ? {
				")": "(",
				"}": "{"
			} : {
				"(": ")",
				"{": "}"
			})[symb],
			forward,
			depth: 0,
			curMoveThrough: false
		};
		var mode = symbolToMode[symb];
		if (!mode) return cur;
		var init = findSymbolModes[mode].init;
		var isComplete = findSymbolModes[mode].isComplete;
		if (init) init(state);
		while (line !== endLine && repeat) {
			state.index += increment;
			state.nextCh = state.lineText.charAt(state.index);
			if (!state.nextCh) {
				line += increment;
				state.lineText = cm.getLine(line) || "";
				if (increment > 0) state.index = 0;
				else {
					var lineLen = state.lineText.length;
					state.index = lineLen > 0 ? lineLen - 1 : 0;
				}
				state.nextCh = state.lineText.charAt(state.index);
			}
			if (isComplete(state)) {
				cur.line = line;
				cur.ch = state.index;
				repeat--;
			}
		}
		if (state.nextCh || state.curMoveThrough) return new Pos(line, state.index);
		return cur;
	}
	function findWord(cm, cur, forward, bigWord, emptyLineIsWord) {
		var lineNum = cur.line;
		var pos = cur.ch;
		var line = cm.getLine(lineNum);
		var dir = forward ? 1 : -1;
		var charTests = bigWord ? bigWordCharTest : wordCharTest;
		if (emptyLineIsWord && line == "") {
			lineNum += dir;
			line = cm.getLine(lineNum);
			if (!isLine(cm, lineNum)) return null;
			pos = forward ? 0 : line.length;
		}
		while (true) {
			if (emptyLineIsWord && line == "") return {
				from: 0,
				to: 0,
				line: lineNum
			};
			var stop = dir > 0 ? line.length : -1;
			var wordStart = stop, wordEnd = stop;
			while (pos != stop) {
				var foundWord = false;
				for (var i = 0; i < charTests.length && !foundWord; ++i) if (charTests[i](line.charAt(pos))) {
					wordStart = pos;
					while (pos != stop && charTests[i](line.charAt(pos))) pos += dir;
					wordEnd = pos;
					foundWord = wordStart != wordEnd;
					if (wordStart == cur.ch && lineNum == cur.line && wordEnd == wordStart + dir) continue;
					else return {
						from: Math.min(wordStart, wordEnd + 1),
						to: Math.max(wordStart, wordEnd),
						line: lineNum
					};
				}
				if (!foundWord) pos += dir;
			}
			lineNum += dir;
			if (!isLine(cm, lineNum)) return null;
			line = cm.getLine(lineNum);
			pos = dir > 0 ? 0 : line.length;
		}
	}
	/**
	* @param {CodeMirror} cm CodeMirror object.
	* @param {Pos} cur The position to start from.
	* @param {int} repeat Number of words to move past.
	* @param {boolean} forward True to search forward. False to search
	*     backward.
	* @param {boolean} wordEnd True to move to end of word. False to move to
	*     beginning of word.
	* @param {boolean} bigWord True if punctuation count as part of the word.
	*     False if only alphabet characters count as part of the word.
	* @return {Cursor} The position the cursor should move to.
	*/
	function moveToWord(cm, cur, repeat, forward, wordEnd, bigWord) {
		var curStart = copyCursor(cur);
		var words = [];
		if (forward && !wordEnd || !forward && wordEnd) repeat++;
		var emptyLineIsWord = !(forward && wordEnd);
		for (var i = 0; i < repeat; i++) {
			var word = findWord(cm, cur, forward, bigWord, emptyLineIsWord);
			if (!word) {
				var eodCh = lineLength(cm, cm.lastLine());
				words.push(forward ? {
					line: cm.lastLine(),
					from: eodCh,
					to: eodCh
				} : {
					line: 0,
					from: 0,
					to: 0
				});
				break;
			}
			words.push(word);
			cur = new Pos(word.line, forward ? word.to - 1 : word.from);
		}
		var shortCircuit = words.length != repeat;
		var firstWord = words[0];
		var lastWord = words.pop();
		if (forward && !wordEnd) {
			if (!shortCircuit && (firstWord.from != curStart.ch || firstWord.line != curStart.line)) lastWord = words.pop();
			return new Pos(lastWord.line, lastWord.from);
		} else if (forward && wordEnd) return new Pos(lastWord.line, lastWord.to - 1);
		else if (!forward && wordEnd) {
			if (!shortCircuit && (firstWord.to != curStart.ch || firstWord.line != curStart.line)) lastWord = words.pop();
			return new Pos(lastWord.line, lastWord.to);
		} else return new Pos(lastWord.line, lastWord.from);
	}
	function moveToEol(cm, head, motionArgs, vim, keepHPos) {
		var retval = new Pos(head.line + motionArgs.repeat - 1, Infinity);
		var end = cm.clipPos(retval);
		end.ch--;
		if (!keepHPos) {
			vim.lastHPos = Infinity;
			vim.lastHSPos = cm.charCoords(end, "div").left;
		}
		return retval;
	}
	function moveToCharacter(cm, repeat, forward, character) {
		var cur = cm.getCursor();
		var start = cur.ch;
		var idx;
		for (var i = 0; i < repeat; i++) {
			var line = cm.getLine(cur.line);
			idx = charIdxInLine(start, line, character, forward, true);
			if (idx == -1) return null;
			start = idx;
		}
		return new Pos(cm.getCursor().line, idx);
	}
	function moveToColumn(cm, repeat) {
		var line = cm.getCursor().line;
		return clipCursorToContent(cm, new Pos(line, repeat - 1));
	}
	function updateMark(cm, vim, markName, pos) {
		if (!inArray(markName, validMarks)) return;
		if (vim.marks[markName]) vim.marks[markName].clear();
		vim.marks[markName] = cm.setBookmark(pos);
	}
	function charIdxInLine(start, line, character, forward, includeChar) {
		var idx;
		if (forward) {
			idx = line.indexOf(character, start + 1);
			if (idx != -1 && !includeChar) idx -= 1;
		} else {
			idx = line.lastIndexOf(character, start - 1);
			if (idx != -1 && !includeChar) idx += 1;
		}
		return idx;
	}
	function findParagraph(cm, head, repeat, dir, inclusive) {
		var line = head.line;
		var min = cm.firstLine();
		var max = cm.lastLine();
		var start, end, i = line;
		function isEmpty(i$1) {
			return !cm.getLine(i$1);
		}
		function isBoundary(i$1, dir$1, any) {
			if (any) return isEmpty(i$1) != isEmpty(i$1 + dir$1);
			return !isEmpty(i$1) && isEmpty(i$1 + dir$1);
		}
		if (dir) {
			while (min <= i && i <= max && repeat > 0) {
				if (isBoundary(i, dir)) repeat--;
				i += dir;
			}
			return new Pos(i, 0);
		}
		var vim = cm.state.vim;
		if (vim.visualLine && isBoundary(line, 1, true)) {
			var anchor = vim.sel.anchor;
			if (isBoundary(anchor.line, -1, true)) {
				if (!inclusive || anchor.line != line) line += 1;
			}
		}
		var startState = isEmpty(line);
		for (i = line; i <= max && repeat; i++) if (isBoundary(i, 1, true)) {
			if (!inclusive || isEmpty(i) != startState) repeat--;
		}
		end = new Pos(i, 0);
		if (i > max && !startState) startState = true;
		else inclusive = false;
		for (i = line; i > min; i--) if (!inclusive || isEmpty(i) == startState || i == line) {
			if (isBoundary(i, -1, true)) break;
		}
		start = new Pos(i, 0);
		return {
			start,
			end
		};
	}
	function findSentence(cm, cur, repeat, dir) {
		function nextChar(cm$1, idx) {
			if (idx.pos + idx.dir < 0 || idx.pos + idx.dir >= idx.line.length) {
				idx.ln += idx.dir;
				if (!isLine(cm$1, idx.ln)) {
					idx.line = null;
					idx.ln = null;
					idx.pos = null;
					return;
				}
				idx.line = cm$1.getLine(idx.ln);
				idx.pos = idx.dir > 0 ? 0 : idx.line.length - 1;
			} else idx.pos += idx.dir;
		}
		function forward(cm$1, ln, pos, dir$1) {
			var line = cm$1.getLine(ln);
			var stop = line === "";
			var curr = {
				line,
				ln,
				pos,
				dir: dir$1
			};
			var last_valid = {
				ln: curr.ln,
				pos: curr.pos
			};
			var skip_empty_lines = curr.line === "";
			nextChar(cm$1, curr);
			while (curr.line !== null) {
				last_valid.ln = curr.ln;
				last_valid.pos = curr.pos;
				if (curr.line === "" && !skip_empty_lines) return {
					ln: curr.ln,
					pos: curr.pos
				};
				else if (stop && curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) return {
					ln: curr.ln,
					pos: curr.pos
				};
				else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && !stop && (curr.pos === curr.line.length - 1 || isWhiteSpaceString(curr.line[curr.pos + 1]))) stop = true;
				nextChar(cm$1, curr);
			}
			var line = cm$1.getLine(last_valid.ln);
			last_valid.pos = 0;
			for (var i = line.length - 1; i >= 0; --i) if (!isWhiteSpaceString(line[i])) {
				last_valid.pos = i;
				break;
			}
			return last_valid;
		}
		function reverse(cm$1, ln, pos, dir$1) {
			var line = cm$1.getLine(ln);
			var curr = {
				line,
				ln,
				pos,
				dir: dir$1
			};
			var last_valid = {
				ln: curr.ln,
				pos: null
			};
			var skip_empty_lines = curr.line === "";
			nextChar(cm$1, curr);
			while (curr.line !== null) {
				if (curr.line === "" && !skip_empty_lines) if (last_valid.pos !== null) return last_valid;
				else return {
					ln: curr.ln,
					pos: curr.pos
				};
				else if (isEndOfSentenceSymbol(curr.line[curr.pos]) && last_valid.pos !== null && !(curr.ln === last_valid.ln && curr.pos + 1 === last_valid.pos)) return last_valid;
				else if (curr.line !== "" && !isWhiteSpaceString(curr.line[curr.pos])) {
					skip_empty_lines = false;
					last_valid = {
						ln: curr.ln,
						pos: curr.pos
					};
				}
				nextChar(cm$1, curr);
			}
			var line = cm$1.getLine(last_valid.ln);
			last_valid.pos = 0;
			for (var i = 0; i < line.length; ++i) if (!isWhiteSpaceString(line[i])) {
				last_valid.pos = i;
				break;
			}
			return last_valid;
		}
		var curr_index = {
			ln: cur.line,
			pos: cur.ch
		};
		while (repeat > 0) {
			if (dir < 0) curr_index = reverse(cm, curr_index.ln, curr_index.pos, dir);
			else curr_index = forward(cm, curr_index.ln, curr_index.pos, dir);
			repeat--;
		}
		return new Pos(curr_index.ln, curr_index.pos);
	}
	function selectCompanionObject(cm, head, symb, inclusive) {
		var cur = head, start, end;
		var bracketRegexp = {
			"(": /[()]/,
			")": /[()]/,
			"[": /[[\]]/,
			"]": /[[\]]/,
			"{": /[{}]/,
			"}": /[{}]/,
			"<": /[<>]/,
			">": /[<>]/
		}[symb];
		var openSym = {
			"(": "(",
			")": "(",
			"[": "[",
			"]": "[",
			"{": "{",
			"}": "{",
			"<": "<",
			">": "<"
		}[symb];
		var offset = cm.getLine(cur.line).charAt(cur.ch) === openSym ? 1 : 0;
		start = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), -1, void 0, { bracketRegex: bracketRegexp });
		end = cm.scanForBracket(new Pos(cur.line, cur.ch + offset), 1, void 0, { bracketRegex: bracketRegexp });
		if (!start || !end) return {
			start: cur,
			end: cur
		};
		start = start.pos;
		end = end.pos;
		if (start.line == end.line && start.ch > end.ch || start.line > end.line) {
			var tmp = start;
			start = end;
			end = tmp;
		}
		if (inclusive) end.ch += 1;
		else start.ch += 1;
		return {
			start,
			end
		};
	}
	function findBeginningAndEnd(cm, head, symb, inclusive) {
		var cur = copyCursor(head);
		var chars = cm.getLine(cur.line).split("");
		var start, end, i, len;
		var firstIndex = chars.indexOf(symb);
		if (cur.ch < firstIndex) cur.ch = firstIndex;
		else if (firstIndex < cur.ch && chars[cur.ch] == symb) {
			end = cur.ch;
			--cur.ch;
		}
		if (chars[cur.ch] == symb && !end) start = cur.ch + 1;
		else for (i = cur.ch; i > -1 && !start; i--) if (chars[i] == symb) start = i + 1;
		if (start && !end) {
			for (i = start, len = chars.length; i < len && !end; i++) if (chars[i] == symb) end = i;
		}
		if (!start || !end) return {
			start: cur,
			end: cur
		};
		if (inclusive) {
			--start;
			++end;
		}
		return {
			start: new Pos(cur.line, start),
			end: new Pos(cur.line, end)
		};
	}
	defineOption("pcre", true, "boolean");
	function SearchState() {}
	SearchState.prototype = {
		getQuery: function() {
			return vimGlobalState.query;
		},
		setQuery: function(query) {
			vimGlobalState.query = query;
		},
		getOverlay: function() {
			return this.searchOverlay;
		},
		setOverlay: function(overlay) {
			this.searchOverlay = overlay;
		},
		isReversed: function() {
			return vimGlobalState.isReversed;
		},
		setReversed: function(reversed) {
			vimGlobalState.isReversed = reversed;
		},
		getScrollbarAnnotate: function() {
			return this.annotate;
		},
		setScrollbarAnnotate: function(annotate) {
			this.annotate = annotate;
		}
	};
	function getSearchState(cm) {
		var vim = cm.state.vim;
		return vim.searchState_ || (vim.searchState_ = new SearchState());
	}
	function splitBySlash(argString) {
		return splitBySeparator(argString, "/");
	}
	function findUnescapedSlashes(argString) {
		return findUnescapedSeparators(argString, "/");
	}
	function splitBySeparator(argString, separator) {
		var slashes = findUnescapedSeparators(argString, separator) || [];
		if (!slashes.length) return [];
		var tokens = [];
		if (slashes[0] !== 0) return;
		for (var i = 0; i < slashes.length; i++) if (typeof slashes[i] == "number") tokens.push(argString.substring(slashes[i] + 1, slashes[i + 1]));
		return tokens;
	}
	function findUnescapedSeparators(str, separator) {
		if (!separator) separator = "/";
		var escapeNextChar = false;
		var slashes = [];
		for (var i = 0; i < str.length; i++) {
			var c = str.charAt(i);
			if (!escapeNextChar && c == separator) slashes.push(i);
			escapeNextChar = !escapeNextChar && c == "\\";
		}
		return slashes;
	}
	function translateRegex(str) {
		var specials = "|(){";
		var unescape = "}";
		var escapeNextChar = false;
		var out = [];
		for (var i = -1; i < str.length; i++) {
			var c = str.charAt(i) || "";
			var n = str.charAt(i + 1) || "";
			var specialComesNext = n && specials.indexOf(n) != -1;
			if (escapeNextChar) {
				if (c !== "\\" || !specialComesNext) out.push(c);
				escapeNextChar = false;
			} else if (c === "\\") {
				escapeNextChar = true;
				if (n && unescape.indexOf(n) != -1) specialComesNext = true;
				if (!specialComesNext || n === "\\") out.push(c);
			} else {
				out.push(c);
				if (specialComesNext && n !== "\\") out.push("\\");
			}
		}
		return out.join("");
	}
	var charUnescapes = {
		"\\n": "\n",
		"\\r": "\r",
		"\\t": "	"
	};
	function translateRegexReplace(str) {
		var escapeNextChar = false;
		var out = [];
		for (var i = -1; i < str.length; i++) {
			var c = str.charAt(i) || "";
			var n = str.charAt(i + 1) || "";
			if (charUnescapes[c + n]) {
				out.push(charUnescapes[c + n]);
				i++;
			} else if (escapeNextChar) {
				out.push(c);
				escapeNextChar = false;
			} else if (c === "\\") {
				escapeNextChar = true;
				if (isNumber(n) || n === "$") out.push("$");
				else if (n !== "/" && n !== "\\") out.push("\\");
			} else {
				if (c === "$") out.push("$");
				out.push(c);
				if (n === "/") out.push("\\");
			}
		}
		return out.join("");
	}
	var unescapes = {
		"\\/": "/",
		"\\\\": "\\",
		"\\n": "\n",
		"\\r": "\r",
		"\\t": "	",
		"\\&": "&"
	};
	function unescapeRegexReplace(str) {
		var stream = new cm_adapter_default.StringStream(str);
		var output = [];
		while (!stream.eol()) {
			while (stream.peek() && stream.peek() != "\\") output.push(stream.next());
			var matched = false;
			for (var matcher in unescapes) if (stream.match(matcher, true)) {
				matched = true;
				output.push(unescapes[matcher]);
				break;
			}
			if (!matched) output.push(stream.next());
		}
		return output.join("");
	}
	/**
	* Extract the regular expression from the query and return a Regexp object.
	* Returns null if the query is blank.
	* If ignoreCase is passed in, the Regexp object will have the 'i' flag set.
	* If smartCase is passed in, and the query contains upper case letters,
	*   then ignoreCase is overridden, and the 'i' flag will not be set.
	* If the query contains the /i in the flag part of the regular expression,
	*   then both ignoreCase and smartCase are ignored, and 'i' will be passed
	*   through to the Regex object.
	*/
	function parseQuery(query, ignoreCase, smartCase) {
		vimGlobalState.registerController.getRegister("/").setText(query);
		if (query instanceof RegExp) return query;
		var slashes = findUnescapedSlashes(query);
		var regexPart;
		var forceIgnoreCase;
		if (!slashes.length) regexPart = query;
		else {
			regexPart = query.substring(0, slashes[0]);
			forceIgnoreCase = query.substring(slashes[0]).indexOf("i") != -1;
		}
		if (!regexPart) return null;
		if (!getOption("pcre")) regexPart = translateRegex(regexPart);
		if (smartCase) ignoreCase = /^[^A-Z]*$/.test(regexPart);
		return new RegExp(regexPart, ignoreCase || forceIgnoreCase ? "im" : "m");
	}
	/**
	* dom - Document Object Manipulator
	* Usage:
	*   dom('<tag>'|<node>[, ...{<attributes>|<$styles>}|<child-node>|'<text>'])
	* Examples:
	*   dom('div', {id:'xyz'}, dom('p', 'CM rocks!', {$color:'red'}))
	*   dom(document.head, dom('script', 'alert("hello!")'))
	* Not supported:
	*   dom('p', ['arrays are objects'], Error('objects specify attributes'))
	*/
	function dom(n) {
		if (typeof n === "string") n = document.createElement(n);
		for (var a, i = 1; i < arguments.length; i++) {
			if (!(a = arguments[i])) continue;
			if (typeof a !== "object") a = document.createTextNode(a);
			if (a.nodeType) n.appendChild(a);
			else for (var key in a) {
				if (!Object.prototype.hasOwnProperty.call(a, key)) continue;
				if (key[0] === "$") n.style[key.slice(1)] = a[key];
				else n.setAttribute(key, a[key]);
			}
		}
		return n;
	}
	function showConfirm(cm, template) {
		var pre = dom("pre", {
			$color: "red",
			class: "cm-vim-message"
		}, template);
		if (cm.openNotification) cm.openNotification(pre, {
			bottom: true,
			duration: 5e3
		});
		else alert(pre.innerText);
	}
	function makePrompt(prefix, desc) {
		return dom(document.createDocumentFragment(), dom("span", {
			$fontFamily: "monospace",
			$whiteSpace: "pre"
		}, prefix, dom("input", {
			type: "text",
			autocorrect: "off",
			autocapitalize: "off",
			spellcheck: "false"
		})), desc && dom("span", { $color: "#888" }, desc));
	}
	function showPrompt(cm, options$1) {
		var template = makePrompt(options$1.prefix, options$1.desc);
		if (cm.openDialog) cm.openDialog(template, options$1.onClose, {
			onKeyDown: options$1.onKeyDown,
			onKeyUp: options$1.onKeyUp,
			bottom: true,
			selectValueOnOpen: false,
			value: options$1.value
		});
		else {
			var shortText = "";
			if (typeof options$1.prefix != "string" && options$1.prefix) shortText += options$1.prefix.textContent;
			if (options$1.desc) shortText += " " + options$1.desc;
			options$1.onClose(prompt(shortText, ""));
		}
	}
	function regexEqual(r1, r2) {
		if (r1 instanceof RegExp && r2 instanceof RegExp) {
			var props = [
				"global",
				"multiline",
				"ignoreCase",
				"source"
			];
			for (var i = 0; i < props.length; i++) {
				var prop = props[i];
				if (r1[prop] !== r2[prop]) return false;
			}
			return true;
		}
		return false;
	}
	function updateSearchQuery(cm, rawQuery, ignoreCase, smartCase) {
		if (!rawQuery) return;
		var state = getSearchState(cm);
		var query = parseQuery(rawQuery, !!ignoreCase, !!smartCase);
		if (!query) return;
		highlightSearchMatches(cm, query);
		if (regexEqual(query, state.getQuery())) return query;
		state.setQuery(query);
		return query;
	}
	function searchOverlay(query) {
		if (query.source.charAt(0) == "^") var matchSol = true;
		return {
			token: function(stream) {
				if (matchSol && !stream.sol()) {
					stream.skipToEnd();
					return;
				}
				var match = stream.match(query, false);
				if (match) {
					if (match[0].length == 0) {
						stream.next();
						return "searching";
					}
					if (!stream.sol()) {
						stream.backUp(1);
						if (!query.exec(stream.next() + match[0])) {
							stream.next();
							return null;
						}
					}
					stream.match(query);
					return "searching";
				}
				while (!stream.eol()) {
					stream.next();
					if (stream.match(query, false)) break;
				}
			},
			query
		};
	}
	var highlightTimeout = 0;
	function highlightSearchMatches(cm, query) {
		clearTimeout(highlightTimeout);
		highlightTimeout = setTimeout(function() {
			if (!cm.state.vim) return;
			var searchState = getSearchState(cm);
			var overlay = searchState.getOverlay();
			if (!overlay || query != overlay.query) {
				if (overlay) cm.removeOverlay(overlay);
				overlay = searchOverlay(query);
				cm.addOverlay(overlay);
				if (cm.showMatchesOnScrollbar) {
					if (searchState.getScrollbarAnnotate()) searchState.getScrollbarAnnotate().clear();
					searchState.setScrollbarAnnotate(cm.showMatchesOnScrollbar(query));
				}
				searchState.setOverlay(overlay);
			}
		}, 50);
	}
	function findNext(cm, prev, query, repeat) {
		if (repeat === void 0) repeat = 1;
		return cm.operation(function() {
			var pos = cm.getCursor();
			var cursor = cm.getSearchCursor(query, pos);
			for (var i = 0; i < repeat; i++) {
				var found = cursor.find(prev);
				if (i == 0 && found && cursorEqual(cursor.from(), pos)) {
					var lastEndPos = prev ? cursor.from() : cursor.to();
					found = cursor.find(prev);
					if (found && !found[0] && cursorEqual(cursor.from(), lastEndPos)) {
						if (cm.getLine(lastEndPos.line).length == lastEndPos.ch) found = cursor.find(prev);
					}
				}
				if (!found) {
					cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));
					if (!cursor.find(prev)) return;
				}
			}
			return cursor.from();
		});
	}
	/**
	* Pretty much the same as `findNext`, except for the following differences:
	*
	* 1. Before starting the search, move to the previous search. This way if our cursor is
	* already inside a match, we should return the current match.
	* 2. Rather than only returning the cursor's from, we return the cursor's from and to as a tuple.
	*/
	function findNextFromAndToInclusive(cm, prev, query, repeat, vim) {
		if (repeat === void 0) repeat = 1;
		return cm.operation(function() {
			var pos = cm.getCursor();
			var cursor = cm.getSearchCursor(query, pos);
			var found = cursor.find(!prev);
			if (!vim.visualMode && found && cursorEqual(cursor.from(), pos)) cursor.find(!prev);
			for (var i = 0; i < repeat; i++) {
				found = cursor.find(prev);
				if (!found) {
					cursor = cm.getSearchCursor(query, prev ? new Pos(cm.lastLine()) : new Pos(cm.firstLine(), 0));
					if (!cursor.find(prev)) return;
				}
			}
			return [cursor.from(), cursor.to()];
		});
	}
	function clearSearchHighlight(cm) {
		var state = getSearchState(cm);
		cm.removeOverlay(getSearchState(cm).getOverlay());
		state.setOverlay(null);
		if (state.getScrollbarAnnotate()) {
			state.getScrollbarAnnotate().clear();
			state.setScrollbarAnnotate(null);
		}
	}
	/**
	* Check if pos is in the specified range, INCLUSIVE.
	* Range can be specified with 1 or 2 arguments.
	* If the first range argument is an array, treat it as an array of line
	* numbers. Match pos against any of the lines.
	* If the first range argument is a number,
	*   if there is only 1 range argument, check if pos has the same line
	*       number
	*   if there are 2 range arguments, then check if pos is in between the two
	*       range arguments.
	*/
	function isInRange(pos, start, end) {
		if (typeof pos != "number") pos = pos.line;
		if (start instanceof Array) return inArray(pos, start);
		else if (typeof end == "number") return pos >= start && pos <= end;
		else return pos == start;
	}
	function getUserVisibleLines(cm) {
		var scrollInfo = cm.getScrollInfo();
		var occludeToleranceTop = 6;
		var occludeToleranceBottom = 10;
		var from = cm.coordsChar({
			left: 0,
			top: occludeToleranceTop + scrollInfo.top
		}, "local");
		var bottomY = scrollInfo.clientHeight - occludeToleranceBottom + scrollInfo.top;
		var to = cm.coordsChar({
			left: 0,
			top: bottomY
		}, "local");
		return {
			top: from.line,
			bottom: to.line
		};
	}
	function getMarkPos(cm, vim, markName) {
		if (markName == "'" || markName == "`") return vimGlobalState.jumpList.find(cm, -1) || new Pos(0, 0);
		else if (markName == ".") return getLastEditPos(cm);
		var mark = vim.marks[markName];
		return mark && mark.find();
	}
	function getLastEditPos(cm) {
		var done = cm.doc.history.done;
		for (var i = done.length; i--;) if (done[i].changes) return copyCursor(done[i].changes[0].to);
	}
	var ExCommandDispatcher = function() {
		this.buildCommandMap_();
	};
	ExCommandDispatcher.prototype = {
		processCommand: function(cm, input, opt_params) {
			var that = this;
			cm.operation(function() {
				cm.curOp.isVimOp = true;
				that._processCommand(cm, input, opt_params);
			});
		},
		_processCommand: function(cm, input, opt_params) {
			var vim = cm.state.vim;
			var commandHistoryRegister = vimGlobalState.registerController.getRegister(":");
			var previousCommand = commandHistoryRegister.toString();
			if (vim.visualMode) exitVisualMode(cm);
			var inputStream = new cm_adapter_default.StringStream(input);
			commandHistoryRegister.setText(input);
			var params = opt_params || {};
			params.input = input;
			try {
				this.parseInput_(cm, inputStream, params);
			} catch (e) {
				showConfirm(cm, e.toString());
				throw e;
			}
			var command;
			var commandName;
			if (!params.commandName) {
				if (params.line !== void 0) commandName = "move";
			} else {
				command = this.matchCommand_(params.commandName);
				if (command) {
					commandName = command.name;
					if (command.excludeFromCommandHistory) commandHistoryRegister.setText(previousCommand);
					this.parseCommandArgs_(inputStream, params, command);
					if (command.type == "exToKey") {
						for (var i = 0; i < command.toKeys.length; i++) vimApi.handleKey(cm, command.toKeys[i], "mapping");
						return;
					} else if (command.type == "exToEx") {
						this.processCommand(cm, command.toInput);
						return;
					}
				}
			}
			if (!commandName) {
				showConfirm(cm, "Not an editor command \":" + input + "\"");
				return;
			}
			try {
				exCommands[commandName](cm, params);
				if ((!command || !command.possiblyAsync) && params.callback) params.callback();
			} catch (e) {
				showConfirm(cm, e.toString());
				throw e;
			}
		},
		parseInput_: function(cm, inputStream, result) {
			inputStream.eatWhile(":");
			if (inputStream.eat("%")) {
				result.line = cm.firstLine();
				result.lineEnd = cm.lastLine();
			} else {
				result.line = this.parseLineSpec_(cm, inputStream);
				if (result.line !== void 0 && inputStream.eat(",")) result.lineEnd = this.parseLineSpec_(cm, inputStream);
			}
			var commandMatch$1 = inputStream.match(/^(\w+|!!|@@|[!#&*<=>@~])/);
			if (commandMatch$1) result.commandName = commandMatch$1[1];
			else result.commandName = inputStream.match(/.*/)[0];
			return result;
		},
		parseLineSpec_: function(cm, inputStream) {
			var numberMatch = inputStream.match(/^(\d+)/);
			if (numberMatch) return parseInt(numberMatch[1], 10) - 1;
			switch (inputStream.next()) {
				case ".": return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
				case "$": return this.parseLineSpecOffset_(inputStream, cm.lastLine());
				case "'":
					var markName = inputStream.next();
					var markPos = getMarkPos(cm, cm.state.vim, markName);
					if (!markPos) throw new Error("Mark not set");
					return this.parseLineSpecOffset_(inputStream, markPos.line);
				case "-":
				case "+":
					inputStream.backUp(1);
					return this.parseLineSpecOffset_(inputStream, cm.getCursor().line);
				default:
					inputStream.backUp(1);
					return;
			}
		},
		parseLineSpecOffset_: function(inputStream, line) {
			var offsetMatch = inputStream.match(/^([+-])?(\d+)/);
			if (offsetMatch) {
				var offset = parseInt(offsetMatch[2], 10);
				if (offsetMatch[1] == "-") line -= offset;
				else line += offset;
			}
			return line;
		},
		parseCommandArgs_: function(inputStream, params, command) {
			if (inputStream.eol()) return;
			params.argString = inputStream.match(/.*/)[0];
			var delim = command.argDelimiter || /\s+/;
			var args = trim(params.argString).split(delim);
			if (args.length && args[0]) params.args = args;
		},
		matchCommand_: function(commandName) {
			for (var i = commandName.length; i > 0; i--) {
				var prefix = commandName.substring(0, i);
				if (this.commandMap_[prefix]) {
					var command = this.commandMap_[prefix];
					if (command.name.indexOf(commandName) === 0) return command;
				}
			}
			return null;
		},
		buildCommandMap_: function() {
			this.commandMap_ = {};
			for (var i = 0; i < defaultExCommandMap.length; i++) {
				var command = defaultExCommandMap[i];
				var key = command.shortName || command.name;
				this.commandMap_[key] = command;
			}
		},
		map: function(lhs, rhs, ctx) {
			if (lhs != ":" && lhs.charAt(0) == ":") {
				if (ctx) throw Error("Mode not supported for ex mappings");
				var commandName = lhs.substring(1);
				if (rhs != ":" && rhs.charAt(0) == ":") this.commandMap_[commandName] = {
					name: commandName,
					type: "exToEx",
					toInput: rhs.substring(1),
					user: true
				};
				else this.commandMap_[commandName] = {
					name: commandName,
					type: "exToKey",
					toKeys: rhs,
					user: true
				};
			} else if (rhs != ":" && rhs.charAt(0) == ":") {
				var mapping = {
					keys: lhs,
					type: "keyToEx",
					exArgs: { input: rhs.substring(1) }
				};
				if (ctx) mapping.context = ctx;
				defaultKeymap.unshift(mapping);
			} else {
				var mapping = {
					keys: lhs,
					type: "keyToKey",
					toKeys: rhs
				};
				if (ctx) mapping.context = ctx;
				defaultKeymap.unshift(mapping);
			}
		},
		unmap: function(lhs, ctx) {
			if (lhs != ":" && lhs.charAt(0) == ":") {
				if (ctx) throw Error("Mode not supported for ex mappings");
				var commandName = lhs.substring(1);
				if (this.commandMap_[commandName] && this.commandMap_[commandName].user) {
					delete this.commandMap_[commandName];
					return true;
				}
			} else {
				var keys = lhs;
				for (var i = 0; i < defaultKeymap.length; i++) if (keys == defaultKeymap[i].keys && defaultKeymap[i].context === ctx) {
					defaultKeymap.splice(i, 1);
					return true;
				}
			}
		}
	};
	var exCommands = {
		colorscheme: function(cm, params) {
			if (!params.args || params.args.length < 1) {
				showConfirm(cm, cm.getOption("theme"));
				return;
			}
			cm.setOption("theme", params.args[0]);
		},
		map: function(cm, params, ctx) {
			var mapArgs = params.args;
			if (!mapArgs || mapArgs.length < 2) {
				if (cm) showConfirm(cm, "Invalid mapping: " + params.input);
				return;
			}
			exCommandDispatcher.map(mapArgs[0], mapArgs[1], ctx);
		},
		imap: function(cm, params) {
			this.map(cm, params, "insert");
		},
		nmap: function(cm, params) {
			this.map(cm, params, "normal");
		},
		vmap: function(cm, params) {
			this.map(cm, params, "visual");
		},
		unmap: function(cm, params, ctx) {
			var mapArgs = params.args;
			if (!mapArgs || mapArgs.length < 1 || !exCommandDispatcher.unmap(mapArgs[0], ctx)) {
				if (cm) showConfirm(cm, "No such mapping: " + params.input);
			}
		},
		move: function(cm, params) {
			commandDispatcher.processCommand(cm, cm.state.vim, {
				type: "motion",
				motion: "moveToLineOrEdgeOfDocument",
				motionArgs: {
					forward: false,
					explicitRepeat: true,
					linewise: true
				},
				repeatOverride: params.line + 1
			});
		},
		set: function(cm, params) {
			var setArgs = params.args;
			var setCfg = params.setCfg || {};
			if (!setArgs || setArgs.length < 1) {
				if (cm) showConfirm(cm, "Invalid mapping: " + params.input);
				return;
			}
			var expr = setArgs[0].split("=");
			var optionName = expr[0];
			var value = expr[1];
			var forceGet = false;
			if (optionName.charAt(optionName.length - 1) == "?") {
				if (value) throw Error("Trailing characters: " + params.argString);
				optionName = optionName.substring(0, optionName.length - 1);
				forceGet = true;
			}
			if (value === void 0 && optionName.substring(0, 2) == "no") {
				optionName = optionName.substring(2);
				value = false;
			}
			var optionIsBoolean = options[optionName] && options[optionName].type == "boolean";
			if (optionIsBoolean && value == void 0) value = true;
			if (!optionIsBoolean && value === void 0 || forceGet) {
				var oldValue = getOption(optionName, cm, setCfg);
				if (oldValue instanceof Error) showConfirm(cm, oldValue.message);
				else if (oldValue === true || oldValue === false) showConfirm(cm, " " + (oldValue ? "" : "no") + optionName);
				else showConfirm(cm, "  " + optionName + "=" + oldValue);
			} else {
				var setOptionReturn = setOption(optionName, value, cm, setCfg);
				if (setOptionReturn instanceof Error) showConfirm(cm, setOptionReturn.message);
			}
		},
		setlocal: function(cm, params) {
			params.setCfg = { scope: "local" };
			this.set(cm, params);
		},
		setglobal: function(cm, params) {
			params.setCfg = { scope: "global" };
			this.set(cm, params);
		},
		registers: function(cm, params) {
			var regArgs = params.args;
			var registers = vimGlobalState.registerController.registers;
			var regInfo = "----------Registers----------\n\n";
			if (!regArgs) for (var registerName in registers) {
				var text = registers[registerName].toString();
				if (text.length) regInfo += "\"" + registerName + "    " + text + "\n";
			}
			else {
				var registerName;
				regArgs = regArgs.join("");
				for (var i = 0; i < regArgs.length; i++) {
					registerName = regArgs.charAt(i);
					if (!vimGlobalState.registerController.isValidRegister(registerName)) continue;
					var register = registers[registerName] || new Register();
					regInfo += "\"" + registerName + "    " + register.toString() + "\n";
				}
			}
			showConfirm(cm, regInfo);
		},
		sort: function(cm, params) {
			var reverse, ignoreCase, unique$1, number, pattern;
			function parseArgs() {
				if (params.argString) {
					var args = new cm_adapter_default.StringStream(params.argString);
					if (args.eat("!")) reverse = true;
					if (args.eol()) return;
					if (!args.eatSpace()) return "Invalid arguments";
					var opts = args.match(/([dinuox]+)?\s*(\/.+\/)?\s*/);
					if (!opts && !args.eol()) return "Invalid arguments";
					if (opts[1]) {
						ignoreCase = opts[1].indexOf("i") != -1;
						unique$1 = opts[1].indexOf("u") != -1;
						var decimal = opts[1].indexOf("d") != -1 || opts[1].indexOf("n") != -1 && 1;
						var hex = opts[1].indexOf("x") != -1 && 1;
						var octal = opts[1].indexOf("o") != -1 && 1;
						if (decimal + hex + octal > 1) return "Invalid arguments";
						number = decimal && "decimal" || hex && "hex" || octal && "octal";
					}
					if (opts[2]) pattern = new RegExp(opts[2].substr(1, opts[2].length - 2), ignoreCase ? "i" : "");
				}
			}
			var err = parseArgs();
			if (err) {
				showConfirm(cm, err + ": " + params.argString);
				return;
			}
			var lineStart = params.line || cm.firstLine();
			var lineEnd = params.lineEnd || params.line || cm.lastLine();
			if (lineStart == lineEnd) return;
			var curStart = new Pos(lineStart, 0);
			var curEnd = new Pos(lineEnd, lineLength(cm, lineEnd));
			var text = cm.getRange(curStart, curEnd).split("\n");
			var numberRegex$1 = pattern ? pattern : number == "decimal" ? /(-?)([\d]+)/ : number == "hex" ? /(-?)(?:0x)?([0-9a-f]+)/i : number == "octal" ? /([0-7]+)/ : null;
			var radix = number == "decimal" ? 10 : number == "hex" ? 16 : number == "octal" ? 8 : null;
			var numPart = [], textPart = [];
			if (number || pattern) for (var i = 0; i < text.length; i++) {
				var matchPart = pattern ? text[i].match(pattern) : null;
				if (matchPart && matchPart[0] != "") numPart.push(matchPart);
				else if (!pattern && numberRegex$1.exec(text[i])) numPart.push(text[i]);
				else textPart.push(text[i]);
			}
			else textPart = text;
			function compareFn(a, b) {
				if (reverse) {
					var tmp = a;
					a = b;
					b = tmp;
				}
				if (ignoreCase) {
					a = a.toLowerCase();
					b = b.toLowerCase();
				}
				var anum = number && numberRegex$1.exec(a);
				var bnum = number && numberRegex$1.exec(b);
				if (!anum) return a < b ? -1 : 1;
				anum = parseInt((anum[1] + anum[2]).toLowerCase(), radix);
				bnum = parseInt((bnum[1] + bnum[2]).toLowerCase(), radix);
				return anum - bnum;
			}
			function comparePatternFn(a, b) {
				if (reverse) {
					var tmp = a;
					a = b;
					b = tmp;
				}
				if (ignoreCase) {
					a[0] = a[0].toLowerCase();
					b[0] = b[0].toLowerCase();
				}
				return a[0] < b[0] ? -1 : 1;
			}
			numPart.sort(pattern ? comparePatternFn : compareFn);
			if (pattern) for (var i = 0; i < numPart.length; i++) numPart[i] = numPart[i].input;
			else if (!number) textPart.sort(compareFn);
			text = !reverse ? textPart.concat(numPart) : numPart.concat(textPart);
			if (unique$1) {
				var textOld = text;
				var lastLine;
				text = [];
				for (var i = 0; i < textOld.length; i++) {
					if (textOld[i] != lastLine) text.push(textOld[i]);
					lastLine = textOld[i];
				}
			}
			cm.replaceRange(text.join("\n"), curStart, curEnd);
		},
		vglobal: function(cm, params) {
			this.global(cm, params);
		},
		global: function(cm, params) {
			var argString = params.argString;
			if (!argString) {
				showConfirm(cm, "Regular Expression missing from global");
				return;
			}
			var inverted = params.commandName[0] === "v";
			var lineStart = params.line !== void 0 ? params.line : cm.firstLine();
			var lineEnd = params.lineEnd || params.line || cm.lastLine();
			var tokens = splitBySlash(argString);
			var regexPart = argString, cmd;
			if (tokens.length) {
				regexPart = tokens[0];
				cmd = tokens.slice(1, tokens.length).join("/");
			}
			if (regexPart) try {
				updateSearchQuery(cm, regexPart, true, true);
			} catch (e) {
				showConfirm(cm, "Invalid regex: " + regexPart);
				return;
			}
			var query = getSearchState(cm).getQuery();
			var matchedLines = [];
			for (var i = lineStart; i <= lineEnd; i++) {
				var line = cm.getLineHandle(i);
				if (query.test(line.text) !== inverted) matchedLines.push(cmd ? line : line.text);
			}
			if (!cmd) {
				showConfirm(cm, matchedLines.join("\n"));
				return;
			}
			var index = 0;
			var nextCommand = function() {
				if (index < matchedLines.length) {
					var line$1 = matchedLines[index++];
					var lineNum = cm.getLineNumber(line$1);
					if (lineNum == null) {
						nextCommand();
						return;
					}
					var command = lineNum + 1 + cmd;
					exCommandDispatcher.processCommand(cm, command, { callback: nextCommand });
				}
			};
			nextCommand();
		},
		substitute: function(cm, params) {
			if (!cm.getSearchCursor) throw new Error("Search feature not available. Requires searchcursor.js or any other getSearchCursor implementation.");
			var argString = params.argString;
			var tokens = argString ? splitBySeparator(argString, argString[0]) : [];
			var regexPart, replacePart = "", trailing, flagsPart, count;
			var confirm = false;
			var global$1 = false;
			if (tokens.length) {
				regexPart = tokens[0];
				if (getOption("pcre") && regexPart !== "") regexPart = new RegExp(regexPart).source;
				replacePart = tokens[1];
				if (replacePart !== void 0) {
					if (getOption("pcre")) replacePart = unescapeRegexReplace(replacePart.replace(/([^\\])&/g, "$1$$&"));
					else replacePart = translateRegexReplace(replacePart);
					vimGlobalState.lastSubstituteReplacePart = replacePart;
				}
				trailing = tokens[2] ? tokens[2].split(" ") : [];
			} else if (argString && argString.length) {
				showConfirm(cm, "Substitutions should be of the form :s/pattern/replace/");
				return;
			}
			if (trailing) {
				flagsPart = trailing[0];
				count = parseInt(trailing[1]);
				if (flagsPart) {
					if (flagsPart.indexOf("c") != -1) confirm = true;
					if (flagsPart.indexOf("g") != -1) global$1 = true;
					if (getOption("pcre")) regexPart = regexPart + "/" + flagsPart;
					else regexPart = regexPart.replace(/\//g, "\\/") + "/" + flagsPart;
				}
			}
			if (regexPart) try {
				updateSearchQuery(cm, regexPart, true, true);
			} catch (e) {
				showConfirm(cm, "Invalid regex: " + regexPart);
				return;
			}
			replacePart = replacePart || vimGlobalState.lastSubstituteReplacePart;
			if (replacePart === void 0) {
				showConfirm(cm, "No previous substitute regular expression");
				return;
			}
			var query = getSearchState(cm).getQuery();
			var lineStart = params.line !== void 0 ? params.line : cm.getCursor().line;
			var lineEnd = params.lineEnd || lineStart;
			if (lineStart == cm.firstLine() && lineEnd == cm.lastLine()) lineEnd = Infinity;
			if (count) {
				lineStart = lineEnd;
				lineEnd = lineStart + count - 1;
			}
			var startPos = clipCursorToContent(cm, new Pos(lineStart, 0));
			var cursor = cm.getSearchCursor(query, startPos);
			cm.pushUndoStop();
			doReplace(cm, confirm, global$1, lineStart, lineEnd, cursor, query, replacePart, params.callback);
		},
		redo: cm_adapter_default.commands.redo,
		undo: cm_adapter_default.commands.undo,
		write: function(cm) {
			if (cm_adapter_default.commands.save) cm_adapter_default.commands.save(cm);
			else if (cm.save) cm.save();
		},
		nohlsearch: function(cm) {
			clearSearchHighlight(cm);
		},
		yank: function(cm) {
			var line = copyCursor(cm.getCursor()).line;
			var lineText = cm.getLine(line);
			vimGlobalState.registerController.pushText("0", "yank", lineText, true, true);
		},
		delmarks: function(cm, params) {
			if (!params.argString || !trim(params.argString)) {
				showConfirm(cm, "Argument required");
				return;
			}
			var state = cm.state.vim;
			var stream = new cm_adapter_default.StringStream(trim(params.argString));
			while (!stream.eol()) {
				stream.eatSpace();
				var count = stream.pos;
				if (!stream.match(/[a-zA-Z]/, false)) {
					showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
					return;
				}
				var sym = stream.next();
				if (stream.match("-", true)) {
					if (!stream.match(/[a-zA-Z]/, false)) {
						showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
						return;
					}
					var startMark = sym;
					var finishMark = stream.next();
					if (isLowerCase(startMark) && isLowerCase(finishMark) || isUpperCase(startMark) && isUpperCase(finishMark)) {
						var start = startMark.charCodeAt(0);
						var finish = finishMark.charCodeAt(0);
						if (start >= finish) {
							showConfirm(cm, "Invalid argument: " + params.argString.substring(count));
							return;
						}
						for (var j = 0; j <= finish - start; j++) {
							var mark = String.fromCharCode(start + j);
							delete state.marks[mark];
						}
					} else {
						showConfirm(cm, "Invalid argument: " + startMark + "-");
						return;
					}
				} else delete state.marks[sym];
			}
		}
	};
	var exCommandDispatcher = new ExCommandDispatcher();
	/**
	* @param {CodeMirror} cm CodeMirror instance we are in.
	* @param {boolean} confirm Whether to confirm each replace.
	* @param {Cursor} lineStart Line to start replacing from.
	* @param {Cursor} lineEnd Line to stop replacing at.
	* @param {RegExp} query Query for performing matches with.
	* @param {string} replaceWith Text to replace matches with. May contain $1,
	*     $2, etc for replacing captured groups using JavaScript replace.
	* @param {function()} callback A callback for when the replace is done.
	*/
	function doReplace(cm, confirm, global$1, lineStart, lineEnd, searchCursor, query, replaceWith, callback) {
		cm.state.vim.exMode = true;
		var done = false;
		var lastPos, modifiedLineNumber, joined;
		function replaceAll() {
			cm.operation(function() {
				while (!done) {
					replace();
					next();
				}
				stop();
			});
		}
		function replace() {
			var newText = cm.getRange(searchCursor.from(), searchCursor.to()).replace(query, replaceWith);
			var unmodifiedLineNumber = searchCursor.to().line;
			searchCursor.replace(newText);
			modifiedLineNumber = searchCursor.to().line;
			lineEnd += modifiedLineNumber - unmodifiedLineNumber;
			joined = modifiedLineNumber < unmodifiedLineNumber;
		}
		function findNextValidMatch() {
			var lastMatchTo = lastPos && copyCursor(searchCursor.to());
			var match = searchCursor.findNext();
			if (match && !match[0] && lastMatchTo && cursorEqual(searchCursor.from(), lastMatchTo)) match = searchCursor.findNext();
			return match;
		}
		function next() {
			while (findNextValidMatch() && isInRange(searchCursor.from(), lineStart, lineEnd)) {
				if (!global$1 && searchCursor.from().line == modifiedLineNumber && !joined) continue;
				cm.scrollIntoView(searchCursor.from(), 30);
				cm.setSelection(searchCursor.from(), searchCursor.to());
				lastPos = searchCursor.from();
				done = false;
				return;
			}
			done = true;
		}
		function stop(close) {
			if (close) close();
			cm.focus();
			if (lastPos) {
				cm.setCursor(lastPos);
				var vim = cm.state.vim;
				vim.exMode = false;
				vim.lastHPos = vim.lastHSPos = lastPos.ch;
			}
			if (callback) callback();
		}
		function onPromptKeyDown(e, _value, close) {
			cm_adapter_default.e_stop(e);
			switch (cm_adapter_default.keyName(e)) {
				case "Y":
					replace();
					next();
					break;
				case "N":
					next();
					break;
				case "A":
					var savedCallback = callback;
					callback = void 0;
					cm.operation(replaceAll);
					callback = savedCallback;
					break;
				case "L": replace();
				case "Q":
				case "Esc":
				case "Ctrl-C":
				case "Ctrl-[":
					stop(close);
					break;
			}
			if (done) stop(close);
			return true;
		}
		next();
		if (done) {
			showConfirm(cm, "No matches for " + query.source);
			return;
		}
		if (!confirm) {
			replaceAll();
			if (callback) callback();
			return;
		}
		showPrompt(cm, {
			prefix: dom("span", "replace with ", dom("strong", replaceWith), " (y/n/a/q/l)"),
			onKeyDown: onPromptKeyDown
		});
	}
	cm_adapter_default.keyMap.vim = {
		attach: attachVimMap,
		detach: detachVimMap,
		call: cmKey
	};
	function exitInsertMode(cm) {
		var vim = cm.state.vim;
		var macroModeState = vimGlobalState.macroModeState;
		var insertModeChangeRegister = vimGlobalState.registerController.getRegister(".");
		var isPlaying = macroModeState.isPlaying;
		var lastChange = macroModeState.lastInsertModeChanges;
		if (!isPlaying) {
			cm.off("change", onChange);
			cm_adapter_default.off(cm.getInputField(), "keydown", onKeyEventTargetKeyDown);
		}
		if (!isPlaying && vim.insertModeRepeat > 1) {
			repeatLastEdit(cm, vim, vim.insertModeRepeat - 1, true);
			vim.lastEditInputState.repeatOverride = vim.insertModeRepeat;
		}
		delete vim.insertModeRepeat;
		vim.insertMode = false;
		cm.setCursor(cm.getCursor().line, cm.getCursor().ch - 1);
		cm.setOption("keyMap", "vim");
		cm.setOption("disableInput", true);
		cm.toggleOverwrite(false);
		insertModeChangeRegister.setText(lastChange.changes.join(""));
		cm_adapter_default.signal(cm, "vim-mode-change", { mode: "normal" });
		if (macroModeState.isRecording) logInsertModeChange(macroModeState);
		cm.enterVimMode();
	}
	function _mapCommand(command) {
		defaultKeymap.unshift(command);
	}
	function mapCommand(keys, type, name, args, extra) {
		var command = {
			keys,
			type
		};
		command[type] = name;
		command[type + "Args"] = args;
		for (var key in extra) command[key] = extra[key];
		_mapCommand(command);
	}
	defineOption("insertModeEscKeysTimeout", 200, "number");
	cm_adapter_default.keyMap["vim-insert"] = {
		fallthrough: ["default"],
		attach: attachVimMap,
		detach: detachVimMap,
		call: cmKey
	};
	cm_adapter_default.keyMap["vim-replace"] = {
		Backspace: "goCharLeft",
		fallthrough: ["vim-insert"],
		attach: attachVimMap,
		detach: detachVimMap,
		call: cmKey
	};
	function executeMacroRegister(cm, vim, macroModeState, registerName) {
		var register = vimGlobalState.registerController.getRegister(registerName);
		if (registerName == ":") {
			if (register.keyBuffer[0]) exCommandDispatcher.processCommand(cm, register.keyBuffer[0]);
			macroModeState.isPlaying = false;
			return;
		}
		var keyBuffer = register.keyBuffer;
		var imc = 0;
		macroModeState.isPlaying = true;
		macroModeState.replaySearchQueries = register.searchQueries.slice(0);
		for (var i = 0; i < keyBuffer.length; i++) {
			var text = keyBuffer[i];
			var match, key;
			while (text) {
				match = /<\w+-.+?>|<\w+>|./.exec(text);
				key = match[0];
				text = text.substring(match.index + key.length);
				vimApi.handleKey(cm, key, "macro");
				if (vim.insertMode) {
					var changes = register.insertModeChanges[imc++].changes;
					vimGlobalState.macroModeState.lastInsertModeChanges.changes = changes;
					repeatInsertModeChanges(cm, changes, 1);
					exitInsertMode(cm);
				}
			}
		}
		macroModeState.isPlaying = false;
	}
	function logKey(macroModeState, key) {
		if (macroModeState.isPlaying) return;
		var registerName = macroModeState.latestRegister;
		var register = vimGlobalState.registerController.getRegister(registerName);
		if (register) register.pushText(key);
	}
	function logInsertModeChange(macroModeState) {
		if (macroModeState.isPlaying) return;
		var registerName = macroModeState.latestRegister;
		var register = vimGlobalState.registerController.getRegister(registerName);
		if (register && register.pushInsertModeChanges) register.pushInsertModeChanges(macroModeState.lastInsertModeChanges);
	}
	function logSearchQuery(macroModeState, query) {
		if (macroModeState.isPlaying) return;
		var registerName = macroModeState.latestRegister;
		var register = vimGlobalState.registerController.getRegister(registerName);
		if (register && register.pushSearchQuery) register.pushSearchQuery(query);
	}
	/**
	* Listens for changes made in insert mode.
	* Should only be active in insert mode.
	*/
	function onChange(cm, changeObj) {
		var macroModeState = vimGlobalState.macroModeState;
		var lastChange = macroModeState.lastInsertModeChanges;
		if (!macroModeState.isPlaying) while (changeObj) {
			lastChange.expectCursorActivityForChange = true;
			if (lastChange.ignoreCount > 1) lastChange.ignoreCount--;
			else if (changeObj.origin == "+input" || changeObj.origin == "paste" || changeObj.origin === void 0) {
				var selectionCount = cm.listSelections().length;
				if (selectionCount > 1) lastChange.ignoreCount = selectionCount;
				var text = changeObj.text.join("\n");
				if (lastChange.maybeReset) {
					lastChange.changes = [];
					lastChange.maybeReset = false;
				}
				if (text) if (cm.state.overwrite && !/\n/.test(text)) lastChange.changes.push([text]);
				else lastChange.changes.push(text);
			}
			changeObj = changeObj.next;
		}
	}
	/**
	* Listens for any kind of cursor activity on CodeMirror.
	*/
	function onCursorActivity(cm) {
		var vim = cm.state.vim;
		if (vim.insertMode) {
			var macroModeState = vimGlobalState.macroModeState;
			if (macroModeState.isPlaying) return;
			var lastChange = macroModeState.lastInsertModeChanges;
			if (lastChange.expectCursorActivityForChange) lastChange.expectCursorActivityForChange = false;
			else lastChange.maybeReset = true;
		} else if (!cm.curOp.isVimOp) handleExternalSelection(cm, vim);
	}
	function handleExternalSelection(cm, vim) {
		var anchor = cm.getCursor("anchor");
		var head = cm.getCursor("head");
		if (vim.visualMode && !cm.somethingSelected()) exitVisualMode(cm, false);
		else if (!vim.visualMode && !vim.insertMode && cm.somethingSelected()) {
			vim.visualMode = true;
			vim.visualLine = false;
			cm_adapter_default.signal(cm, "vim-mode-change", { mode: "visual" });
		}
		if (vim.visualMode) {
			var headOffset = !cursorIsBefore(head, anchor) ? -1 : 0;
			var anchorOffset = cursorIsBefore(head, anchor) ? -1 : 0;
			head = offsetCursor(head, 0, headOffset);
			anchor = offsetCursor(anchor, 0, anchorOffset);
			vim.sel = {
				anchor,
				head
			};
			updateMark(cm, vim, "<", cursorMin(head, anchor));
			updateMark(cm, vim, ">", cursorMax(head, anchor));
		} else if (!vim.insertMode) vim.lastHPos = cm.getCursor().ch;
	}
	/** Wrapper for special keys pressed in insert mode */
	function InsertModeKey(keyName) {
		this.keyName = keyName;
	}
	/**
	* Handles raw key down events from the text area.
	* - Should only be active in insert mode.
	* - For recording deletes in insert mode.
	*/
	function onKeyEventTargetKeyDown(e) {
		var lastChange = vimGlobalState.macroModeState.lastInsertModeChanges;
		var keyName = cm_adapter_default.keyName(e);
		if (!keyName) return;
		function onKeyFound() {
			if (lastChange.maybeReset) {
				lastChange.changes = [];
				lastChange.maybeReset = false;
			}
			lastChange.changes.push(new InsertModeKey(keyName));
			return true;
		}
		if (keyName.indexOf("Delete") != -1 || keyName.indexOf("Backspace") != -1) cm_adapter_default.lookupKey(keyName, "vim-insert", onKeyFound);
	}
	/**
	* Repeats the last edit, which includes exactly 1 command and at most 1
	* insert. Operator and motion commands are read from lastEditInputState,
	* while action commands are read from lastEditActionCommand.
	*
	* If repeatForInsert is true, then the function was called by
	* exitInsertMode to repeat the insert mode changes the user just made. The
	* corresponding enterInsertMode call was made with a count.
	*/
	function repeatLastEdit(cm, vim, repeat, repeatForInsert) {
		var macroModeState = vimGlobalState.macroModeState;
		macroModeState.isPlaying = true;
		var isAction = !!vim.lastEditActionCommand;
		var cachedInputState = vim.inputState;
		function repeatCommand() {
			if (isAction) commandDispatcher.processAction(cm, vim, vim.lastEditActionCommand);
			else commandDispatcher.evalInput(cm, vim);
		}
		function repeatInsert(repeat$1) {
			if (macroModeState.lastInsertModeChanges.changes.length > 0) {
				repeat$1 = !vim.lastEditActionCommand ? 1 : repeat$1;
				var changeObject = macroModeState.lastInsertModeChanges;
				repeatInsertModeChanges(cm, changeObject.changes, repeat$1);
			}
		}
		vim.inputState = vim.lastEditInputState;
		if (isAction && vim.lastEditActionCommand.interlaceInsertRepeat) for (var i = 0; i < repeat; i++) {
			repeatCommand();
			repeatInsert(1);
		}
		else {
			if (!repeatForInsert) repeatCommand();
			repeatInsert(repeat);
		}
		vim.inputState = cachedInputState;
		if (vim.insertMode && !repeatForInsert) exitInsertMode(cm);
		macroModeState.isPlaying = false;
	}
	function repeatInsertModeChanges(cm, changes, repeat) {
		function keyHandler(binding) {
			if (typeof binding == "string") cm_adapter_default.commands[binding](cm);
			else binding(cm);
			return true;
		}
		var head = cm.getCursor("head");
		var visualBlock = vimGlobalState.macroModeState.lastInsertModeChanges.visualBlock;
		if (visualBlock) {
			selectForInsert(cm, head, visualBlock + 1);
			repeat = cm.listSelections().length;
			cm.setCursor(head);
		}
		for (var i = 0; i < repeat; i++) {
			if (visualBlock) cm.setCursor(offsetCursor(head, i, 0));
			for (var j = 0; j < changes.length; j++) {
				var change = changes[j];
				if (change instanceof InsertModeKey) cm_adapter_default.lookupKey(change.keyName, "vim-insert", keyHandler);
				else if (typeof change == "string") {
					window.cm = cm;
					cm.replaceSelections(change);
				} else {
					var start = cm.getCursor();
					var end = offsetCursor(start, 0, change[0].length);
					cm.replaceRange(change[0], start, end);
					cm.setCursor(end);
				}
			}
		}
		if (visualBlock) cm.setCursor(offsetCursor(head, 0, 1));
	}
	resetVimGlobalState();
	return vimApi;
};
cm_adapter_default.Vim = Vim();
var keymap_vim_default = cm_adapter_default;

//#endregion
//#region src/statusbar.ts
var VimStatusBar = class {
	constructor(node, editor, sanitizer = null) {
		this.input = null;
		this.closeInput = () => {
			this.removeInputListeners();
			this.input = null;
			this.setSec("");
			if (this.editor) this.editor.focus();
		};
		this.clear = () => {
			this.setInnerHtml_(this.node, "");
		};
		this.inputKeyUp = (e) => {
			if (!this.input) return;
			const { options } = this.input;
			if (options && options.onKeyUp) options.onKeyUp(e, e.target.value, this.closeInput);
		};
		this.inputKeyInput = (e) => {
			if (!this.input) return;
			const { options } = this.input;
			if (options && options.onKeyInput) options.onKeyInput(e, e.target.value, this.closeInput);
		};
		this.inputBlur = (event) => {
			if (!this.input) return;
			const { options } = this.input;
			if (options === null || options === void 0 ? void 0 : options.onBlur) options.onBlur(event, this.closeInput);
			if (options === null || options === void 0 ? void 0 : options.closeOnBlur) this.closeInput();
		};
		this.inputKeyDown = (e) => {
			if (!this.input) return;
			const { options, callback } = this.input;
			if (options && options.onKeyDown && options.onKeyDown(e, e.target.value, this.closeInput)) return;
			if (e.keyCode === 27 || options && options.closeOnEnter !== false && e.keyCode == 13) {
				this.input.node.blur();
				e.stopPropagation();
				this.closeInput();
			}
			if (e.keyCode === 13 && callback) {
				e.stopPropagation();
				e.preventDefault();
				callback(e.target.value);
			}
		};
		this.node = node;
		this.modeInfoNode = document.createElement("span");
		this.secInfoNode = document.createElement("span");
		this.notifNode = document.createElement("span");
		this.notifNode.className = "vim-notification";
		this.keyInfoNode = document.createElement("span");
		this.keyInfoNode.setAttribute("style", "float: right");
		this.node.appendChild(this.modeInfoNode);
		this.node.appendChild(this.secInfoNode);
		this.node.appendChild(this.notifNode);
		this.node.appendChild(this.keyInfoNode);
		this.toggleVisibility(false);
		this.editor = editor;
		this.sanitizer = sanitizer;
	}
	setMode(ev) {
		if (ev.mode === "visual") {
			if (ev.subMode === "linewise") this.setText("--VISUAL LINE--");
			else if (ev.subMode === "blockwise") this.setText("--VISUAL BLOCK--");
			else this.setText("--VISUAL--");
			return;
		}
		this.setText(`--${ev.mode.toUpperCase()}--`);
	}
	setKeyBuffer(key) {
		this.keyInfoNode.textContent = key;
	}
	setSec(text, callback, options) {
		this.notifNode.textContent = "";
		if (text === void 0) return this.closeInput;
		this.setInnerHtml_(this.secInfoNode, text);
		const input = this.secInfoNode.querySelector("input");
		if (input) {
			input.focus();
			this.input = {
				callback,
				options,
				node: input
			};
			if (options) {
				if (options.selectValueOnOpen) input.select();
				if (options.value) input.value = options.value;
			}
			this.addInputListeners();
		}
		return this.closeInput;
	}
	setText(text) {
		this.modeInfoNode.textContent = text;
	}
	toggleVisibility(toggle) {
		if (toggle) this.node.style.display = "block";
		else this.node.style.display = "none";
		if (this.input) this.removeInputListeners();
		if (this.notifTimeout) clearTimeout(this.notifTimeout);
	}
	addInputListeners() {
		if (!this.input) return;
		const { node } = this.input;
		node.addEventListener("keyup", this.inputKeyUp);
		node.addEventListener("keydown", this.inputKeyDown);
		node.addEventListener("input", this.inputKeyInput);
		node.addEventListener("blur", this.inputBlur);
	}
	removeInputListeners() {
		if (!this.input || !this.input.node) return;
		const { node } = this.input;
		node.removeEventListener("keyup", this.inputKeyUp);
		node.removeEventListener("keydown", this.inputKeyDown);
		node.removeEventListener("input", this.inputKeyInput);
		node.removeEventListener("blur", this.inputBlur);
	}
	showNotification(text) {
		const sp = document.createElement("span");
		this.setInnerHtml_(sp, text);
		this.notifNode.textContent = sp.textContent;
		this.notifTimeout = setTimeout(() => {
			this.notifNode.textContent = "";
		}, 5e3);
	}
	setInnerHtml_(element, htmlContents) {
		while (element.childNodes.length) element.removeChild(element.childNodes[0]);
		if (!htmlContents) return;
		if (typeof htmlContents === "string") {
			element.appendChild(document.createTextNode(htmlContents));
			return;
		}
		const node = this.sanitizer ? this.sanitizer(htmlContents) : htmlContents;
		element.appendChild(node);
	}
};

//#endregion
//#region src/index.ts
function initVimMode(editor, statusbarNode = null, StatusBarClass = VimStatusBar, sanitizer = null) {
	const vimAdapter = new keymap_vim_default(editor);
	if (!statusbarNode) {
		vimAdapter.attach();
		return vimAdapter;
	}
	const statusBar = new StatusBarClass(statusbarNode, editor, sanitizer);
	let keyBuffer = "";
	vimAdapter.on("vim-mode-change", (mode) => {
		statusBar.setMode(mode);
	});
	vimAdapter.on("vim-keypress", (key) => {
		if (key === ":") keyBuffer = "";
		else keyBuffer += key;
		statusBar.setKeyBuffer(keyBuffer);
	});
	vimAdapter.on("vim-command-done", () => {
		keyBuffer = "";
		statusBar.setKeyBuffer(keyBuffer);
	});
	vimAdapter.on("dispose", function() {
		statusBar.toggleVisibility(false);
		statusBar.closeInput();
		statusBar.clear();
	});
	statusBar.toggleVisibility(true);
	vimAdapter.setStatusBar(statusBar);
	vimAdapter.attach();
	return vimAdapter;
}

//#endregion
exports.StatusBar = VimStatusBar;
exports.VimMode = keymap_vim_default;
exports.initVimMode = initVimMode;
});
//# sourceMappingURL=monaco-vim.umd.js.map